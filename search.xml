<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>12.19技术分享</title>
    <url>/2019/12/19/2019-12-19-19jishu/</url>
    <content><![CDATA[<h1 id="mysql重置密码-MySQL-服务无法启动"><a href="#mysql重置密码-MySQL-服务无法启动" class="headerlink" title="mysql重置密码,MySQL 服务无法启动:"></a>mysql重置密码,MySQL 服务无法启动:</h1><h3 id="mysql重置密码"><a href="#mysql重置密码" class="headerlink" title="mysql重置密码:"></a>mysql重置密码:</h3><ol>
<li><p>打开命令窗口cmd，输入命令：net stop mysql，停止MySQL服务，</p>
</li>
<li><p>开启跳过密码验证登录的MySQL服务</p>
<pre><code> 输入命令  mysqld --console --skip-grant-tables --shared-memory 
</code></pre></li>
<li><p>再打开一个新的cmd，无密码登录MySQL，输入登录命令：mysql -u root -p</p>
</li>
<li><p>密码置为空，命令如下：</p>
<p> use mysql</p>
<p> update user set authentication_string=’’ where user=’root’;</p>
</li>
</ol>
<ol start="5">
<li><p>退出mysql，执行命令：</p>
<p> quit</p>
</li>
</ol>
<ol start="6">
<li><p>关闭以-console –skip-grant-tables –shared-memory 启动的MySQL服务，</p>
</li>
<li><p>打开命令框，输入：net start mysql  启动MySQL服务，一管理员的身份运行cmd。</p>
</li>
<li><p>步骤4密码已经置空，所以无密码状态登录MySQL，输入登录命令：mysql -u root -p</p>
</li>
<li><p>利用上一篇博客中更改密码的命令，成功修改密码:</p>
</li>
</ol>
<p>ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘新密码’;</p>
<ol start="10">
<li>验证更改后密码正确登录</li>
</ol>
<p>输入quit，退出当前登录，输入登录命令：mysql -u root -p</p>
<p>输入密码，成功登录，到此，重置密码结束。</p>
<h3 id="MySQL-服务无法启动"><a href="#MySQL-服务无法启动" class="headerlink" title="MySQL 服务无法启动:"></a>MySQL 服务无法启动:</h3><p><code>安装MySQL启动时出现“net start mysql MySQL 服务正在启动 MySQL 服务无法启动。 服务没有报告任何错误</code>  </p>
<ol>
<li>进入mysql的bin目录.</li>
<li>执行mysqld –initialize-insecure ，执行结束后没有输出信息.</li>
<li>再次启动，成功.</li>
</ol>
<h3 id="关联mysql失败-Server-returns-invalid-timezone-Go-to-‘Advanced’-tab-and-set-‘serverTimezon’"><a href="#关联mysql失败-Server-returns-invalid-timezone-Go-to-‘Advanced’-tab-and-set-‘serverTimezon’" class="headerlink" title="关联mysql失败_Server returns invalid timezone. Go to ‘Advanced’ tab and set ‘serverTimezon’:"></a>关联mysql失败_Server returns invalid timezone. Go to ‘Advanced’ tab and set ‘serverTimezon’:</h3><p>mysql修改时区:  </p>
<p>时区错误，MySQL默认的时区是UTC时区，比北京时间晚8个小时。</p>
<p>所以要修改mysql的时长</p>
<p>在mysql的命令模式下，输入：</p>
<p>set global time_zone=’+8:00’;</p>
<p>再次连接成功</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL重置密码</tag>
        <tag>MySQL 服务无法启动</tag>
      </tags>
  </entry>
  <entry>
    <title>12.18Java学习进度</title>
    <url>/2019/12/18/2019-12-18-18ribao/</url>
    <content><![CDATA[<h1 id="SpringBoot-Servlet-Filter-SpringBoot-Task"><a href="#SpringBoot-Servlet-Filter-SpringBoot-Task" class="headerlink" title="SpringBoot Servlet/Filter,SpringBoot Task:"></a>SpringBoot Servlet/Filter,SpringBoot Task:</h1><h3 id="SpringBoot-Servlet-Filter"><a href="#SpringBoot-Servlet-Filter" class="headerlink" title="SpringBoot Servlet/Filter:"></a>SpringBoot Servlet/Filter:</h3><ol>
<li><p>Servlet应用</p>
<ul>
<li><p>按Servlet标准编写实现组件</p>
<pre><code>  @WebServlet(name=&quot;helloservlet&quot;,urlPatterns= {&quot;/hello&quot;,&quot;/hello.do&quot;},loadOnStartup=1)
  public class HelloServlet extends HttpServlet{

      public void service(HttpServletRequest request,HttpServletResponse response) throws IOException {
          response.setContentType(&quot;text/html;charset=UTF-8&quot;);
          PrintWriter out = response.getWriter();
          out.println(&quot;Hello SpringBoot Servlet&quot;);
          out.flush();
          out.close();
      }
  }
</code></pre></li>
<li><p>使用@WebServlet和@ServletComponentScan配置</p>
<pre><code>  @SpringBootApplication
  @ServletComponentScan//扫描包下的@WebServlet、@WebFilter、@WebListener
  public class RunBoot {

      public static void main(String[] args) {
          SpringApplication.run(RunBoot.class, args);
      }

  }
</code></pre></li>
</ul>
</li>
<li><p>Filter应用</p>
<ul>
<li><p>按Filter标准编写实现组件</p>
<pre><code>  //@WebFilter(filterName=&quot;myfilter&quot;,urlPatterns= {&quot;/hello&quot;,&quot;/hello.do&quot;})
  @WebFilter(filterName=&quot;myfilter&quot;,servletNames= {&quot;helloservlet&quot;})
  public class MyFilter implements Filter{

      public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
              throws IOException, ServletException {
          System.out.println(&quot;进入MyFilter&quot;);
          chain.doFilter(request, response);
          System.out.println(&quot;退出MyFilter&quot;);
      }

  }
</code></pre></li>
<li><p>使用@WebFilter和@ServletComponentScan配置</p>
</li>
</ul>
</li>
</ol>
<pre><code>    同上

提示：多个Filter过滤器，执行顺序按类名字典顺序排列。
</code></pre><ol start="3">
<li>通过@Bean方式配置Servlet或Filter</li>
</ol>
<pre><code>    @Configuration
    public class MyServletConfiguration {

        @Bean
        public ServletRegistrationBean&lt;Servlet&gt; someServlet(){
            ServletRegistrationBean&lt;Servlet&gt; bean = 
                    new ServletRegistrationBean&lt;Servlet&gt;();
            bean.setServlet(new SomeServlet());
            List&lt;String&gt; urls = new ArrayList&lt;String&gt;();
            urls.add(&quot;/some&quot;);
            urls.add(&quot;/some.do&quot;);
            bean.setUrlMappings(urls);
            return bean;
        }

        @Bean
        public FilterRegistrationBean&lt;Filter&gt; somefilter(){
            FilterRegistrationBean&lt;Filter&gt; bean = new FilterRegistrationBean&lt;Filter&gt;();
            bean.setFilter(new SomeFilter());
            List&lt;String&gt; servlets = new ArrayList&lt;String&gt;();
            servlets.add(&quot;helloservlet&quot;);
            bean.setServletNames(servlets);
            return bean;
        }

    }
</code></pre><h2 id="SpringBoot-Task"><a href="#SpringBoot-Task" class="headerlink" title="SpringBoot Task:"></a>SpringBoot Task:</h2><h3 id="启动Task"><a href="#启动Task" class="headerlink" title="启动Task:"></a>启动Task:</h3><p>tomcat服务器启动后，自动执行一个处理，例如解析配置文件，加载缓存数据。</p>
<p>SpringBoot提供了ApplicationRunner和CommandLineRunner两个接口，用于实现启动任务封装。</p>
<ul>
<li><p>ApplicationRunner</p>
<pre><code>  @Component
  @Order(2)
  public class MyTask1 implements ApplicationRunner{

      public void run(ApplicationArguments args) throws Exception {
          System.out.println(&quot;启动后立刻解析某个配置文件&quot;+new Date());
      }

  }
</code></pre></li>
<li><p>CommandLineRunner</p>
<pre><code>  @Component
  @Order(1)
  public class MyTask2 implements CommandLineRunner{

      public void run(String... args) throws Exception {
          System.out.println(&quot;启动后自动为缓存加载数据&quot;+new Date());
          Thread.sleep(10000);
      }

  }
</code></pre></li>
</ul>
<p>提示：通过@Order注解指定调用顺序，1，2，3；多个任务是采用同步执行，单线程操作。</p>
<h3 id="定时Task"><a href="#定时Task" class="headerlink" title="定时Task"></a>定时Task</h3><p>可以按指定时间或周期频率调用某个任务逻辑。</p>
<p>Timer、TimerTask；quartz；spring task</p>
<h3 id="cron表达式规则："><a href="#cron表达式规则：" class="headerlink" title="cron表达式规则："></a>cron表达式规则：</h3><p>由 秒  分  时  日   月  星期  年(可省略) 七部分构成。</p>
<pre><code>  * ： 表示每秒、每分、每时、每日、每月 、星期每天
  / ： 表示增量，0/5 表示0、5、10、15...; 3/5 表示3、8、13、18...
 ? ： 只用在日和星期两部分，为了解决冲突。用日做限制，星期用?；如果星期做限制，日用?
 L ： 用在日和星期位置，最后一天，星期六

 0 30 8-17 * * ?
 0 0 24 L * ?
 0/5 * * * * ?
</code></pre>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot Servlet/Filter</tag>
        <tag>SpringBoot Task</tag>
      </tags>
  </entry>
  <entry>
    <title>12.17Java学习进度</title>
    <url>/2019/12/17/2019-12-17-17ribao/</url>
    <content><![CDATA[<h1 id="Spring-MVC-拦截器-Spring-MVC-异常处理机制"><a href="#Spring-MVC-拦截器-Spring-MVC-异常处理机制" class="headerlink" title="Spring MVC 拦截器,Spring MVC 异常处理机制:"></a>Spring MVC 拦截器,Spring MVC 异常处理机制:</h1><h3 id="什么是Rest，有什么特点"><a href="#什么是Rest，有什么特点" class="headerlink" title="什么是Rest，有什么特点"></a>什么是Rest，有什么特点</h3><p>Rest、Restful</p>
<p>REST：是一种规则或风格。</p>
<p>Roy Thomas Fielding</p>
<p>RESTFul：按RESTful规则的一种应用。</p>
<p>目前主流的RESTful应用，都是REST规则在HTTP协议之上一种应用。</p>
<p>基于URL定位资源，通过HTTP动作做不同操作。</p>
<pre><code>http://localhost:8888/news/2
GET 查询
POST 添加
PUT 更新
DELETE 删除
</code></pre><p>使用技术目的：前后分离模式，异构系统之间交互更规范。搜索引擎更敏感。</p>
<h3 id="什么是Thymeleaf，有什么特点，常用属性标记"><a href="#什么是Thymeleaf，有什么特点，常用属性标记" class="headerlink" title="什么是Thymeleaf，有什么特点，常用属性标记"></a>什么是Thymeleaf，有什么特点，常用属性标记</h3><p>Thymeleaf是一种模板技术，例如veloctiy、freemarker等。</p>
<p>Thymeleaf是对JSP替代，性能好。跟其他模板技术比，扩展名为html可以直接用浏览器打开，所见即所得。SpringBoot主推Thymeleaf。</p>
<p>th:text 、th:each、 th:if、 th:value、 th:href等</p>
<h2 id="SpringBoot-MVC机制"><a href="#SpringBoot-MVC机制" class="headerlink" title="SpringBoot MVC机制:"></a>SpringBoot MVC机制:</h2><h3 id="Spring-MVC-拦截器"><a href="#Spring-MVC-拦截器" class="headerlink" title="Spring MVC 拦截器:"></a>Spring MVC 拦截器:</h3><ol>
<li><p>按规则编写拦截器组件，实现HandlerInterceptor接口</p>
<pre><code> @Component//扫描
 public class SomeInterceptor implements HandlerInterceptor{

     //在controller前执行，如果方法返回false就是阻止流程继续执行
     public boolean preHandle(HttpServletRequest request, 
             HttpServletResponse response, Object handler)
             throws Exception {
         System.out.println(&quot;preHandle&quot;);
         return true;
     }

     //在controller后执行，可以改变ModelAndView结果
     public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
             @Nullable ModelAndView modelAndView) throws Exception {
         System.out.println(&quot;postHandle&quot;);
     }

     //在响应输出前
     public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,
             @Nullable Exception ex) throws Exception {
         System.out.println(&quot;afterCompletion&quot;);
     }

 }
</code></pre></li>
</ol>
<ol start="2">
<li><p>编写配置类，实现WebMvcConfigurer接口</p>
<pre><code> @Configuration
 public class MyInterceptorConfiguration implements WebMvcConfigurer{

     @Autowired
     private SomeInterceptor some;

     public void addInterceptors(InterceptorRegistry registry) {

         registry.addInterceptor(some).addPathPatterns(&quot;/demo1&quot;);
     }

 }
</code></pre></li>
</ol>
<h3 id="Spring-MVC-异常处理机制"><a href="#Spring-MVC-异常处理机制" class="headerlink" title="Spring MVC 异常处理机制:"></a>Spring MVC 异常处理机制:</h3><ol>
<li><p>SpringBoot异常处理过程</p>
<p> SpringBoot提供了一个自动配置组件ErrorMvcAutoConfiguration,自动创建一个BasicErrorController对象，该对象有两个/error请求处理，一个返回html响应；另一个返回json响应。当Boot底层发生异常，会自动以转发方式调用/error请求，返回处理结果，显示白板界面。</p>
</li>
<li><p>自定义异常处理Controller</p>
<p> 编写Controller，实现ErrorController，底层自动配置BasicErrorController将失效。</p>
<pre><code> @Controller
 @RequestMapping(&quot;/error&quot;)
 public class MyErrorController implements ErrorController{

     public String getErrorPath() {
         return &quot;/error&quot;;
     }

     @RequestMapping(produces=MediaType.TEXT_HTML_VALUE)
     public ModelAndView errorHtml() {
         ModelAndView mav = new ModelAndView();
         mav.setViewName(&quot;myerror&quot;);
         mav.getModel().put(&quot;msg&quot;, &quot;自定义异常处理&quot;);
         return mav;
     }

     @RequestMapping
     @ResponseBody
     public Object error() {
         Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;();
         map.put(&quot;msg&quot;, &quot;自定义异常&quot;);
         map.put(&quot;error&quot;, &quot;json类型响应&quot;);
         return map;
     }

 }
</code></pre><p> 提示：追加thymeleaf支持，在templates下添加myerror.html模板文件。</p>
</li>
</ol>
<ol start="3">
<li><p>@ExceptionHanlder处理</p>
<p> 在Controller中添加异常处理方法，处理当前Controller内的异常。</p>
<pre><code> @Controller
 public class Demo2Controller{

     @GetMapping(&quot;/demo2&quot;)
     @ResponseBody
     public Object say() {
         Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;();
         data = null;
         data.put(&quot;id&quot;, 1);
         data.put(&quot;name&quot;, &quot;tom&quot;);
         return data;
     }

     @ExceptionHandler
     @ResponseBody
     public Object handleException(Exception ex) {
         Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;();
         data.put(&quot;msg&quot;, &quot;发生异常了&quot;);
         data.put(&quot;type&quot;, ex.getClass().getName());
         return data;
     }

 }
</code></pre><p> 提示：可以提成一个BasicController父类处理多个Controller异常，也可以添加@ControllerAdvice用于所有Controller异常处理。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring MVC 拦截器</tag>
        <tag>Spring MVC 异常处理机制</tag>
      </tags>
  </entry>
  <entry>
    <title>12.16Java学习进度</title>
    <url>/2019/12/16/2019-12-16-16ribao/</url>
    <content><![CDATA[<h1 id="SpringBoot-MVC快速开发"><a href="#SpringBoot-MVC快速开发" class="headerlink" title="SpringBoot MVC快速开发:"></a>SpringBoot MVC快速开发:</h1><p>主要针对Spring MVC进行的封装应用。</p>
<h3 id="基于Spring-MVC开发Rest服务"><a href="#基于Spring-MVC开发Rest服务" class="headerlink" title="基于Spring MVC开发Rest服务"></a>基于Spring MVC开发Rest服务</h3><p>rest请求–》Spring MVC–》返回JSON结果</p>
<p>/news/xx GET —&gt; Spring MVC –&gt; 返回某个新闻的json结果</p>
<p>/news/list GET —&gt; Spring MVC –&gt; 返回某个新闻列表的json结果</p>
<h3 id="基于Spring-MVC开发JSP应用"><a href="#基于Spring-MVC开发JSP应用" class="headerlink" title="基于Spring MVC开发JSP应用"></a>基于Spring MVC开发JSP应用</h3><p>http请求–》Spring MVC–》list.jsp–》返回HTML列表界面</p>
<ol>
<li><p>pom.xml额外增加jar引入</p>
<ul>
<li>jasper引擎(tomcat解析jsp,内置tomcat不带)</li>
<li>jstl（JSP标签）</li>
</ul>
</li>
<li><p>application.properties额外增加参数</p>
<pre><code> spring.mvc.view.prefix=/
 spring.mvc.view.suffix=.jsp
</code></pre></li>
<li><p>controller返回ModelAndView（视图名字和传出来的数据对象）</p>
<pre><code> public ModelAndView xx(){
     // ... ...
 }
</code></pre></li>
<li><p>在src/main/webapp目录下定义jsp文件</p>
<p> <img src="webapp.png" alt></p>
</li>
</ol>
<h3 id="基于Spring-MVC开发Thymeleaf应用"><a href="#基于Spring-MVC开发Thymeleaf应用" class="headerlink" title="基于Spring MVC开发Thymeleaf应用"></a>基于Spring MVC开发Thymeleaf应用</h3><p>模板技术是对JSP一种替代技术。例如velocity（<em>.vm+VTL）、freemarker（</em>.ftl+FTL）、Thymeleaf（*.html+THTL）</p>
<p>JSP和模板技术区别：</p>
<ul>
<li>JSP编译成Servlet，然后由Servlet生成HTML响应输出;模板是将模板和数据直接输出位HTML响应（模板技术效率高）</li>
<li>模板技术只识别模板表达式语言；JSP使用的技术EL、JSTL、框架标签、Java代码等（模板技术简单易用）</li>
</ul>
<p>http请求–》Spring MVC–》list.html–》返回HTML列表界面</p>
<ol>
<li><p>在pom.xml引入jar包</p>
<ul>
<li>spring-boot-starter-thymeleaf</li>
<li>spring-boot-starter-web</li>
<li>jdbc、驱动、devtools</li>
</ul>
</li>
<li><p>在application.properties</p>
<p> 配置datasource、tomcat端口，其他不同配，默认thymeleaf访问src/main/resources/templates目录，扩展名*.html</p>
</li>
<li><p>编写Controller、service、dao等业务组件</p>
<p> 返回ModelAndView，去查找html模板，给模板传递数据</p>
</li>
<li><p>编写html模板文件</p>
<p> 在src/main/resources/templates目录定义html模板，里面使用th:xxx表达式语言。</p>
<pre><code> &lt;html xmlns:th=&quot;https://www.thymeleaf.org&quot;&gt;
     ... ...
 &lt;/html&gt;
</code></pre></li>
</ol>
<h3 id="SpringBoot-MVC机制"><a href="#SpringBoot-MVC机制" class="headerlink" title="SpringBoot MVC机制"></a>SpringBoot MVC机制</h3><ol>
<li><p>SpringBoot静态资源存放和访问</p>
<p> SpringBoot提供了src/main/resources目录下约定几个存放位置</p>
<ul>
<li>META-INF/resources（优先级最高）</li>
<li>resources</li>
<li>static</li>
<li><p>public（优先级最低）</p>
<p>如果需要修改静态资源目录，可以自定义配置</p>
<p>  @Configuration<br>  public class MyResourceConfiguration implements WebMvcConfigurer{</p>
<pre><code>  public void addResourceHandlers(ResourceHandlerRegistry registry) {
      registry.addResourceHandler(&quot;/**&quot;)
          .addResourceLocations(
              &quot;classpath:/mystatic/&quot;,
              &quot;classpath:/resources/&quot;,
              &quot;classpath:/static/&quot;,
              &quot;classpath:/public/&quot;);
  }
</code></pre><p>  }</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot MVC快速开发</tag>
      </tags>
  </entry>
  <entry>
    <title>12.14Java学习进度</title>
    <url>/2019/12/14/2019-12-14-14ribao/</url>
    <content><![CDATA[<h1 id="SpringBoot数据库访问-DataSource连接池-Spring-JPA"><a href="#SpringBoot数据库访问-DataSource连接池-Spring-JPA" class="headerlink" title="SpringBoot数据库访问,DataSource连接池,Spring JPA:"></a>SpringBoot数据库访问,DataSource连接池,Spring JPA:</h1><h3 id="DataSource连接池"><a href="#DataSource连接池" class="headerlink" title="DataSource连接池"></a>DataSource连接池</h3><p>连接池优点：连接对象重用提升程序性能（避免频繁创建和释放Connection对象）；控制最大连接数有效保护数据库稳定运行。</p>
<p>各种不同的连接池组件都必须实现DataSource接口。</p>
<p>SpringBoot中提供了DataSourceAutoConfiguration自动配置组件，用于创建DataSource对象。（依次创建Hikari、Tomcat、DBCP2连接池对象，也可以根据spring.datasource.type指定类型创建）</p>
<ol>
<li><p>引入驱动包和spring-boot-starter-jdbc </p>
<p> boot2.x版本默认引入hikari，1.x默认引入tomcat-jdbc,将hikaricp从spring-boot-starter-jdbc排除方法如下</p>
<pre><code> &lt;dependency&gt;
     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
     &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
     &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;
     &lt;exclusions&gt;
         &lt;exclusion&gt;
             &lt;groupId&gt;com.zaxxer&lt;/groupId&gt;
             &lt;artifactId&gt;HikariCP&lt;/artifactId&gt;
         &lt;/exclusion&gt;
     &lt;/exclusions&gt;
 &lt;/dependency&gt;
</code></pre></li>
<li><p>在application.properties配置文件中定义db参数</p>
<pre><code> spring.datasource.username=root
 spring.datasource.password=123456
 spring.datasource.url=jdbc:mysql://localhost:3306/jd
 spring.datasource.driverClassName=com.mysql.jdbc.Driver
</code></pre></li>
<li><p>开启自动配置，会自动调用DataSourceAutoConfiguration创建连接池</p>
<pre><code> 优先级为：hikari、tomcat、dbcp2
</code></pre></li>
<li><p>利用spring.datasource.type创建指定类型的连接池</p>
<pre><code> spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
</code></pre></li>
<li><p>如果通过@Bean自定义DataSource对象，自动配置dataSource不会再创建</p>
<pre><code> @Bean
 @Primary
 @ConfigurationProperties(prefix=&quot;spring.datasource&quot;)
 public DataSource dbcp() {
     BasicDataSource dbcp = new BasicDataSource();
     return dbcp;
 }
</code></pre></li>
</ol>
<h3 id="Spring-DAO-JdbcTemplate"><a href="#Spring-DAO-JdbcTemplate" class="headerlink" title="Spring DAO (JdbcTemplate)"></a>Spring DAO (JdbcTemplate)</h3><pre><code>spring-boot-starter-jdbc
mysql-connector-java
</code></pre><ol>
<li>创建连接池对象（参考上面案例过程）</li>
<li>根据表编写实体类型</li>
<li>定义Dao接口</li>
<li>定义Dao实现组件，注入JdbcTemplate对象使用</li>
</ol>
<h3 id="Spring-MyBatis"><a href="#Spring-MyBatis" class="headerlink" title="Spring MyBatis"></a>Spring MyBatis</h3><pre><code>spring-boot-starter-jdbc
mybatis-spring-boot-starter
mysql-connector-java
</code></pre><h3 id="使用XML文件定义SQL"><a href="#使用XML文件定义SQL" class="headerlink" title="使用XML文件定义SQL:"></a>使用XML文件定义SQL:</h3><ol>
<li>创建连接池对象（参考上面案例过程）</li>
<li>根据表编写实体类型</li>
<li>定义SQL语句XML文件（配置mybatis.mapperLocations=classpath:sql/*.xml）</li>
<li>定义Mapper映射器接口（在启动类前加@MapperScan）</li>
<li>定义启动类（@SpringBootApplication+@MapperScan）</li>
<li><p>添加pageHelper-spring-boot-starter启动器追加分页功能</p>
<p> PageHelper.startPage(1, 3);//设置分页参数<br> List<news> list = newDao.findAll();//pageHelper先将sql封装成分页sql，再执行查询</news></p>
</li>
</ol>
<h3 id="使用注解定义SQL"><a href="#使用注解定义SQL" class="headerlink" title="使用注解定义SQL:"></a>使用注解定义SQL:</h3><ol>
<li>创建连接池对象（参考上面案例过程）</li>
<li>根据表编写实体类型</li>
<li><p>定义Mapper映射器接口，（在启动类前加@MapperScan）</p>
<p> 利用@Select、@Insert、@Update、@Delete定义SQL语句</p>
</li>
<li><p>定义启动类（@SpringBootApplication+@MapperScan）</p>
</li>
<li>添加pageHelper-spring-boot-starter启动器追加分页功能</li>
</ol>
<h3 id="参数映射-和-区别"><a href="#参数映射-和-区别" class="headerlink" title="参数映射#{}和${}区别:"></a>参数映射#{}和${}区别:</h3><pre><code>1. #{}采用PrepareStatement机制执行SQL；${}采用Statement拼SQL执行

2. 字段值位置建议使用#{}安全;表名和字段名位置的参数需要使用${}不要使用#{}
</code></pre><h3 id="Spring-JPA"><a href="#Spring-JPA" class="headerlink" title="Spring JPA"></a>Spring JPA</h3><pre><code>spring-boot-starter-jdbc
spring-boot-starter-jpa
mysql-connector-java
</code></pre><ol>
<li>创建连接池对象（参考上面案例过程）</li>
<li>根据表编写实体类型（@Entity、@Table、@id、@Column映射描述）</li>
<li>定义JPA Repository接口（继承JpaRepository、PagingAndSortingRepository或CrudRepository等）</li>
<li>定义启动类（@SpringBootApplication）</li>
</ol>
<h3 id="Spring-JPA-扩展"><a href="#Spring-JPA-扩展" class="headerlink" title="Spring JPA 扩展"></a>Spring JPA 扩展</h3><ol>
<li><p>按规则定义方法名</p>
<pre><code> //select * from news where title like ?
 public List&lt;News&gt; findByTitleLike(String title);
 //select * from news where id&lt;?
 public List&lt;News&gt; findByIdLessThan(int id);
</code></pre></li>
<li><p>定义SQL语句</p>
<pre><code> @Query(nativeQuery=true,value=&quot;select * from news where title like :title&quot;)
 public List&lt;News&gt; findSQL(@Param(&quot;title&quot;)String title);
</code></pre></li>
<li><p>定义JPQL面向对象语句</p>
<pre><code> //JPQL 使用类型名和属性名，区分大小写
 @Query(&quot;from News where id &lt; :no&quot;)
 public List&lt;News&gt; findSQL2(@Param(&quot;no&quot;)int id);
</code></pre></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot数据库访问</tag>
        <tag>DataSource连接池</tag>
        <tag>Spring JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>12.13Java学习进度</title>
    <url>/2019/12/13/2019-12-13-13ribao/</url>
    <content><![CDATA[<h1 id="SpringBoot-组件扫描-SpringBoot-自动配置"><a href="#SpringBoot-组件扫描-SpringBoot-自动配置" class="headerlink" title="SpringBoot 组件扫描,SpringBoot 自动配置:"></a>SpringBoot 组件扫描,SpringBoot 自动配置:</h1><h3 id="SpringBoot-组件扫描"><a href="#SpringBoot-组件扫描" class="headerlink" title="SpringBoot 组件扫描"></a>SpringBoot 组件扫描</h3><p>@ComponentScan，在启动类前使用，可以指定扫描包路径，也可以按默认路径规则加载。</p>
<pre><code>@ComponentScan(basePackages= {&quot;cn.xdl&quot;}) //指定扫描包路径
@ComponentScan //默认扫描当前包及子包组件
</code></pre><p>在包中的组件前面，需要使用@Controller、@Service、@Repository、@Component等扫描标记。</p>
<h3 id="SpringBoot自动配置案例（DataSource、JdbcTemplate）"><a href="#SpringBoot自动配置案例（DataSource、JdbcTemplate）" class="headerlink" title="SpringBoot自动配置案例（DataSource、JdbcTemplate）"></a>SpringBoot自动配置案例（DataSource、JdbcTemplate）</h3><ol>
<li><p>在pom.xml引入驱动包、spring-boot-starter-jdbc</p>
<p> spring-boot-starter-jdbc（包含了spring核心容器、spring dao、hikari功能）</p>
</li>
<li><p>在application.properties定义db连接参数</p>
<pre><code> spring.datasource.username=SCOTT
 spring.datasource.password=TIGER
 spring.datasource.url=jdbc:oracle:thin:@localhost:1521:XE
 #spring.datasource.driver-class-name=oracle.jdbc.OracleDriver
</code></pre></li>
<li><p>编写启动类，使用@EnableAutoConfiguration开启自动配置</p>
<p> 实例化SpringBoot容器获取DataSource对象和JdbcTemplate对象。</p>
<pre><code> @EnableAutoConfiguration
 public class RunBoot {

     public static void main(String[] args) {
         ApplicationContext ac = SpringApplication.run(RunBoot.class, args);
         DataSource ds = ac.getBean(DataSource.class);
         System.out.println(ds);
         JdbcTemplate template = ac.getBean(JdbcTemplate.class);
         System.out.println(template);
     }

 }
</code></pre></li>
</ol>
<h3 id="自动配置原理（自动配置类的加载过程）"><a href="#自动配置原理（自动配置类的加载过程）" class="headerlink" title="自动配置原理（自动配置类的加载过程）"></a>自动配置原理（自动配置类的加载过程）</h3><ol>
<li>内部定义了很多自动配置类，在xxx-autoconfigure.jar包的META-INF/spring.factories文件定义。</li>
<li>自动配置类，实际就是才用了@Configuration+@Bean标记实现了Bean定义</li>
<li>在开启@EnableAutoConfiguration标记后，会自动导入AutoConfigurationImportSelector组件，该组件内部调用SpringFactoriesLoader加载autoconfigure.jar包中的spring.factories文件，根据文件定义列表载入各个配置类</li>
<li>各个XxxAutoConfiguration配置类会创建相应对象载入Spring容器中，例如DataSource、JdbcTemplate、DispatcherServlet、HandlerMapping、RedisTemplate、MongoTemplate、RestTemplate等</li>
</ol>
<p>提示： @ConditionalOnClass注解表示能找到指定的实现类才加载配置</p>
<p>##@SpringBootApplication</p>
<p>平时使用时采用@SpringBootApplication,等价于定义@SpringBootConfiguration+@ComponentScan+@EnableAutoConfiguration。</p>
<h3 id="配置参数注入"><a href="#配置参数注入" class="headerlink" title="配置参数注入"></a>配置参数注入</h3><p>将application.properties配置文件中定义的参数取出，写入到Bean对象属性中。</p>
<ul>
<li><p>application.properties参数定义</p>
<pre><code>  spring.datasource.username=SCOTT
  spring.datasource.password=TIGER
  spring.datasource.url=jdbc:oracle:thin:@localhost:1521:XE
  #spring.datasource.driver-class-name=oracle.jdbc.OracleDriver

  db.user=root
  db.password=123456
</code></pre></li>
<li><p>定义实体类</p>
<p>  DbParams实体类，在类前使用注解@ConfigurationProperties</p>
<pre><code>  @Component
  @ConfigurationProperties(prefix=&quot;db&quot;)
  public class DbParams {

      private String user; //对应db.user=xxx
      private String password;//对应db.password=xxx

      public String getUser() {
          return user;
      }
      public void setUser(String user) {
          this.user = user;
      }
      public String getPassword() {
          return password;
      }
      public void setPassword(String password) {
          this.password = password;
      }

  }
</code></pre><p>  OracleParams实体类</p>
<pre><code>  public class OracleParams {

      @Value(&quot;${spring.datasource.username}&quot;)
      private String user;
      private String password;
      private String url;
</code></pre></li>
</ul>
<pre><code>        public String getUser() {
            return user;
        }
        public void setUser(String user) {
            this.user = user;
        }
        public String getPassword() {
            return password;
        }
        public void setPassword(String password) {
            this.password = password;
        }
        public String getUrl() {
            return url;
        }
        public void setUrl(String url) {
            this.url = url;
        }

    }

在@Bean方法前使用注解@ConfigurationProperties

    @Bean
    @ConfigurationProperties(prefix=&quot;spring.datasource&quot;)
    public OracleParams params() {
        return new OracleParams();
    }
</code></pre>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot自动配置</tag>
        <tag>SpringBoot 组件扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>12.12Java学习进度</title>
    <url>/2019/12/12/2019-12-12-12ribao/</url>
    <content><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot:"></a>SpringBoot:</h1><p>Pivotal  SpringBoot、SpringCloud，微服务架构。</p>
<p>SpringBoot : 对Spring框架进行了封装，目的快速搭建Spring应用，快速开发。</p>
<ol>
<li>内置服务器，自动启动和web发布</li>
<li>取消了XML配置，完全采用Java配置模式（注解+编码）</li>
<li>有自动配置机制，可以创建大量常用对象</li>
<li><p>starter启动工具集(jar)引入更加方便</p>
<pre><code> spring-boot-starter //包含ioc、aop、yaml解析、自动配置
 spring-boot-starter-web //包含mvc、rest、tomcat、boot-starter所有包
 spring-boot-starter-jdbc //包含hikari、spring-jdbc
 spring-boot-starter-test //包含junit、spring-test
</code></pre></li>
</ol>
<p><strong>SpringBoot开发体验:</strong>  </p>
<ol>
<li><p>starter工具集导入（pom.xml）</p>
<pre><code> &lt;dependencies&gt;
     &lt;dependency&gt;
         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
         &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
         &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;
     &lt;/dependency&gt;
 &lt;/dependencies&gt;
</code></pre></li>
<li><p>application.properties或application.yml配置文件</p>
<pre><code> server.port=8888
</code></pre></li>
<li><p>业务组件代码（Controller、Service、Dao）</p>
<pre><code> @Controller
 public class HelloController {

     @RequestMapping(&quot;/hello&quot;)
     @ResponseBody
     public String say() {
         return &quot;Hello SpringBoot&quot;;
     }

 }
</code></pre></li>
<li><p>启动类</p>
<pre><code> @SpringBootApplication
 public class RunBoot {

     public static void main(String[] args) {
         SpringApplication.run(RunBoot.class);
     }

 }
</code></pre></li>
</ol>
<p><strong>SpringBoot程序结构:</strong>  </p>
<p>SpringBoot程序由以下几部分构成：</p>
<ol>
<li><p>boot开发包(pom.xml)</p>
<p> spring-boot-starter-xxx</p>
</li>
<li><p>主配置文件</p>
<p> application.properties格式</p>
<p> application.yml格式</p>
</li>
<li><p>启动类main</p>
<p> @SpringBootApplication</p>
<p> SpringApplication.run()</p>
</li>
<li><p>业务处理组件</p>
<p> controller、service、dao、entity</p>
</li>
</ol>
<p><strong>SpringBoot启动过程:</strong>  </p>
<pre><code>SpringApplication.run()方法主要是构建一个Spring容器对象ApplicationContext，对容器环境、bean对象做设置。

//原始Spring通过xml配置文件实例化容器
ApplicationContext ac = new ClasspathXmlApplicationContext(&quot;applicationContext.xml&quot;);

//SpringBoot通过启动标记@SpringBootApplication实例化Spring容器
ApplicationContext ac = SpringApplication.run(xxx);
</code></pre><ol>
<li>创建SpringApplication对象，做初始化工作（加载spring.factories文件的初始组件和Listener组件）</li>
<li><p>调用SpringApplication对象的run方法启动</p>
<ul>
<li>加载程序环境信息（Web环境、JDK环境…）</li>
<li>打印Banner启动Logo</li>
<li>创建ApplicationContext容器对象（根据环境不同创建不同的实例AnnotationConfigApplicationContext）</li>
<li>设置Spring容器环境和参数</li>
<li>往Spring容器中加载各种Bean组件</li>
<li>如果底层有tomcat服务器，自动启动发布程序</li>
<li>返回Spring容器对象</li>
</ul>
</li>
</ol>
<p><strong>SpringBoot启动标记:</strong>  </p>
<p>SpringBoot启动加载@SpringBootApplication是一个复合标记，包含以下几项重要功能：</p>
<ol>
<li><p>@SpringBootConfiguration或@Configuration（Bean定义）</p>
<p> 等价于之前XML配置中的&lt; bean id=”” class=””&gt;</p>
<ul>
<li><p>在启动类前追加@SpringBootConfiguration或@Configuration</p>
<pre><code>  @SpringBootConfiguration//bean定义
  public class RunBoot {

  }
</code></pre></li>
<li><p>在类中定义方法，追加@Bean标记</p>
<pre><code>  @Bean(name=&quot;deptdao&quot;)//将返回的对象添加到spring容器中，id名默认为方法名
  public DeptDao deptDao2() {
      return new DeptDao();
  }
</code></pre></li>
<li><p>如果有多个相同类型对象，可以使用@Primary</p>
<pre><code>  //&lt;bean id=&quot;deptDao1&quot; class=&quot;cn.xdl.dao.DeptDao&quot;&gt;
  @Bean//将返回的对象添加到spring容器中，id名默认为方法名
  @Primary//类型注入发生冲突，默认注入
  public DeptDao deptDao1() {
      return new DeptDao();
  }
</code></pre></li>
<li><p>如果有多个配置类，可以使用@Import注解合并成一个</p>
<pre><code>  @SpringBootConfiguration//bean定义
  @Import(BeanConfiguration.class)//加载BeanConfiguration配置类
  public class RunBoot {

  }
</code></pre></li>
</ul>
</li>
<li><p>@ComponentScan（Bean扫描）</p>
<p> 等价于之前XML配置中的&lt;context:component-scan base-pakcage=””&gt;</p>
</li>
<li><p>@EnableAutoConfiguration (自动配置)</p>
<p> SpringBoot特有功能，省略大量的XML配置定义。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>12.11Java学习进度</title>
    <url>/2019/12/11/2019-12-11-11ribao/</url>
    <content><![CDATA[<h1 id="SSM"><a href="#SSM" class="headerlink" title="SSM:"></a>SSM:</h1><p><strong>以登录为例   完成 SSM 架构的搭建:</strong>   </p>
<p>将Mybatis 和  Spring 进行整合 (以MapperScannerConfigurer 最终提供Service)</p>
<ol>
<li>建立一个项目  导入jar包(ioc aop dao mvc mybatis mybatis-spring数据库连接池  数据库驱动 )  拷贝spring 配置文件到src下  </li>
<li>根据表 建立实体类  </li>
<li>编写SQL 定义文件   根据账号 和 密码进行查询  </li>
<li>编写DAO 接口  </li>
<li>在Spring 容器中 创建 SqlSessionFactoryBean  提供  SqlSessionFactory依赖dataSource  和 Sql定义文件  </li>
<li>创建 MapperScannerConfigurer  批量产生DAO 实现类  依赖于basePackage和   SqlSessionFactory  </li>
<li>编写Service 类 提供业务方法 根据账号和密码进行 登录    然后开启组件扫描 在容器中创建 Service 对应的对象  测试  </li>
</ol>
<p>1.2 搭建基于标注的Spring MVC</p>
<p>1.3 编写控制器方法  让页面请求 结合到控制器方法<br>  控制器方法中使用  Service 完成 登录  根据结果 做页面跳转 </p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>12.10Java学习进度</title>
    <url>/2019/12/10/2019-12-10-10ribao/</url>
    <content><![CDATA[<h1 id="Mybatis-Mybatis的作用"><a href="#Mybatis-Mybatis的作用" class="headerlink" title="Mybatis,Mybatis的作用:"></a>Mybatis,Mybatis的作用:</h1><p><strong>Mybatis 简介:</strong>  </p>
<p>  Apache         Google            GitHub<br>  Ibatis         Mybatis           Mybatis  </p>
<p><strong>Mybatis 的作用:</strong>  </p>
<p>可以用来执行普通的sql操作   存储过程<br>它是一个高级的ORM(Object Relation  Mapping  对象关系映射  以面向对象的思想操作数据库)框架<br>它封装了几乎所有的jdbc 操作    以及参数的手工设置<br>结果集检索(把结果集自动转换成对象)<br><strong>Mybatis 框架的构成:</strong>  </p>
<p>实体类:                     封住数据和业务逻辑<br>SQL定义文件:        写SQL语句的XML 文件<br>主配置文件:              用来定义连接数据库信息 和 加载SQL定义文件 以及做一些特殊设置的 XML文件<br>框架的API:     主要通过SqlSession 来体现   (SqlSession 略微麻烦一些)  用来完成增删改查  </p>
<p><strong>使用Mybatis 完成根据id 查询银行账户:</strong>  </p>
<ol>
<li>建立一个项目 导入jar包(mybatis.jar 数据库驱动)  </li>
<li>根据表建立对应的实体类  </li>
<li>拷贝sql 定义文件的模板 到 一个包中     在sql 定义文件中 定义SQL语句  </li>
<li>拷贝主配置文件模板 到src下     定义连接数据的信息  并加载sql定义文件  </li>
<li>获取SqlSession对象   使用SqlSession 完成查询  </li>
</ol>
<p><strong>MyBatis 的Mapper 映射器规则:</strong>   </p>
<ul>
<li>如果按照规则编写DAO 接口则不用写DAO的实现类 因为可以自动生成</li>
</ul>
<ol>
<li>接口中的方法名   和  Sql定义文件中的  sql语句的id 保持一致  </li>
<li>接口中方法的返回值类型  和  sql语句中的  resultType 保持一致<br>当是查询语句时 如果是返回单值  则 和   resultType 保持一致  如果可能返回多个值  <pre><code> 则使用List&lt;这里的类型和restultType保持一致&gt;  
</code></pre>如果是增删改 语句  则返回void 或者int  推荐使用 int  </li>
<li>接口中方法的参数和 parameterType 保持一致<br>   如果没有  parameterType 则代表方法参数任意  </li>
<li>SQL 定义文件中的 namespace  要写 包名.接口名   </li>
</ol>
<p><strong>Spring 和 Mybatis的整合:</strong>  </p>
<ol>
<li>新建一个项目  导入jar包(ioc aop  mybatis  mybatis-spring dao  数据库驱动 连接池)拷贝 Spring 容器的配置文件到src下  </li>
<li>根据银行账户表  建立一个实体类  </li>
<li>编写SQL 定义文件   根据 id  查询 银行账户   </li>
<li>根据Mapper 映射器规则 编写DAO 接口  </li>
<li>在Spring 容器中  创建 SqlSessionFactoryBean  返回SqlSessionFactory依赖于  dataSource   和  Sql 定义文件  </li>
<li>在Spring 容器创建  MapperFactoryBean   返回 DAO 的实现类依赖于  接口 和 SqlSessionFactory  </li>
<li>创建Spring容器 从容器中 获取DAO 的实现类  测试  </li>
</ol>
<p><strong>MapperScannerConfigurer  批量产生实现类</strong></p>
<p><strong>自定义标注 解决接口的实现类控制问题</strong> </p>
<p><strong>Mybatis  和  Spring 的第二种手段:</strong>  </p>
<ul>
<li>利用模板(SqlSessionTemplate) 自己写DAO的实现类  </li>
</ul>
<ol>
<li>新建一个项目  导入jar包(ioc aop  mybatis  mybatis-spring dao  数据库驱动 连接池)拷贝 Spring 容器的配置文件到src下  </li>
<li>根据银行账户表  建立一个实体类  </li>
<li>编写SQL 定义文件   根据 id  查询 银行账户  </li>
<li>根据Mapper 映射器规则 编写DAO 接口  </li>
<li>在Spring 容器中  创建 SqlSessionFactoryBean  返回SqlSessionFactory依赖于  dataSource   和  Sql 定义文件  </li>
<li>自己写DAO 的实现类 注入 SqlSessionTemplate对象  这个对象依赖于  SqlSessionFactory  </li>
<li>开启组件扫描 在容器中创建DAO的实现类对应的对象  获取这个对象测试  </li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>Mybatis的使用</tag>
      </tags>
  </entry>
  <entry>
    <title>12.09Java学习进度</title>
    <url>/2019/12/09/2019-12-09-09ribao/</url>
    <content><![CDATA[<h1 id="拦截器-Spring中异常处理"><a href="#拦截器-Spring中异常处理" class="headerlink" title="拦截器,Spring中异常处理:"></a>拦截器,Spring中异常处理:</h1><p><strong>拦截器:</strong>  </p>
<p>拦截器 就是对 之前过滤器的一个封装   功能和之前的过滤器类似    比如有  身份认证   登录检查<br>  资源的加密访问    编码设置等功能。<br>拦截器在Spring  中 需要实现  HandlerInterceptor 接口  </p>
<p><strong>HandlerInterceptor  接口介绍:</strong>  </p>
<p>  preHandle    在HandlerMapping 之后  控制器之前    返回 布尔值类型   如果返回 true<br>  则代表继续后续逻辑调用     如果返回false  则请求被拦截。<br>  postHandle   控制器处理之后   视图处理器之前<br>  afterCompletion   视图处理器之后  响应之前  </p>
<p><strong>拦截器的使用步骤:</strong>  </p>
<ol>
<li>搭建一个基于标注的 spring  MVC  完成基本的登录功能  最起码有  toLogin.do</li>
<li>编写一个拦截器类  实现HandlerInterceptor  接口   覆盖接口方法 </li>
<li>在Spring  配置文件中配置拦截器 <pre><code>   大体需要配置 拦截的路径   不拦截的路径    拦截器对象 
</code></pre></li>
<li>测试功能  </li>
</ol>
<p><strong>Spring 中的异常处理:</strong>  </p>
<ol>
<li>全局异常处理 —- 系统提供的异常处理器   <code>SimpleMappingExceptionResolver</code><br> 指定对应的异常  可以跳转到 对应的页面 <pre><code>&lt;!--  配置一个 系统提供的异常处理器  什么样对应什么样的页面 --&gt; 
&lt;bean  id=&quot;exceptionResolver&quot;  
   class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;
   &lt;property name=&quot;exceptionMappings&quot;&gt;
       &lt;props&gt;
           &lt;prop key=&quot;java.lang.Exception&quot;&gt;error2&lt;/prop&gt;
           &lt;prop key=&quot;java.lang.RuntimeException&quot;&gt;error&lt;/prop&gt; 
       &lt;/props&gt;
   &lt;/property&gt;
&lt;/bean&gt;
</code></pre></li>
<li><p>全局异常处理  ——-  自定义异常处理器<br> 实现 HandlerExceptionResolver   并且在Spring 容器中创建自定义异常处理器对象<br><code>`</code><br>@Controller<br>public class MyExceptionResolver implements HandlerExceptionResolver {</p>
<p> @Override<br> public ModelAndView resolveException(HttpServletRequest request,</p>
<pre><code>     HttpServletResponse response, Object method,
     Exception e) {
 // 出现什么样的异常 就跳转到对应的页面 
 ModelAndView  mav  = new  ModelAndView();
 if(e  instanceof  RuntimeException) {
      mav.setViewName(&quot;error&quot;);
 }else if(e instanceof  Exception) {
      mav.setViewName(&quot;error2&quot;);
 }
 return mav;
</code></pre><p> }</p>
</li>
</ol>
<p>}</p>
<pre><code>3. 局部异常处理 ----- 只处理具体的一个控制器抛出的异常  

</code></pre><p>@ExceptionHandler<br> public  String  方法名(Exception  e){<br>     return “错误页面的名字”;<br> }<br><code>`</code><br><strong>文件上传:</strong>  </p>
<ol>
<li>编写一个文件上传的页面<br>form 表单的method=”post”    enctype=”multipart/form-data”<br>form 表单中要有 type=”file”  的组件 </li>
<li>编写一个控制器  用来获取文件数据 并将文件数据写入服务器的磁盘中<br>真正完成文件上传 需要依赖于文件解析器  —- 注意文件解析器依赖于文件上传的jar包  还有这个解析器的<br>id必须是  multipartResolver </li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>拦截器</tag>
        <tag>Spring中异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>12.07Java学习进度</title>
    <url>/2019/12/07/2019-12-07-07ribao/</url>
    <content><![CDATA[<h1 id="MVC框架组件-MVC核心组件"><a href="#MVC框架组件-MVC核心组件" class="headerlink" title="MVC框架组件,MVC核心组件:"></a>MVC框架组件,MVC核心组件:</h1><p><strong>什么是MVC:</strong><br>MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。</p>
<p>Model（模型） - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。<br>View（视图） - 视图代表模型包含的数据的可视化。<br>Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/08/1200px-ModelViewControllerDiagram2.svg_.png" alt="MVC结构"></p>
<p>MVC是一个设计模式，它强制性的使应用程序的输入、处理和输出分开。使用MVC应用程序被分成三个核心部件：模型、视图、控制器。它们各自处理自己的任务。 </p>
<ul>
<li>视图 </li>
</ul>
<p>视图是用户看到并与之交互的界面。对老式的Web应用程序来说，视图就是由HTML元素组成的界面，在新式的Web应用程序中，HTML依旧在视图中扮演着重要的角色，但一些新的技术已层出不穷，它们包括Macromedia Flash和象XHTML，XML/XSL，WML等一些标识语言和Web services. </p>
<p>如何处理应用程序的界面变得越来越有挑战性。MVC一个大的好处是它能为你的应用程序处理很多不同的视图。在视图中其实没有真正的处理发生，不管这些数据是联机存储的还是一个雇员列表，作为视图来讲，它只是作为一种输出数据并允许用户操纵的方式。 </p>
<ul>
<li>模型 </li>
</ul>
<p>模型表示企业数据和业务规则。在MVC的三个部件中，模型拥有最多的处理任务。例如它可能用象EJBs和ColdFusion Components这样的构件对象来处理数据库。被模型返回的数据是中立的，就是说模型与数据格式无关，这样一个模型能为多个视图提供数据。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。 </p>
<ul>
<li>控制器 </li>
</ul>
<p>控制器接受用户的输入并调用模型和视图去完成用户的需求。所以当单击Web页面中的超链接和发送HTML表单时，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后用确定用哪个视图来显示模型处理返回的数据。 </p>
<p>现在我们总结MVC的处理过程，首先控制器接收用户的请求，并决定应该调用哪个模型来进行处理，然后模型用业务逻辑来处理用户的请求并返回数据，最后控制器用相应的视图格式化模型返回的数据，并通过表示层呈现给用户。</p>
<p><strong>MVC框架五大核心组件:</strong>  </p>
<ol>
<li>DispatcherServlet (控制器,请求入口)  </li>
<li>HandlerMapping (控制器,请求派发 让请求和控制器建立一一对应的关系)  </li>
<li>Controller (控制器,请求处理流程 真正处理请求的组件)  </li>
<li>ModelAndView (模型,封装数据信息和视图信息的对象)  </li>
<li>ViewResolver (视图,视图显示处理器)  </li>
</ol>
<p><strong>Spring MVC的编写步骤:</strong>  </p>
<ol>
<li>建立一个项目   导入jar包(ioc mvc)  并拷贝配置文件到src下   在WEB-INF下<br>建立一个jsp 页面 </li>
<li>在WEB-INF下的 web.xml 中  配置DispatcherServlet  并使用初始化参数<br>contextConfigLocation关联Spring的配置文件</li>
<li>在Spring 配置文件中 配置HandlerMapping  的  实现类<br>SimpleUrlHandlerMapping  并且要配置 请求和控制器的对应关系 </li>
<li>编写控制器的实现类   实现 Controller 接口<br>在接口方法中 返回 ModelAndView    同时在容器中创建 控制器对象 </li>
<li>在Spring 配置文件中  配置ViewResolver 的实现类<br>InternalResourceViewResolver   需要配置前缀和后缀   </li>
</ol>
<blockquote>
<p>使用Spring MVC 访问WEB-INF下的jsp   </p>
</blockquote>
<p><strong>基于标注的Spring  MVC:</strong>  </p>
<ol>
<li>建立一个项目 导入jar包(ioc aop mvc)  拷贝配置文件到src 下  并 在WEB-INF下建立jsp文件 </li>
<li>在web.xml 中配置 DispatcherServlet  并通过 初始化参数 contextConfigLocation<br>关联Spring 配置文件 </li>
<li>开启组件扫描 和 标注形式的mvc<pre><code>&lt;context:component-san  base-package=&quot;&quot;  /&gt;
&lt;mvc:annotation-driven /&gt;   
</code></pre>底层创建了一个 RequestMappingHandlerMapping的组件</li>
<li>写一个java类   不用实现Controller接口  </li>
</ol>
<pre><code>@RequestMapping(&quot;/请求路径&quot;)
控制器方法的返回值类型 可以是String 也可以是 ModelAndView   方法名自由了(参数自由了){

}  
</code></pre><p>在类上加对应的标注  @Controller   可以把普通类 变成控制器  并在容器中创建Controller 对象</p>
<ol>
<li>配置视图处理器   </li>
</ol>
<blockquote>
<p>使用标注形式的 mvc  访问 WEB-INF下的  register.jsp </p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MVC框架</tag>
        <tag>MVC核心组件</tag>
      </tags>
  </entry>
  <entry>
    <title>12.06Java学习进度</title>
    <url>/2019/12/06/2019-12-06-06ribao/</url>
    <content><![CDATA[<h1 id="Spring-的声明式事务"><a href="#Spring-的声明式事务" class="headerlink" title="Spring 的声明式事务:"></a>Spring 的声明式事务:</h1><p>不继承JdbcDaoSupport 的方式 完成对数据库的访问<br>和之前的不同在于 需要我们自己在容器中创建一个模板对象(模板对象依赖于dataSource)<br>再把模板 注入给DAO 的实现类 使用自己的模板完成对应的操作  </p>
<ol>
<li>Spring 的声明式事务  </li>
</ol>
<p>Spring声明式事务管理,是使用Spring的AOP方式实现的  </p>
<ol>
<li>通过Spring配置将操作纳入到事务管理中  </li>
<li>解除了事务管理和代码的耦合  </li>
<li>不需要事务管理时,可直接从Spring配置文件中移除  </li>
</ol>
<ol start="2">
<li><p>Spring 声明式事务的实现步骤  </p>
<ol>
<li>开启声明式事务<br><code>`</code><br>&lt;tx:annotation-driven transaction-manager=”事务管理器id”<br>proxy-target-class=”false”/&gt;  </li>
</ol>
<p>proxy-target-class 如果是false 代表优先使用sun公司的代理机制生成代理<br>proxy-target-class 如果是true 代表使用CGLIB的代理机制生成代理  </p>
<pre><code>2. 在Spring 容器中创建一个事务管理器对象--- 依赖于dataSource  
</code></pre><p><bean id="事务管理器id" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"><br> <property name="dataSource" ref="dataSource"><br></property></bean></p>
<pre><code>
3. 在需要事务管理的类或者方法上加事务管理标注  
`@Transactional`  
`@Transactional`的属性  
- rollbackFor Spring 的声明式事务 默认只针对运行时异常进行事务回滚  
- noRollbackFor 针对指定的运行时异常 不回滚  
- isolation 事务隔离级别:  
读未提交  读提交  可重复读  序列化    
用于解决事务隔离三大读问题:  
- 脏读: 一个事务读取到了另外一个事务没提交的数据(好处效率高)
- 不可重复读: 一个事务在开始时 读取了一份数据 另外一个事务修改了这份数据 并进行了提交 当第一个事务再次读取数据时 发现数据发生改变.(不让另一个事务发生更改,安全性高,占用资源多)
- 幻读: 一个事务统计了整张表的所有数据 另外一个事务增加了数据 并进行提交 当再次统计数据时 数据发生了改变  

- readOnly 只读事务 只有当事务语句都是查询时 才能使用这个属性的值是true  默认这个属性的值是false  

- propagation 事务传播特性 一个方法去调用另一个事务方法时 事务应该如何表现  
</code></pre><p>Propagation.REQUIRED 如果当前方法没有事务 则会开启新事务<br>如果当前方法有事务 则将事务加入到当前事务中  </p>
<p>propagation_required: 如果当前没有事务 ,就新建一个事务, 如果已存在一个事务中,加入到这个事务中,这是最常见的选择<br>propagation_supports: 支持当前事务, 如果没有当前事务, 就以非事务方法执行<br>propagation_mandatory: 使用当前事务, 如果没有当前事务, 就抛出异常<br>propagation_required_new: 新建事务,如果当前存在事务,把当前事务挂起<br>propagation_not_supported: 以非事务方式执行操作, 如果当前存在事务, 就把当前事务挂起<br>propagation_never: 以非事务方式执行操作, 如果当前事务存在则抛出异常<br>propagation_nested: 如果当前存在事务, 则再嵌套事务内执行, 如果当前没有事务, 则执行propagation_required<br><code>`</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring 的声明式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>12.05Java学习进度</title>
    <url>/2019/12/05/2019-12-05-05ribao/</url>
    <content><![CDATA[<h1 id="根据银行账户增删改查项目"><a href="#根据银行账户增删改查项目" class="headerlink" title="根据银行账户增删改查项目"></a>根据银行账户增删改查项目</h1>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java进度</tag>
      </tags>
  </entry>
  <entry>
    <title>12.04Java学习进度</title>
    <url>/2019/12/04/2019-12-04-04ribao/</url>
    <content><![CDATA[<h1 id="Bean-参数的注入"><a href="#Bean-参数的注入" class="headerlink" title="Bean 参数的注入:"></a>Bean 参数的注入:</h1><ol>
<li><p>Bean 参数的注入  </p>
<ol>
<li>简单值的注入<br>八种基本类型 和 对应的封装类 枚举 String<br>在spring 容器中创建连接池对象  </li>
<li>复杂值的注入<br>只要把上面的value 换成ref即可  </li>
<li>集合参数的注入  </li>
</ol>
<ul>
<li>Java中集合:<br>List Set Map Properties  </li>
<li>List:  <pre><code>&lt;property name=&quot;&quot;&gt;
&lt;list&gt;
   &lt;value&gt;值&lt;/value&gt;
   &lt;value&gt;值&lt;/value&gt;
&lt;/list&gt;
&lt;/property&gt;
</code></pre></li>
<li><p>Set  </p>
<pre><code>&lt;property name=&quot;&quot;&gt;
&lt;set&gt;
   &lt;value&gt;值&lt;/value&gt;
   &lt;value&gt;值&lt;/value&gt;
&lt;/set&gt;
&lt;/property&gt;
</code></pre></li>
<li><p>Map  </p>
<pre><code>&lt;map&gt;
   &lt;entry key=&quot;13888888888&quot; value=&quot;李白&quot;&gt;
   &lt;/entry&gt;
&lt;/map&gt;
</code></pre></li>
<li><p>Properties  </p>
<pre><code>&lt;props&gt;
   &lt;prop key=&quot;13888888888&quot; value=&quot;李白&quot;&gt;
   &lt;/prop&gt;
&lt;/props&gt;
</code></pre></li>
<li><p>集合参数单独定义  </p>
<pre><code>&lt;util:list id=&quot;&quot;    &gt;
&lt;util:set id=&quot;&quot;    &gt;
&lt;util:map id=&quot;&quot;    &gt;
&lt;util:properties id=&quot;&quot;    &gt;
下面再使用时标签后面加 id=&quot;&quot; 即可
</code></pre></li>
<li><p>Properties 单独定义时 可以关联一个.properties 文件  </p>
</li>
</ul>
</li>
<li><p>Spring DAO 对JDBC的改进<br>简化了DAO 实现类组件的编写 对jdbc的操作步骤做了简化和封装<br>提供了基于AOP的事务管理  </p>
<pre><code>conn.setAutoCommit(false) 连接自动提交设为false状态
conn.commit()
</code></pre><p>对JDBC中的异常 做了封装 把原来的检查异常 封装成了继承自 运行异常的一个异常类<code>DataAccessException</code>  </p>
</li>
<li><p>SpringDAO的核心类<br>JdbcTemplate jdbc模板类<br>自动加载驱动 自动获取连接 自动获取sql执行环境 以及自动释放资源<br>JdbcDaoSupport jdbc DAO的支持类<br>这个类 可以提供模板对象  </p>
</li>
<li><p>Spring DAO 访问数据库的步骤 以查询某张表的数据量为例  </p>
<ol>
<li>建立一个银行账户表 并为表建立对应的序列 插入测试数据 提交  <pre><code>create table xdl_bank_account_29(
id number constraint xdl_bank_account_29_id_pk primary key,
acc _no varchar2(30) constraint xdl_bank_account_29_acc_no_uk unique,
acc_password varchar2(30),
acc_money number
);
create sequence xdl_bank_account_29_id_seq;
</code></pre></li>
<li>建立一个项目 导入jar包(ioc aop dao 数据库驱动 连接池) 拷贝配置文件到src下  </li>
<li>编写DAO接口  </li>
<li>编写DAO的实现类 继承 JdbcDaoSupport 利用模板完成查询  </li>
<li>开启组件扫描 在DAO实现类上打对应的标注  同时给JdbcDaoSupport 这个类 注入一个 dataSource 对象  </li>
<li>获取DAO的实现类 测试  </li>
</ol>
</li>
</ol>
<ol start="5">
<li>重新建立一个项目 然后使用Spring DAO 访问数据库的步骤 完成<br>根据id 查询银行账号  <ol>
<li>建立一个项目 导入jar包(ioc aop dao 数据库驱动 连接池) 拷贝配置文件到src下  </li>
<li>根据表建立对应的实体类 XdlBankAccount  </li>
<li>编写DAO接口  </li>
<li>编写DAO的实现类 继承JdbcSupport 利用模板完成查询  </li>
<li>开启组件扫描 在DAO 实现类上打对应的标注 同时给JdbcDaoSupport 这个类 注入一个 dataSource 对象  </li>
<li>获得DAO的实现类 测试  </li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Bean 参数的注入</tag>
        <tag>Spring DAO 对JDBC的改进</tag>
      </tags>
  </entry>
  <entry>
    <title>12.03Java学习进度</title>
    <url>/2019/12/03/2019-12-03-03ribao/</url>
    <content><![CDATA[<h1 id="bean-对象的延迟实例化-DI-依赖注入-组件扫描"><a href="#bean-对象的延迟实例化-DI-依赖注入-组件扫描" class="headerlink" title="bean 对象的延迟实例化,DI(依赖注入),组件扫描:"></a>bean 对象的延迟实例化,DI(依赖注入),组件扫描:</h1><p><strong>bean 对象的延迟实例化:</strong><br>单例对象 默认是容器启动时 创建 可以通过bean标记的 <code>lazy-init=&quot;true&quot;</code> 就可以让对象推迟实例化 只有用到这个对象时 才会创建对象  </p>
<p><strong>什么是 DI?</strong><br>Dependence Injection(依赖注入 或者 依赖注射)<br>用来解决组件之间的装配问题  </p>
<p><strong>实现DI的方式:</strong>  </p>
<ol>
<li><p>setter 注入<br>一个组件装配值时 参考的是类型对应的set方法 格式如下:  </p>
<pre><code>&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;  
 &lt;property name=&quot;set方法去掉set之后首字母小写&quot; value=&quot;值&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>如果装配的是一个复杂的对象 则需要把<code>value</code>改成<code>ref</code> 只有八种基本类型 和对应的封装类 枚举 String 这些可以使用<code>value</code> 其他使用<code>ref</code>  </p>
</li>
<li><p>构造器注入<br>把上面的<code>property</code> 换成 <code>constructor-arg</code><br>只不过我们不但可以使用name=”构造方法参数名” 还可以使用index 代表参数的位置 编号从0开始  </p>
</li>
<li><p>自动化注入<br>在bean 标记中使用autowire属性可以完成自动化注入<br>autowire 的取值有 byName byType constructor<br>byName 参考的是类型中对应的set方法<br>byType 参考的是类型中对应的成员变量类型 然后去容器中找类型匹配的组件 但是可能会找到多个 找到多个就崩溃<br>constructor 参考的是构造方法 只要有一个参数无法装配成功 则终止后续装配 但不报错   </p>
</li>
</ol>
<p><strong>组件扫描:</strong>  </p>
<ol>
<li><p>什么是组件扫描<br>Component Scan  组件扫描<br>它是Spring 提供的一套基于标注(注解)的技术<br>目的是为了简化XML 的配置  </p>
</li>
<li><p>实现组件扫描的步骤  </p>
<ol>
<li>建立一个项目 导入jar包(ioc aop) 并拷贝配置文件到src下  </li>
<li>在配置文件中开启组件扫描  <pre><code>&lt;context:component-scan base-package=&quot;包名&quot;/&gt;&gt;
</code></pre></li>
<li>建立一个类然后在类上打对应的标注  <pre><code>@Repository  持久层标注 一般加载DAO上
@Service     服务层标注
@Controller  控制层标注
@Component   通用层标注
d.创建Spring 容器 从容器中获取对象 进行测试
</code></pre></li>
</ol>
</li>
<li><p>和组件扫描相关的其他标注  </p>
<pre><code> @Scope(&quot;singleton&quot;||&quot;prototype&quot;) 和对象作用域相关的标注
 @PostContruct 加在初始化方法上
 @PreDestroy  即将销毁对象时调用的方法
</code></pre></li>
<li><p>和DI相关的标注  </p>
<ol>
<li><p>@Value<br>它可以用在成员变量上 或者set方法上<br>如果是简单值(八种基本类型和封装类 String 枚举) 可以直接使用@Value(“值”)<br>但是如果是复杂对象的赋值 则需要使用Spring 的EL表达式赋值 从Spring容器中<br>进行取值 取值的语法是 把之前的$ 换成# 即可  </p>
<ol start="2">
<li><p>@Autowired<br>它可以用在成员变量 set方法 构造方法上<br>它可以用来解决复杂值的装配问题的<br>它优先使用类型进行匹配 如果类型有冲突 则会启用名字匹配进行装配<br>它可以和@Qualifier 配合使用 @Qualifier可以指定查找的组件名 如果找不到则程序报错<br>注意@Qualifier 不能用在构造方法上<br>当使用@Qualifier 指定名字查找时 对组件的依赖 属于强依赖(找不到程序就报错) 可以使用@Autowired的属性 <code>requried=false</code> 来接触这种强依赖 就是让程序尽量的去查找组件 找不到也不报错  </p>
</li>
<li><p>@Resource<br>它可以用在成员变量 set方法上<br>它也是用来解决复杂值的装配问题<br>它优先按照名字(参考的是set方法名 而不是参数的名字)进行匹配 如果名字不匹配 会启动类型进行匹配<br>它是JDK 提供的标注<br>可以通过 @Resource 的name 属性 指定查找的组件 如果找不到就报错 但是无法解除强依赖  </p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>DI(依赖注入)</tag>
        <tag>组件扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>12.02Java学习进度</title>
    <url>/2019/12/02/2019-12-02-02ribao/</url>
    <content><![CDATA[<h1 id="项目编程思想-Spring-框架的构成-IOC"><a href="#项目编程思想-Spring-框架的构成-IOC" class="headerlink" title="项目编程思想,Spring 框架的构成,IOC:"></a>项目编程思想,Spring 框架的构成,IOC:</h1><p><strong>项目编程思想:</strong><br>项目功能的开发思路 —以注册为准 MVC  </p>
<ol>
<li>根据需求文档 建立对应的表 xdl_user  </li>
<li>根据表建立对应的实体类 XdlUser  </li>
<li>定义一个DAO接口  </li>
<li>利用jdbc的工具类结合JDBC访问数据库的五步完成功能  </li>
<li>加一个工厂类 提供DAO的实现类 接触Service和DAO的耦合度  </li>
<li>编写一个业务类 XdlUserService 注册 —测试 —-M  </li>
<li>观察 register.jsp 让其发出register.do —-V  </li>
<li>编写一个Servlet 充当控制器 接收页面请求参数  </li>
<li>利用M层完成注册,根据注册结果做数据设置和页面跳转  </li>
<li>利用上面的思想 设计快件列表的显示  </li>
</ol>
<p>利用上面的思想 设计快件列表的显示  </p>
<ol>
<li>建立快件对应的表  </li>
<li>根据表建立对应的实体类  </li>
<li>编写DAO 接口  </li>
<li>编写DAO 的实现类  </li>
<li>编写DAO 工厂类  </li>
<li>编写Service 类 包装一个业务方法 可以提供快件列表的数据 —测试 M  </li>
<li>编写控制器类 使用M层获取快件列表 放入request中 转发到快递列表对应的jsp —C  </li>
<li><p>使用jstl + el 在jsp中展示快件列表 —V  </p>
</li>
<li><p>建立快件对应的表  </p>
</li>
<li>根据表建立对应的实体类  </li>
<li>编写DAO 接口  </li>
<li>编写DAO 的实现类  </li>
<li>编写DAO 工厂类  </li>
<li>编写Service 类 包装一个业务方法 可以提供快件列表的数据 —测试 M  </li>
<li>编写一个控制器 使用M层获取快件列表 使用第三方jar包 把列表转成JSON字符串 写给浏览器  </li>
<li>jsp 中发送ajax请求 把返回的数据 使用js 显示到页面中  </li>
</ol>
<p><strong>Spring 框架的构成:</strong>  </p>
<ol>
<li>IOC 控制反转模块 这是Spring框架的核心  </li>
<li>DAO 数据访问模块 Spring框架对jdbc访问数据库做了简化和封装  </li>
<li>WebMVC Spring 对web部分以及MVC框架的支持  </li>
<li>AOP 面向切面编程 在面对对象的基础上做了扩展  </li>
<li>ORM Mybatis 以面向对象的思想来操作数据库  </li>
<li>JEE Spring 对远程调用消息服务 邮件服务等的支持  </li>
</ol>
<p><strong>什么是IOC:</strong>  </p>
<p>Inversion Of Control 控制反转<br>程序中一个组件 用到另外一个组件时 由原来的new的方式 变成了由容器来进行 组件的创建 管理 和维护组件关系<br>这样做的好处是 可以大大降低组件之间的耦合度  </p>
<p><strong>Spring容器:</strong>  </p>
<p>在Spring中,任何Java类都被当成Bean组件通过容器管理和使用<br>Spring容器实现了IOC和AOP机制<br>Spring容器有ApplicationContext和BeanFactory两种类型  </p>
<p><strong>Spring 容器的使用步骤:</strong><br>—使用容器获取日期类型的对象  </p>
<ol>
<li>建立一个项目 导入jar包(ioc) 拷贝Spring 容器对象的配置文件到src下  </li>
<li>在spring容器配置文件中 写对象对应的配置  <pre><code>&lt;bean id=&quot;对象的引用名&quot; class=&quot;包名.类名&quot;&gt;&lt;/bean&gt;
</code></pre></li>
<li>创建Spring 容器对象 和从容器中获取对象  <pre><code>ApplicationContext app = new ClassPathXmlApplicationContext(&quot;配置文件名&quot;);
app.getBean(&quot;对象的引用名&quot;,类型.class);
</code></pre></li>
</ol>
<p><strong>Spring 容器创建对象的三种方式:</strong>  </p>
<ol>
<li><p>构造器方式实例化  </p>
<pre><code>&lt;bean id=&quot;对象引用名&quot; class=&quot;包名.类名&quot;&gt;
</code></pre><p>默认调用类型对应的无参构造  </p>
<pre><code>Date date = new Date();
</code></pre></li>
<li><p>静态工厂方法实例化<br>使用类型 调用对应的静态方法来获取对象  </p>
<pre><code>&lt;bean id=&quot;对象引用名&quot; class=&quot;包名.工厂类名&quot; factory-method=&quot;静态方法名&quot;&gt;&lt;/bean&gt;
</code></pre></li>
<li><p>实例工厂方法实例化<br>本质上这种方式是使用一个已经存在的对象 创建出另一个类型的对象  </p>
<pre><code>&lt;bean id=&quot;对象引用名&quot; (可不写)class=&quot;包名.目标类名&quot; factory-method=&quot;成员方法名&quot; factory-bean=&quot;工厂对象的id&quot;&gt;&lt;/bean&gt;
</code></pre></li>
</ol>
<p><strong>Spring 容器中Bean 对象的作用域:</strong><br>Spring容器中 默认一个对象的作用域是单例的 可以再spring 配置文件中通过bean标记的<br>scope 属性来指定对象的作用域 取值有 singleton 或者 prototype 其他的 如 request<br>session 等到web部分才涉及  </p>
<p><strong>bean 对象的初始化和销毁:</strong>  </p>
<ol>
<li>对象的初始化:  </li>
</ol>
<p>bean 对象创建完成后 可以通过beans标记中的 default-init-method 属性指定初始化方法 , 由于这样会影响到spring容器中配置的所有对象 这样影响的范围比较大 所以对象对应的类型中国没有对应的初始化方法也不会报错.<br>也可以在bean标记中通过 init-method 来指定初始化方法 这样只影响到一个具体的对象 所以控制的比较精准 当这个对象对应的类型中没有对应的初始化方法时,程序会报错.  </p>
<ol start="2">
<li>对象的销毁:  </li>
</ol>
<p>bean 对象即将消亡 可以通过beans标记中的 default-destroy-method 属性指定销毁方法 由于这样会影响到spring容器中配置的所有对象, 这样影响的范围比较大 所以对象对应的类型中没有对应的销毁方法也不会报错.<br>也可以在bean标记中通过 destroy-method 来指定销毁方法 这样只影响到一个具体的对象 所以控制的比较精准 当这个对象对应的类型中没有对应的销毁方法时 程序会报错.<br>销毁方法只针对单例模式的对象.  </p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>项目编程思想</tag>
        <tag>Spring 框架</tag>
      </tags>
  </entry>
  <entry>
    <title>11.30Java学习进度</title>
    <url>/2019/11/30/2019-11-30-30ribao/</url>
    <content><![CDATA[<h1 id="Ajax-Jquery-Ajax请求-缓存问题"><a href="#Ajax-Jquery-Ajax请求-缓存问题" class="headerlink" title="Ajax-Jquery,Ajax请求,缓存问题:"></a>Ajax-Jquery,Ajax请求,缓存问题:</h1><p><strong>Ajax-Jquery:</strong>  </p>
<p>Jquery对Ajax操作,进行了封装,简化了ajax的开发,且实现了多浏览器的兼容性  </p>
<p><strong>ajax函数:</strong><br>函数名称: ajax<br>参数列表: 长度为1, 需要传递一个对象.  </p>
<p>通常我们传递参数时,传递的是JSON对象, 格式:  </p>
<pre><code>{
  &quot;url&quot;:&quot;请求地址&quot;,
  &quot;type&quot;:&quot;请求方式GET/POST&quot;,
  &quot;async&quot;:请求是否为异步(默认true为异步),
  &quot;data&quot;:&quot;请求的参数,格式与网址后的参数拼接一致&quot;,
  &quot;dataType&quot;:&quot;服务器返回的数据类型TEXT或JSON&quot;,
  &quot;success&quot;:function(data){
    //当请求成功时,函数执行了,相当于xhr.readyState==4  status==200
    //data就是响应的内容  
    //如果dataType:JSON, 则data就是一个JSON对象.
    //如果dataType:TEXT, 则data就是一个字符串文本.
  },
  &quot;error&quot;:function(){
    //当请求失败时,函数执行
  }
}
</code></pre><p><strong>$.get函数 / $.post函数</strong><br>这两个函数的格式,完全一致,一个用于GET请求,一个用于POST请求  </p>
<p>函数名称: $.get / $.post<br>参数列表:  </p>
<ol>
<li>url : 请求地址  </li>
<li>data : 请求时携带的参数  </li>
<li>success : 请求成功时 处理的函数</li>
<li>响应的数据类型 : TEXT/JSON  </li>
</ol>
<p><strong>getJSON函数:</strong><br>用于get请求, 返回JSON对象<br>函数名: $.getJSON();<br>参数列表:  </p>
<ol>
<li>url : 请求地址  </li>
<li>data : 请求时携带的参数  </li>
<li>success : 请求成功时,处理的函数  </li>
</ol>
<p><strong>jquery对象.load:</strong><br>通过jquery对象,调用load函数,将服务器返回的内容直接嵌入到元素的内部<br>使用load函数访问的服务器通常返回的不是JSON,耳饰html标签<br>函数名称: $lbj.load<br>参数列表:  </p>
<ol>
<li>url : 请求的地址  </li>
<li>data : 传递的参数  </li>
<li>success : 请求成功时执行的函数  </li>
</ol>
<p><strong>ajax请求 数据缓存问题 :</strong><br>在操作ajax时,浏览器对ajax请求的结果缓存以后,当我们再次向这个地址发起ajax时,浏览器有可能会不再请求服务器,采用上一次缓存<br>解决缓存:<br>需要先明白缓存原理. 浏览器是按照网址进行缓存的.<br>所以我们想要浏览器不使用缓存,只需要保证网址不重复就可以了  </p>
<p>格式:<br>给请求地址字符串,添加一个时间戳参数.  </p>
<p>例如:  </p>
<pre><code>$.load(&quot;s3.do&quot;,time=&quot;+new Date().getTime(),function(){}&quot;);
</code></pre>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>11.29Java学习进度</title>
    <url>/2019/11/29/2019-11-29-29ribao/</url>
    <content><![CDATA[<h1 id="Ajax-GSON-jar"><a href="#Ajax-GSON-jar" class="headerlink" title="Ajax,GSON.jar:"></a>Ajax,GSON.jar:</h1><p><strong>Ajax简介:</strong><br>一种用于网页 异步请求的技术.  </p>
<p><strong>作用:</strong><br>用于与服务器进行异步交互 以及局部页面的刷新  </p>
<p><strong>Ajax的GET使用步骤:</strong>  </p>
<ol>
<li><p>创建一个 异步请求的对象  </p>
<pre><code>var xhr = new XMLHttpRequest();
</code></pre></li>
<li><p>设置请求的方式,以及请求的地址  </p>
<pre><code>xhr.open(&quot;GET&quot;,&quot;请求地址&quot;);
</code></pre></li>
<li><p>设置请求结果产生时的时间处理函数(当请求状态发生改变时,执行的函数)  </p>
<pre><code>xhr.onreadystatechange = function(){
//此方法在一次ajax中,会执行五次,分别表示五种状态  
//每次的状态值,从xhr.readyState属性中得到.  
//状态值:  
// 0 请求初始化中,它的触发,在new对象时,此方法不会执行  
// 1 请求正在发送,它的触发在open函数执行时,此方法如果在open前指定,则状态发生时,方法执行  
// 2 请求发送完毕  
// 3 服务器开始响应  
// 4 响应完毕  

//请求也存在状态码, 例如: 404 表示资源找不到 500表示服务器内部错误. 200表示成功 302表示重定向  
//请求状态码,通过xhr.status得到 如果是200表示请求成功  

if(xhr.readyState == 4){
 if(xhr.status == 200 ){
   //成功得到结果  
   //得到结果,在xhr.responseText中 . 是文本内容
 }else{
   //请求失败
   //提示失败
 }
}
}
</code></pre></li>
</ol>
<blockquote>
<p>P(OST请求的话)设置请求头部  </p>
<pre><code>xhr.setRequestHeader(&quot;content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);
</code></pre></blockquote>
<ol start="4">
<li>发送请求  <pre><code>xhr.send(null);
</code></pre></li>
</ol>
<p><strong>使用IE浏览器8/8- 操作上述的案例:</strong>  </p>
<p>GET或POST请求 都需要修改第一步:  </p>
<pre><code>var xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
</code></pre><p><strong>GSON.jar:</strong><br>作用:<br>将Java中的对象,快速的转换为JSON格式的字符串<br>将JSON格式的字符串,转换为Java的对象  </p>
<p>转换JSON字符串的步骤:  </p>
<ol>
<li>引入jar包  </li>
<li>在需要转换JSON字符串的位置编写如下代码即可:  <pre><code>String json = new Gson().toJSON(要转换的对象);
</code></pre></li>
</ol>
<p>转换Java对象的步骤  </p>
<ol>
<li>引入jar包  </li>
<li>在需要转换Java对象的位置,编写如下代码:  <pre><code>对象 = new Gson().fromJson(JSON字符串,对象类型.class);
</code></pre></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>GSON.jar</tag>
      </tags>
  </entry>
  <entry>
    <title>11.28Java学习进度</title>
    <url>/2019/11/28/2019-11-28-28ribao/</url>
    <content><![CDATA[<h1 id="JSTL常用标签-自定义标签-web三大组件"><a href="#JSTL常用标签-自定义标签-web三大组件" class="headerlink" title="JSTL常用标签,自定义标签,web三大组件:"></a>JSTL常用标签,自定义标签,web三大组件:</h1><p><strong>JSTL常用标签:</strong><br> 单分支判断if标签： </p>
<pre><code>           &lt;c  : if  test = “EL条件表达式”&gt; 
           满足条件执行 
           &lt;/c  : if &gt;   
</code></pre><p>多分支判断choose标签： </p>
<pre><code>            &lt;c  : choose &gt; 
             &lt;c  : when test = “EL表达式”&gt; 
                         满足条件执行 
                  &lt;/c  : when&gt; 
             … 
             &lt;c  : otherwise&gt; 
                         不满足上述when条件时执行 
             &lt;/c  : otherwise&gt; 
            &lt;/c  : choose &gt;   
</code></pre><p>循环forEach标签： </p>
<pre><code>        &lt;c  : forEach  var= “循环变量”  
            items= “集合” varStatus= “状态变量”  
       &gt; 
            …  … 
           &lt;/c  : forEach&gt;   
</code></pre><p><strong>JSTL自定义标签:</strong>  </p>
<p>如果上面几个标签不能满足需求，程序员也可以自定义标签，步骤如下： </p>
<ol>
<li>编写标签类 ，继承SimpleTagSupport或TagSupport </li>
<li>重写父类方法(doTag或doStartTag、doEndTag) </li>
<li>配置标签说明文件 （tld标签库文件 ）  </li>
</ol>
<p>编写标签的Java类和doTag方法处理： </p>
<pre><code>      public class PagerTag extends SimpleTagSupport  { 

            private int pageSize;//定义标签属性 
            //省略了set和get方法 

           public void doTag() throws JspException,  
      IOException  { 
                JspWriter out = this.getJspContext().getOut(); 
                out.print( “要输出的HTML内容”); 
           } 
      }   
</code></pre><p>定义标签库文件,放置到WEB-INF下： </p>
<pre><code>             &lt;?xml version= &quot;1.0 &quot; encoding=&quot;UTF-8 &quot; ?&gt; 
             &lt;taglib xmlns= &quot;http ://java.sun.com/xml/ns/javaee &quot; 
                 xmlns:xsi= &quot;http ://www.w3.org/2001/XMLSchema-instance &quot; 
                 xsi:schemaLocation= &quot;http ://java.sun.com/xml/ns/javaee 
                 http ://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd&quot; version= &quot;2.1&quot;&gt;   
               &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; 
               &lt;short-name&gt;xdl&lt;/short-name&gt; 
               &lt;uri&gt;http://www.lampbrother.net/pager&lt;/uri&gt; 
               &lt;tag&gt; 
                 &lt;description&gt;生成分页按钮&lt;/description&gt; 
                 &lt;name&gt;pager&lt;/name&gt; 
                 &lt;tag-class&gt;com.xdl.tag.PagerTag&lt;/tag-class&gt; 
                 &lt;body-content&gt;empty&lt;/body-content&gt; 
                 &lt;attribute&gt; 
                     &lt;description&gt;每页显示记录数&lt;/description&gt; 
                     &lt;name&gt;pageSize&lt;/name&gt; 
                     &lt;required&gt;true&lt;/required&gt; 
                     &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; 
                 &lt;/attribute&gt; 
              &lt;/tag&gt;   
             &lt;/taglib&gt;   
</code></pre><p>在JSP中添加taglib指令引入标签库使用： </p>
<pre><code>       &lt;%@ page language= &quot;java &quot; import=&quot;java.util.* &quot;  
       pageEncoding=&quot;UTF-8 &quot;%&gt; 
       &lt;%@taglib prefix= &quot;xdl&quot;   
       uri=&quot;http ://www.lampbrother.net/pager &quot;%&gt; 
       &lt;html&gt; 
         &lt;head&gt; 
           &lt;title&gt;自定义标签应用&lt;/title&gt; 
         &lt;/head&gt; 
         &lt;body&gt; 
           &lt;xdl:pager totalSize= &quot;21&quot; pageSize=&quot;5 &quot;/&gt; 
         &lt;/body&gt; 
       &lt;/html&gt;   
</code></pre><p><strong>Servlet:</strong>  </p>
<p>HTML –&gt; 静态网页<br>Servlet –&gt; 接收用户的参数 | 准备HTML响应体<br>JSP –&gt; 更方便的准备HTML响应体  </p>
<p>字符转(字符编码) ‘A’ = 65  </p>
<p>HashMap<br>1001 : 考试<br>1002 : 提交成绩  </p>
<p>堆内存 –&gt; Java的规则  </p>
<p>JSON :  </p>
<pre><code>var person = {&quot;name&quot;:&quot;张三&quot;, &quot;age&quot;:18};  
var user = {&quot;username&quot;,&quot;123&quot;,&quot;password&quot;:&quot;456&quot;};  
</code></pre><p>XML :  </p>
<pre><code>&lt;person&gt;
    &lt;name&gt;张三&lt;/name&gt;
    &lt;age&gt;18&lt;/age&gt;
&lt;/person&gt;
</code></pre><p><strong>JSP心得:</strong><br>功能该分开要分开,避免耦合度过高<br>将一个大项目拆分成多个模块<br><img src="https://s2.ax1x.com/2019/11/28/QiS4AJ.png" alt="避免耦合度过高">  </p>
<p><strong>web三大组件:</strong><br>Servlet是web的三大组件之一.  </p>
<ol>
<li>Servlet</li>
<li>Filter 过滤器</li>
<li>Listener 监听器  </li>
</ol>
<p><strong>Filter 过滤器:</strong>  </p>
<p>过滤的是请求.<br>面向切面编程思想<br>使用步骤:  </p>
<ol>
<li>编写一个类,实现Filter接口  </li>
<li>通过web.xml 或 注解的方式,配置过滤器的过滤地址.  </li>
</ol>
<p><strong>doFilter中的请求与响应对象 为什么不是http的 ?</strong>  </p>
<p>过滤器在早期设计时,不只是针对HTTP请求,针对所有协议的请求都可以进行过滤.<br>因为我们现在都是使用HTTP协议,所以感觉很怪异<br>想要操作HTTP相关的请求对象 与 响应对象 怎么办?<br>只需要将请求对象强制转换为HttpServletRequest 将响应对象 强制转换为HttpServletResponse 即可  </p>
<p><strong>过滤器链:</strong><br>当多个过滤器的过滤地址重复时,就形成了过滤器链,<br>用户的一次请求,需要经过多次过滤放行.  </p>
<p>过滤器链的执行顺序是:<br>web.xml中配置的顺序:<br>    按照xml中配置的先后顺序来执行的, web.xml中配置代码靠前的,优先执行.  </p>
<p>注解配置的顺序:<br>    按照类名的自然排序执行.<br>    注意: 注解配置的过滤器,一定执行在web.xml过滤器之后<br>    例如:<br>    类名Filter1 执行在类名Filter2之前.<br>    类名Aaa 执行在 类名Aab之前  </p>
<p><strong>Listener监听器:</strong><br>事件驱动,监听的是tomcat产生的事件:<br>两类事件:  </p>
<ol>
<li>生命周期相关的事件  </li>
<li>域对象中数据的变化事件  </li>
</ol>
<p><strong>ServletContextAttributeListener监听器:</strong><br>监听Servlet上下文中数据的 增加,删除 以及修改.  </p>
<p><strong>HttpSessionListener:</strong><br>用于监听session的创建与销毁<br>因为我们服务器中每一个session表示一次用户的会话<br>一个客户端就会创建一个单独的session. 可以将session的数量,理解为在线用户的数量.<br>所以我们经常在session创建与销毁的监听中, 计算当前在线的人数.  </p>
<p><strong>HttpSessionAttributeListener:</strong><br>用于监听session中的数据增加,删除,修改  </p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JSTL标签</tag>
        <tag>自定义标签</tag>
        <tag>web三大组件</tag>
      </tags>
  </entry>
  <entry>
    <title>11.27Java学习进度</title>
    <url>/2019/11/27/2019-11-27-27ribao/</url>
    <content><![CDATA[<h1 id="JSP指令-JSP的九大内置对象-EL"><a href="#JSP指令-JSP的九大内置对象-EL" class="headerlink" title="JSP指令,JSP的九大内置对象,EL:"></a>JSP指令,JSP的九大内置对象,EL:</h1><p><strong>include 指令:</strong><br>用于将一个JSP或HTML文件引入到另一个JSP中.<br>格式:  </p>
<pre><code>&lt;%@ include file=&quot;引入的路径&quot; %&gt;
</code></pre><p><strong>include 动作:</strong><br>用于将一个JSP或HTML文件引入到另一个JSP中.<br>格式:  </p>
<pre><code>&lt;jsp:include page=&quot;引入路径&quot; flush=&quot;true&quot;(刷新属性)/&gt;
</code></pre><p><strong>include 指令 与 include动作的区别:</strong>  </p>
<p>include指令: 在JSP程序的转换时期,将被引入的JSP文件嵌入到include指令的位置,然后统一编译执行(最终生成了一个.java文件)  </p>
<p>include动作: 在JSP程序的转换时期,被引入的文件不会嵌入到include动作的位置上,而是等客户端请求时,再临时将被引入的文件以额外的servlet的方式加载到响应中(最终生成的是多个.java文件)  </p>
<p><strong>JSP的内置对象(隐含对象):</strong>  </p>
<p>内置对象指的是: JSP引擎在转换JSP文件时,帮我们的代码在执行之前 创建的一些 供我们使用的对象,<br>内置对象具备大量的JSP中的常用功能,使用JSP内置对象可以大大的简化我们的开发流程.  </p>
<p><strong>JSP的九大内置对象:</strong>  </p>
<p><code>request:</code><br>类型: HttpServletRequest<br>作用: 请求对象,包含了请求相关的信息和参数  </p>
<p><code>response:</code><br>类型: HttpServletResponse<br>作用: 响应对象,包含了一些用于响应的功能.  </p>
<p><code>out:</code><br>类型: JSPWriter<br>作用: 是打印流,用于向响应体中输出数据  </p>
<p><code>session:</code><br>类型: HttpSession<br>作用: 会话对象,用于状态管理以及会话跟踪  </p>
<p><code>application:</code><br>类型: ServletContext<br>作用: Servlet的上下文,一个应用内存中同时只有一个上下文对象,用于多个Servlet/JSP之间通信.  </p>
<hr>
<p>config:<br>类型: ServletConfig<br>作用: Servlet的配置对象,用于配置一些初始的键值对信息.  </p>
<p>pageContext:<br>类型: PageContext<br>作用: 页面的上下文,每一个JSP都拥有一个上下文对象,用于多段代码之间进行通信  </p>
<p>exception:<br>类型: Throwable<br>作用: 当页面的page指令中 isErrorPage属性值为true时,才会存在此对象,用于收集错误信息!<br>    通常此对象值为null,只有其他页面指定errorPage=当前页面时,且其他页面发生BUG后,跳转到此页面时,对象才不为null  </p>
<p>page:<br>类型: Object<br>作用: 指当前JSP页面自身,在JSP引擎生成的代码中,page对象的赋值代码为:<br>    Object page = this;  </p>
<p><strong>JSP的四大域对象:</strong><br>九大隐含对象中,包含了四个较为特殊的隐含对象,这四个对象我们称其为域对象,它们都具备存储数据/删除数据/获取属性值的方法:<br>存储数据:  </p>
<pre><code>setAttribute(String key, Object value);
</code></pre><p>获取数据:  </p>
<pre><code>Object value = getAttribute(String key);
</code></pre><p>删除数据:<br>removeAttribute(String key);  </p>
<p>这四个域对象,’域’指的是作用域  </p>
<p>分别是:<br>pageContext : 页面的上下文   作用域: 一个JSP页面<br>request : 请求对象  作用域: 一次请求(请求可以被转发,一次请求可能包含多个JSP页面)<br>session : 会话对象  作用域: 一次会话(一次会话可能包含多次请求)<br>application : servlet上下文对象  作用域: 一次服务(服务器的启动到关闭)(一次服务可能包含多次会话)  </p>
<hr>
<p>点击加入购物车–&gt;携带id发送给查询的servlet–&gt;查询成功–&gt;转发到添加购物车的servlet–&gt;将商品信息添加到购物车中  </p>
<p><strong>JSP useBean 动作:</strong><br>作用: 向四大域对象中,存储bean对象.<br>格式:  </p>
<pre><code>&lt;jsp:useBean
    id=&quot;存储时的key&quot;  
    scope=&quot;page/request/session/application&quot;  
    class=&quot;要存储的对象类型&quot;&gt;
&lt;/jsp:useBean&gt;
</code></pre><p><strong>JSP useBean + setProperty动作:</strong><br>作用: 向四大域对象中,存储bean对象,且设置属性值<br>格式:  </p>
<pre><code>&lt;jsp:useBean
    id=&quot;存储时的key&quot;  
    scope=&quot;page/request/session/application&quot;  
    class=&quot;要存储的对象类型&quot;&gt;  
&lt;/jsp:uesBean&gt;  
&lt;jsp:setProperty name=&quot;存储时的key&quot; property=&quot;属性名&quot; value=&quot;属性值&quot;/&gt;  
//setProperty动作可以出现多次
</code></pre><p>案例:  </p>
<pre><code>&lt;jsp:useBean id=&quot;p&quot; scope=&quot;page&quot; class=&quot;cn.xdl.bean.Person&quot;&gt;&lt;/jsp:useBean&gt;  
&lt;jsp:setProperty name=&quot;p&quot; property=&quot;name&quot; value=&quot;刘建&quot;/&gt;  
&lt;jsp:setProperty name=&quot;p&quot; property=&quot;age&quot; value=&quot;18&quot;/&gt;
</code></pre><p><strong>JSP useBean + setProperty动作 快速获取表单提交的内容:</strong><br>格式:  </p>
<pre><code>&lt;jsp:useBean
    id=&quot;存储时的key&quot;
    scope=&quot;page/request/session/application&quot;
    class=&quot;要存储的对象类型&quot;&gt;
&lt;/jsp:useBean&gt;  
&lt;jsp:setProperty name=&quot;存储时的key&quot; property=&quot;属性名&quot;/&gt;  
</code></pre><p>注意:<br>如果setProperty动作中,property的值即是对象的属性名,又是我们用户请求的参数的名称的话,会自动将参数获取到并赋值给对象  </p>
<p><strong>JSP getProperty动作:</strong><br>作用:<br>从四大域对象中取出某个对象的属性,并显示到网页中  </p>
<p>格式:  </p>
<pre><code>&lt;jsp:getProperty name=&quot;对象的key&quot; property=&quot;属性名&quot;&gt;
</code></pre><p><strong>通过重写URL,得到session:</strong><br>//1. 重写普通的网址,通常是超链接/表单中使用的网址<br>// url = response.encodeUrl(url);  </p>
<p>//2. 重写重定向的网址,这种网址用于重定向<br>url = response.encodeRedirectUrl(url);  </p>
<p><strong>EL表达式:</strong><br>作用:<br>用于快速的从域对象中取出数据,并将结果输出到网页<br>也可以用于一些运算,运算的结果也会输出到网页<br>格式:<br>${表达式}<br>例如:  </p>
<pre><code>运算的结果:${ 1+2+3+4+5 }
</code></pre><p><strong>用于取出域对象中的数据:</strong><br>访问存储数据的格式:<br>${存储的key}  </p>
<p>访问存储的对象属性值:<br>静态取值:${存储的key.属性名}<br>静态取值:${存储的key[属性名]}<br>动态取值:${存储的key[“属性名的key”]}  </p>
<p>访问集合/数组中的对象:<br>静态取值:${存储的key[下标].属性名}<br>静态取值:${存储的key[下标][“属性名”]}<br>动态取值:${存储的key[下标][属性名的key]}  </p>
<p>有时我们需要使用变量的值,可以将其先存储到域对象中,再在el表达式中使用存储的key来操作<br>例如:  </p>
<pre><code>&lt;%
    User[] data = {new User(&quot;root1&quot;,&quot;123&quot;),new User(&quot;root2&quot;,&quot;223&quot;),new User(&quot;root3&quot;,&quot;323&quot;),new User(&quot;root4&quot;,&quot;423&quot;),};
    pageContext.setAttribute(&quot;Users&quot;,data);
    pageContext.setAttribute(&quot;a&quot;,&quot;username&quot;);
%&gt;
&lt;%
    for(int i = 0; i&lt;data.length;i++){
        pageContext.setAttribute(&quot;index&quot;,i);
    }
%&gt;
    静态取值: ${user[index].username}
&lt;%} %&gt;
</code></pre><p><strong>EL表达式 取出数据的流程:</strong>  </p>
<p>取出顺序: 范围从小到大  </p>
<p>步骤:  </p>
<ol>
<li>先从pageContext中寻找数据是否存在  </li>
<li>当pageContext中不存在数据时,去request中寻找数据是否存在  </li>
<li>当request中不存在数据时,去session中寻找数据是否存在  </li>
<li>当session中不存在此数据时,去application中寻找数据是否存在  </li>
<li>当application中不存在此数据时,向网页输出长度为0的字符串(是””,不是null)  </li>
</ol>
<p>在上述的流程中,一旦某个步骤寻找到了数据,就会将数据输出到网页中,且后续流程不再执行.  </p>
<p><strong>taglib指令:</strong><br>用于在JSP中引入标签库<br>语法格式:  </p>
<pre><code>&lt;%@ taglib prefix=&quot;&quot; uri=&quot;&quot;%&gt;
</code></pre><p>属性:<br>prefix: 是引入标签库的名称,用于区分多个标签库,在使用此标签库中的标签时,需在标签前添加标签库名称:<br>例如: 我们引入一个标签库,prefix=a,则其中的标签在使用时:  </p>
<pre><code>&lt;a:标签名&gt;&lt;/a:标签&gt;
</code></pre><p>uri: 用于匹配标签库,在引入的tld文件中存在一个uri属性值,我们uri属性与tld文件中的属性相同,则引入这个文件描述的库.  </p>
<p><strong>JSTL标签库:</strong>  </p>
<p>是一套JSP的标准标签库,对JSP的标签进行了扩展  </p>
<p><strong>IF标签:</strong>  </p>
<p>用于判断元素是否显示  </p>
<p>格式:  </p>
<pre><code>&lt;库的名称:if test=&quot;&quot;&gt;&lt;/库的名称:if&gt;  
test属性值:  
    可以是boolean值,或运算结果为boolean的el表达式. 
</code></pre><p>案例:  </p>
<pre><code>&lt;%--
&lt;heiheihei:if test=&quot;true&quot;&gt;
    从前有座山
&lt;/heiheihei:if&gt;  
&lt;heiheihei:if test=&quot;false&quot;&gt;
    从前有座山
&lt;/heiheihei:if&gt;  
--%&gt;  
&lt;%
    pageContext.setAttribute(&quot;flag&quot;,false);
%&gt;  
&lt;heiheihei:if test=&quot;${ flag }&quot;&gt;  
    从前有座山  
&lt;/heiheihei:if&gt;  
&lt;%
    pageContext.setAttribute(&quot;flag&quot;,true);
%&gt;  
&lt;heiheihei:if test=&quot;${ flag }&quot;&gt;  
    山上有座庙  
&lt;/heiheihei:if&gt;
</code></pre><p><strong>choose+when+otherwise标签:</strong><br>类似Java中的: switch+case+default<br>这三个标签,只有when是由test属性的,属性值是boolean值,允许使用el表达式传入<br>作用:<br>用于多分支显示.  </p>
<p><strong>forEach标签:</strong><br>用于遍历集合 或数组元素<br>格式:  </p>
<pre><code>&lt;标签库名称:forEach items=&quot;&quot; var=&quot;&quot;&gt;

&lt;/标签库名称:forEach&gt;
</code></pre><p>属性:<br>items : 要遍历的数组或集合 必须通过el表达式传递<br>var : 从循环遍历时,从数组或集合中取出每个元素会被存储到pageContext中,key就是var的值  </p>
<p><strong>如何自定义标签库:</strong>  </p>
<p>自定义标签库的类:<br>两种实现的方式:  </p>
<ol>
<li>继承SimpleTagSupport  </li>
<li>继承TagSupport</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JSP指令</tag>
        <tag>JSP对象</tag>
        <tag>EL</tag>
      </tags>
  </entry>
  <entry>
    <title>11.26Java学习进度</title>
    <url>/2019/11/26/2019-11-26-26ribao/</url>
    <content><![CDATA[<h1 id="Session技术-JSP引擎-JSP指令"><a href="#Session技术-JSP引擎-JSP指令" class="headerlink" title="Session技术,JSP引擎,JSP指令:"></a>Session技术,JSP引擎,JSP指令:</h1><p><strong>Session技术(会话):</strong><br>基于Cookie实现的技术,是Java中的一个键值对的容器,就像我们常用的Map集合<br>技术原理:  </p>
<ol>
<li>浏览器访问服务器时,服务器可以选择创建Session对象.  </li>
<li>session对象在创建时,会生成一个id,我们称其为sessionid,sessionid是session的密钥, 是唯一的!  </li>
<li>session创建完毕后,会自动将sessionid以cookie的形式存储到用户的浏览器中.  </li>
<li>当浏览器再次访问服务器时,会自动携带sessionid发送给服务器.  </li>
<li>服务器得到session后,会去匹配找到对应的session对象,供用户使用  </li>
</ol>
<p><strong>如何获取session对象:</strong><br>在Java中,session是一个Java对象,对象的类型为HttpSession<br>获取Session对象的格式:  </p>
<ol>
<li><p>无参方法:<br>HttpSession session = request.getSession();<br>内部调用了一参方法, 且传入true  </p>
</li>
<li><p>一参方法:<br>HttpSession session = request.getSession(boolean isNew);<br>用于获取session参数:<br>true: 根据当前浏览器传入的sessionid,寻找session对象并返回, 如果不存在, 则创建新的session并返回<br>false: 根据当前浏览器传入的sessionid,寻找session对象并返回, 如果不存在,则返回null</p>
</li>
</ol>
<p><strong>session的常用方法:</strong>  </p>
<ol>
<li>存储数据  <pre><code>session.setAttribute(String key , Object value);
</code></pre></li>
<li>获取数据  <pre><code>session.getAttribute(String key);
</code></pre></li>
<li>删除数据  <pre><code>session.removeAttribute(String key);
</code></pre></li>
<li>销毁session(应用场景: 基本是退出登录)  <pre><code>session.invalidate();
</code></pre></li>
</ol>
<p><strong>session的存活时长:</strong><br>session的默认时长为: 30分钟<br>指的是: 用户的上一次访问大于30分钟时,session自动删除  </p>
<p>设置Session时长:  </p>
<ol>
<li>修改单个session的时长:  <pre><code>session.setMaxInactiveInterval(int 秒);
</code></pre></li>
<li>修改tomcat下,所有session的默认时长:<br>独立环境: 寻找到tomcat/conf/web.xml文件<br>开发环境: 寻找Servers项目中 web.xml </li>
</ol>
<p>修改web.xml中 session-config节点  </p>
<pre><code>&lt;session-config&gt;
    &lt;session-timeout&gt;数值分钟&lt;/session-timeout&gt;
&lt;/session-config&gt;
</code></pre><p><strong>session的优缺点:</strong>  </p>
<p>优点:  </p>
<ol>
<li>数据存储在服务器中,安全  </li>
<li>session存储时的值类型为: Object,可以存储任意类型数据  </li>
<li>可存储的数据大小,理论上是无上限的  </li>
</ol>
<p>缺点:<br>数据在服务器的内存中存储,内存通常是有限的, 会对服务器造成大量的压力, 很容易耗尽服务器资源  </p>
<p><strong>Cookie技术和Session技术不是互斥的:</strong><br>Cookie和Session是结合使用的:  </p>
<ol>
<li>对于安全不敏感的数据,建议使用Cookie存储  </li>
<li>对于安全敏感的数据,建议使用session存储  </li>
<li>对于安全敏感,且较大的数据,存储在数据库  </li>
</ol>
<p><strong>JSP引擎:</strong><br>引擎原理:<br>JSP引擎用于将JSP文件,转换为Servlet  </p>
<ol>
<li>在服务器启动时, JSP引擎读取.jsp文件.  </li>
<li>将文件转换为Servlet的代码,并给servlet添加映射地址为jsp的文件名称.  </li>
<li>当用户浏览器访问jsp文件名称时, 其实请求的不是jsp文件, 而是生成的servlet  </li>
<li>servlet负责给浏览器进行响应  </li>
</ol>
<p><strong>JSP语法结构:</strong><br>JSP文件保存的路径: webContent目录下<br>JSP文件 可以包含HTML代码, Java代码,以及JSP特有的标记.  </p>
<p><strong>Java代码 声明区:</strong><br>指的是Java的成员代码位置, 在JSP声明区中编写的Java代码,会生成到servlet的成员位置.<br>语法:  </p>
<pre><code>&lt;%!
    这里用于编写Java代码,且会生成到声明区
%&gt;
</code></pre><p><strong>Java代码 执行区:</strong><br>指的是Servlet的service方法中. 用户每次请求都会执行<br>语法:  </p>
<pre><code>&lt;%!
    Java代码
%&gt;
</code></pre><p><strong>表达式:</strong><br>用于快速的将Java代码中的变量输出到网页中.<br>语法:  </p>
<pre><code>&lt;%=变量名%&gt;  
</code></pre><p>转换的Java:  </p>
<pre><code>out.print(变量名);
</code></pre><p><strong>JSP中如何编写注释:</strong>  </p>
<p>因为JSP文件包含了三种语法结构(Java/HTML/jsp)<br>所以,三种语法结构的注释,都可以起到注释的效果:<br>html注释:  </p>
<pre><code>&lt;!--html--&gt;  
</code></pre><p>JSP中,HTML的注释会被JSP引擎认为是HTML代码,会转换为</p>
<pre><code>out.write(&quot;&lt;!----&gt;&quot;);  
</code></pre><p>Java注释:  </p>
<pre><code>/*Java注释*/
</code></pre><p>JSP中,Java的注释会被JSP引擎认为是Java代码,会原封不动的放到_jsp.java文件中  </p>
<p>JSP注释:  </p>
<pre><code>&lt;%--JSP注释--%&gt;
</code></pre><p>在JSP引擎将jsp文件 转换为.java文件时,会忽略JSP注释的部分  </p>
<p><strong>JSP三大指令:</strong><br>指令格式:  </p>
<pre><code>&lt;$@ 指令名称 属性名=值 属性名2=值 ... 属性n=值$&gt;
</code></pre><p><strong>page指令:</strong>  </p>
<p>用于设置页面<br>完整格式:  </p>
<pre><code>&lt;%@ page
    language=&quot;java&quot;
    extends=&quot;继承的类&quot;
    buffer=&quot;数值|none&quot;  -- 缓冲大小,none表示不缓冲,默认是8kb
    session=&quot;true|false&quot;  --true:自动创建session
    autoFlush=&quot;true|false&quot;  -- 缓冲器自动清除,默认是true
    isThreadSafe=&quot;true|false&quot;  --&lt;%%&gt;中的代码是否是同步的,true表示同步,默认是false  
    contentType=&quot;text/html;charset=utf-8&quot;  -- 内容类型以及编码格式    

    errorPage=&quot;网页地址&quot;  -- 当JSP代码出错误,页面由指定地址进行显示*  

    isErrorPage=&quot;true|false&quot;  -- true:当前页面是处理错误的页面,只有为true时,才可以查看异常信息.*  

    import=&quot;导包列表&quot;  -- 属性值是一个或多个导入的包,包与包之间使用逗号隔开即可

%&gt;
</code></pre><p><strong>指定项目全局错误页面:</strong>  </p>
<p>编写项目的web.xml<br>在根节点中,加入子节点:  </p>
<pre><code>&lt;error-page&gt;
    &lt;error-code&gt;404&lt;/error-code&gt;
    &lt;location&gt;处理404的页面地址&lt;/location&gt;
&lt;/error-page&gt;
&lt;error-page&gt;
    &lt;error-code&gt;500&lt;/error-code&gt;
    &lt;location&gt;处理500的页面地址&lt;/location&gt;
&lt;/error-page&gt;
</code></pre>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Session技术</tag>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title>11.25Java学习进度</title>
    <url>/2019/11/25/2019-11-25-25ribao/</url>
    <content><![CDATA[<h1 id="Servlet线程安全-请求的转发和重定向"><a href="#Servlet线程安全-请求的转发和重定向" class="headerlink" title="Servlet线程安全,请求的转发和重定向:"></a>Servlet线程安全,请求的转发和重定向:</h1><p><strong>Servlet线程安全:</strong><br>Servlet的service方法,每次被请求时,调用.<br>这个调用很特殊,是在新的子线程中调用的,当service方法执行完毕,子线程死亡了.<br>可以简单理解为: service方法每次执行都是一个新的线程  </p>
<p><strong>代码锁:</strong></p>
<pre><code>synchronized(o){
    //代码线程锁
}
</code></pre><p>多个代码块 尽量不要用同一个锁!!!  </p>
<p><strong>请求的转发:</strong></p>
<p>概念: 一个web组件 将未处理完毕的请求,通过tomcat转交给另一个web组件处理  </p>
<p>步骤: </p>
<ol>
<li>获取请求转发器  </li>
</ol>
<pre><code>RequestDispatcher rd = request.getRequestDispatcher(&quot;转发的地址&quot;);
</code></pre><ol start="2">
<li>通过转发器发起转发  </li>
</ol>
<pre><code>rd.forward(request,response);
</code></pre><p>简写步骤:  </p>
<pre><code>request.getRequestDispatcher(&quot;转发的地址&quot;).forward(request,response);
</code></pre><p>转发流程:<br>    步骤1. 当浏览器访问服务器中tomcat时<br>    步骤2. tomcat将请求信息,与响应工具进行封装,传递给我们的Servlet的service方法进行处理<br>    步骤3. 我们在service方法中 得到请求转发器, 通过请求转发器 告知tomcat,请求转发的地址<br>    步骤4. tomcat接收到请求转发需求,会重新封装请求信息,将请求对象 与 响应对象传递给转发地址的Servlet的service方法进行处理</p>
<p>特点:  </p>
<ol>
<li>转发过程中,多个Servlet之间共享一份请求信息,共享一个响应对象.  </li>
<li>转发只能发生在同一个服务器中.(转发无法实现跨域)  </li>
<li>无论转发发生多少次,对于浏览器来说,只能发起过一次请求,并且只接到了一次响应.  </li>
<li>相对于重定向来说,效率更高</li>
</ol>
<p><strong>请求的重定向:</strong><br>概念: 响应时,告知浏览器的新的请求地址,浏览器接受到 自动请求显得地址!  </p>
<p>步骤:  </p>
<pre><code>response.sendRedirect(&quot;重定向地址&quot;);
</code></pre><p>重定向流程:<br>    步骤1. 当浏览器访问服务时,服务器对浏览器响应一个302的状态码,以及一个location的地址<br>    步骤2. HTTP协议约定,当浏览器接收到302状态码时,会自动寻找location地址,并发起新的请求.(相当于 控制用户浏览器 自动完成页面的跳转操作.)  </p>
<p>特点:  </p>
<ol>
<li>重定向会产生新的请求 和 新的响应.  </li>
<li>使用重定向,可以多个服务器之间发生(可以实现跨域操作)  </li>
<li>浏览器地址栏的内容,会发生改变  </li>
<li>相对于请求转发而言,效率较低  </li>
</ol>
<p><strong>注意:</strong><br>在一次用户的操作中,可以无限制的进行转发和重定向,但是记住: 一定要存在出口  </p>
<p><strong>HttpServletRequest 类常用操作:</strong>  </p>
<ol>
<li>获取访问的客户端ip地址<pre><code>String ip = request.getRemoteAddr();
</code></pre></li>
<li>获取客户端访问的地址(有可能因为服务器映射了多个域名,多个用户的访问地址 不同)  <pre><code>request.getRequestURI();
</code></pre></li>
<li>获取服务器的名称 (通常获取的是ip)  <pre><code>request.getServerName();
</code></pre></li>
<li>获取端口号  <pre><code>request.getServerPort();
</code></pre></li>
<li>获取请求的方式  <pre><code>String method = request.getMethod();
</code></pre></li>
<li>获取get请求的参数(网址中 ? 后面的部分)  <pre><code>String params = request.getQueryString();
</code></pre></li>
</ol>
<p>三个将请求对象 作为数据容器特殊的方式:  </p>
<ol>
<li>存储数据<pre><code>request.setAttribute(String key,Object value);
</code></pre></li>
<li>获取数据<pre><code>Object value = request.getAttribute(String key);
</code></pre></li>
<li>删除数据  <pre><code>request.removeAttribute(String key);
</code></pre></li>
</ol>
<p><strong>ServletContext 上下文:</strong>  </p>
<p>每一个Servlet都是一个独立的用于处理请求的对象<br>为了便于多个Servlet之间的数据交流,JavaWeb提供了一个上下文对象ServletContext<br>我们在任何的Servlet代码中,都可以获得这个ServletContext对象,且每一个Servlet获取的都是同一份ServletContext对象.<br>上下文对象,类似于我们SE所学习的MAP集合,是一个键值对的容器.  </p>
<p>作用: ServletContext是Servlet之间通信的桥梁,用于多个Servlet之间信息的共享.  </p>
<p><strong>从Servlet中得到上下文对象:</strong>  </p>
<p>格式:</p>
<pre><code>    ServletContext context = getServletContext();  
</code></pre><p><strong>ServletContext的常用方法:</strong>  </p>
<ol>
<li>存储数据  <pre><code>context.setAttribute(String key,Object value);
</code></pre></li>
<li>获取数据  <pre><code>Object value = context.getAttribute(String key);
</code></pre></li>
<li>删除数据  <pre><code>context.removeAttribute(String key);
</code></pre></li>
<li>获取项目运行时的 文件夹绝对路径  </li>
</ol>
<p>//因为一个项目,只有一个ServletContext对象,且在项目启动时创建了,项目销毁时销毁.<br>//所以我们再一次项目启动的过程中,一个Servlet存储的数据,任何Servlet都可以获取到</p>
<p><strong>会话跟踪(状态管理):</strong><br>HTTP协议是无状态的, 我们的服务器在与客户端进行交互时,没有记忆.<br>两种方式来实现状态管理:  </p>
<ol>
<li>Cookie技术: 将状态, 存储到客户端中  </li>
<li>Session技术: 将id存储在客户端中, 将状态存储在服务器中  </li>
</ol>
<p><strong>Cookie技术:</strong><br>技术实现步骤以及原理:  </p>
<ol>
<li>当服务器向客户端响应时 ,可以响应头部加入Cookie, 每一个Cookie表示一个键值对.  </li>
<li>浏览器在接收到响应后,如果存在Cookie,则会将Cookie存储在文本文件中(.txt)<br><code>存储时,会存储的信息有: 服务器的域,路径,Cookie键,Cookie的值,存储时长...</code>  </li>
<li>当浏览器向客户端请求时,会遍历Cookie的文本文件,将匹配新请求地址的Cookie携带上,放在请求头部,发送给服务器.<br><code>Cookie匹配的规则:</code><br> <code>当cookie存储的域相同时,路径匹配时,才会将Cookie发送给服务器.</code>   </li>
</ol>
<p><strong>如何创建Cookie:</strong><br>Cookie在Java中的体现,就是一个表示键值对的Java类,类名为:Cookie.<br>格式:  </p>
<pre><code>Cookie cookie = new Cookie(String name,String value);
</code></pre><p><strong>如何将Cookie添加到响应头部:</strong><br>通过响应对象,将Cookie添加到响应头部<br>格式:</p>
<pre><code>response.addCookie(Cookie cookie);
</code></pre><p>一次响应,可以添加n个cookie<br>如果浏览器中已经存储过与某个Cookie的那么相同的Cookie, 再次存储时会覆盖value<br><strong>如何从请求头部 得到之前存储的所有Cookie:  </strong><br>因为一个域 和路径下,可能存在多个Cookie,所以获取的不是单个Cookie,而是数组:  </p>
<pre><code>Cookie[] cookies = request.getCookies();
//如果从未存储过,则返回的数组值是null
</code></pre><p><strong>得到Cookie后,如何取出其中的键和值:</strong><br>获取Cookie的键:  </p>
<pre><code>String name = cookie.getName();
</code></pre><p>获取Cookie的值:  </p>
<pre><code>String value  cookie.getValue();
</code></pre><p><strong>如何调整Cookie存储时长:</strong><br>cookie.getMaxAge(int 秒):<br>传入值:  </p>
<ul>
<li>负数 : 默认 -1 ,表示浏览会话结束时删除  </li>
<li>正数 : 存活的秒数, 例如60*60*24*365*10表示十年  </li>
<li>0 : 经常用于覆盖一个cookie时使用, 作用为0秒后删除(立即删除)  </li>
</ul>
<p><strong>Cookie存储时,路径问题的解决:</strong>  </p>
<p>路径匹配的规则:  </p>
<ul>
<li>Cookie的替换: 只能由相同域,相同路径的完成替换.  </li>
<li>Cookie的获取: 只能由相同域,相同路径或子路径获取  </li>
</ul>
<p>例如:<br>    A地址: localhost/x/a.do<br>    B地址: localhost/x/b.do<br>    C地址: localhost/c.do  </p>
<p>A存储数据时: a/b可以获取, a/b可以替换 . c不能获取也不能替换<br>C存储数据时: a/b/c可以获取 , c可以替换  </p>
<p>Cookie的路径问题,经常影响我们的开发   </p>
<p>JavaWeb给我们提供了一个cookie方法,用于设置Cookie的路径<br>通常我们会将cookie的路径设置为/(根目录)<br>格式:  </p>
<pre><code>cookie.setPath(&quot;/&quot;); 
</code></pre><p><strong>Cookie的优缺点:</strong><br>缺点:  </p>
<ol>
<li>Cookie存储的数据类型,只能是字符串  </li>
<li>数据存储的大小,有限制,最大为4kb  </li>
<li>数据存储在用户的计算机上, 不安全  </li>
<li>受限于用户的浏览器设置,当浏览器禁止使用Cookie时,cookie就无法再存储了  </li>
</ol>
<p>优点:<br>数据存储在客户端, 分散了服务器的压力</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Servlet线程安全</tag>
        <tag>请求的转发和重定向</tag>
        <tag>HttpServletRequest</tag>
      </tags>
  </entry>
  <entry>
    <title>11.21技术分享</title>
    <url>/2019/11/21/2019-11-21-21jishu/</url>
    <content><![CDATA[<h1 id="对谷歌插件的导入导出"><a href="#对谷歌插件的导入导出" class="headerlink" title="对谷歌插件的导入导出:"></a>对谷歌插件的导入导出:</h1><ol>
<li>导出谷歌插件</li>
</ol>
<p>在你的电脑中找到谷歌的安装的位置   </p>
<p>正常情况下默认为<code>C:\Users\Administrator\AppData\Local\Google\Chrome\User Data\Default\Extensions</code></p>
<p>这个路径下存放的都是谷歌浏览器中安装的插件  </p>
<p>将此目录下的插件文件复制即可</p>
<ol start="2">
<li>判断文件分别对应哪个插件  </li>
</ol>
<p>在插件这个目录下 文件名都是随机生成的, 所以我们没办法直接在这里区分哪个插件  </p>
<p>我们可以点进每个文件夹 它的下级目录就是一个版本号 , 在谷歌的扩展程序中寻找与之相同的插件  </p>
<p>那这个文件夹就是对应的插件了 </p>
<ol start="3">
<li>如何导入谷歌插件</li>
</ol>
<p>设置—&gt; 左侧栏扩展程序 —&gt; 右上角确定开启开发者模式 —&gt; 加载已解压的扩展程序  </p>
<p>然后在文件中找到之前复制导出的那些文件夹,<code>注意:要选中加载的文件夹 是乱码名下那个版本号名的文件夹!</code>  </p>
<blockquote>
<p>这里再分享一个安装插件的小技巧  </p>
</blockquote>
<p><strong>有时候我们在网上下载下来的插件是.crx文件,然而谷歌有时候会安装不上这种文件</strong><br><strong>这时候可以将.crx文件后缀名改为<code>.zip</code>或者其他压缩文件后缀名,然后再解压,之后的导入插件步骤同上</strong></p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>谷歌插件</tag>
      </tags>
  </entry>
  <entry>
    <title>11.21Java学习进度</title>
    <url>/2019/11/21/2019-11-21-21ribao/</url>
    <content><![CDATA[<h1 id="Servlet-接收用户表单的参数-GET-POST-乱码问题"><a href="#Servlet-接收用户表单的参数-GET-POST-乱码问题" class="headerlink" title="Servlet,接收用户表单的参数,GET,POST,乱码问题:"></a>Servlet,接收用户表单的参数,GET,POST,乱码问题:</h1><p><strong>Servlet的生命周期:</strong><br>指的是Servlet从创建到消亡的周期!  </p>
<p>Servlet的创建时机: 默认情况, 当用户第一次访问Servlet的映射地址时, 对象创建  </p>
<p>Servlet的销毁时机: 当tomcat关闭,或者 项目从tomcat删除时,Servlet被销毁  </p>
<p>三个方法的体现:  </p>
<ol>
<li>init方法 : 此方法在对象创建后,执行  </li>
<li>service方法 : 服务方法,当用户每一次访问时,执行,用于处理用户的请求,以及对用户进行响应  </li>
<li>destroy方法 : 当tomcat关闭 或 项目从tomcat删除时 执行</li>
</ol>
<blockquote>
<p>在编辑项目的时候遇到了idea不能使用@WebServlet,找了很久才找到解决方法  </p>
</blockquote>
<p><code>解决问题的博客</code>:<a href="https://blog.csdn.net/alinekang/article/details/75669819" target="_blank" rel="noopener">https://blog.csdn.net/alinekang/article/details/75669819</a></p>
<p><strong>ServletConfig对象:</strong><br>是Servlet的配置对象,每一个Servlet都拥有一个ServletConfig.<br>我们在web.xml中 进行Servlet配置是, 可以向一个Servlet中 添加初始化的参数 这些参数以键值对的形式存储在ServletConfig中  </p>
<p>在web.xml中,向ServletConfig存储数据格式:  </p>
<pre><code>&lt;servlet&gt;
    ...
    &lt;!-- init-param标签可以存在多个,每个init-param都表示一个键值对 --&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;键&lt;/param-name&gt;
        &lt;param-value&gt;值&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;
</code></pre><p>在Servlet中 得到ServletConfig对象的方式:<br>方式1与方式2是互斥的  </p>
<ol>
<li><p> 在Servlet中,重写生命周期init(ServletConfig config)方法, 使用方法参数中的config对象  </p>
</li>
<li><p> 在Servlet的任意代码位置,通过getServletConfig();方法,得到对象  </p>
</li>
</ol>
<p>从ServletConfig 取出数据的格式:  </p>
<pre><code>```
String value = config对象.getInitParameter(String name);
```
</code></pre><p><strong>Servlet的创建时机(懒汉 变 饿汉):</strong>  </p>
<p>在web.xml中 配置servlet时 </p>
<pre><code>&lt;servlet&gt;
    &lt;servlet-name...
    &lt;servlet-class...
    &lt;load-on-startup&gt;数字&lt;/load-on-startup&gt;
&lt;/servlet&gt;
</code></pre><p>load-on-startup:<br>取值为数字:(默认值为-1)<br>当值为负数是:懒汉模式,第一次请求时加载,<br>当值&gt;=时,描述的是请求的顺序,值越小越早加载  </p>
<p>如果多个servlet值相同:  按照web.xml中servlet的配置顺序 自上而下加载  </p>
<p><strong>接受用户表单的参数:</strong>  </p>
<ol>
<li>根据一个name,接收单个参数  <pre><code>String value = request.getParameter(String name);
</code></pre></li>
<li>根据一个name,接收一组参数  <pre><code>String[] values = request.getParameters(String name);
</code></pre></li>
</ol>
<p><strong>HttpGET请求 与 HttpPOST请求的区别:</strong><br>GET请求:  </p>
<ul>
<li>请求的参数,以键值对的形式存储在网址中 ,在网址中,编写在<code>?</code>后,有1个或多个键值对之间使用<code>&amp;</code>分割  </li>
<li>只能传输字符串类型的参数  </li>
<li>网址的最大长度为4kb 通常支持的文字2048个文字  </li>
<li>数据传输不安全  </li>
</ul>
<p>tomcat8+版本:  GET请求不会乱码  </p>
<p>POST请求:  </p>
<ul>
<li>请求的数据,以键值对的形式存储在请求体中  </li>
<li>请求体是一个单独的数据包,较GET请求而言, 安全  </li>
<li>可以传输任意类型的数据  </li>
<li>数据的大小,理论上是无上限的  </li>
</ul>
<p>tomcat8+版本: Post请求默认编码为 ISO-8859-1(不支持中文)  </p>
<p><strong>什么样的请求时GET:</strong><br>以我们目前所学习的技术来说,除了表单提交是method=”POST”,其他的访问方式都是GET请求  </p>
<p>例如:  </p>
<ul>
<li>点击超链接 访问  </li>
<li>通过js: window.location.href=’’访问  </li>
<li>浏览器中输入网址+回车  </li>
<li>表单提交时,method=”GET” 或默认  </li>
<li>ajax的get请求  </li>
</ul>
<p><strong>什么样的请求是POST:</strong>  </p>
<ul>
<li>表单提交时method=”POST”  </li>
<li>ajax的post请求  </li>
<li>Java代码的URL类的POST请求  </li>
</ul>
<p><strong>响应的乱码问题:</strong>  </p>
<ol>
<li><p>设置网页的内容类型,以及网页的编码格式:  </p>
<pre><code>response.setContentType(&quot;text/html;charset=utf-8&quot;);
</code></pre></li>
<li><p>设置网页的编码格式(因为没有设置网页内容类型为html,所以浏览器解析时也是乱码)  </p>
<pre><code>response.setCharacterEncoding(&quot;UTF-8&quot;);
</code></pre></li>
</ol>
<p><strong>请求的乱码问题:</strong>  </p>
<p>解决乱码的两种格式:<br>格式1.<br>    tomcat8版本之前,get请求会乱码 以及 所有版本的POST请求乱码:<br>    解决方案:<br>    将乱码的文字,按照乱码的编码ISO-8859-1转换为字节数组,再按照正常的编码UTF-8组装为文字;  </p>
<p>案例:  </p>
<pre><code>// 1. 接受用户传递的参数
String username = request.getParameter(&quot;username&quot;);
// 解决乱码  
{
    // 2. 将乱码的文字通过ISO-8859-1编码打碎成字节数组  
    byte[] bytes = username.getBytes(&quot;ISO-8859-1&quot;);
    // 3. 通过UTF-8编码,将字节数组 重新组装为正常文字  
    username = new String(bytes,&quot;UTF-8&quot;);
}
</code></pre><p>格式2.<br>    格式1 解决乱码适用于参数较少的情况,如果参数过多,解决起来极其麻烦.<br>    tomcat为我们提供了 设置请求体编码的方式:  </p>
<pre><code>注意: 只有POST请求,才有请求体  

格式: request.setCharacterEncoding(&quot;UTF-8&quot;);  
</code></pre><p><code>注意:</code><br>    设置响应乱码的两种方式,都必须写在响应内容之前!</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Servlet生命周期</tag>
        <tag>GET/POST请求</tag>
      </tags>
  </entry>
  <entry>
    <title>11.20心得</title>
    <url>/2019/11/20/2019-11-20-20xinde/</url>
    <content><![CDATA[<h1 id="对于博客模板的修改"><a href="#对于博客模板的修改" class="headerlink" title="对于博客模板的修改:"></a>对于博客模板的修改:</h1><blockquote>
<p>由于19号发现了之前自己的博客模板有一些没改好的地方,便下决心这次要彻底改好一个博客模板</p>
</blockquote>
<p>所以19号的整整一天就都是在找模板,看效果的  </p>
<p>然后晚自习的时候就已经确定好了这个模板,开始着手修改  </p>
<p>由于不太了解博客里面元素和.ejs文件的构造 在改一些东西的时候总会有报错  </p>
<p>后来想到了把所有文件打开  然后去查找那个关键字  </p>
<p>由于有一些js基础,这么一查找到,想做些修改也不是很难  </p>
<p>在将一些404图片修改了,把多余的文字修改了之后  </p>
<blockquote>
<p>后续又对博客进行了一些优化  </p>
</blockquote>
<p>首先将<code>Valine</code>评论区的 ID 和 Key 换成了自己注册的LeanCloud 的ID 和 Key  </p>
<p>还将github博客也推到了coding 这个仓库可以让国内访问github可以快一些  </p>
<p>并将自己之前购买的域名都绑定到了自己的博客上:  </p>
<p><a href="http://zhengyupeng.top" target="_blank" rel="noopener">zhengyupeng.top</a>  </p>
<p><a href="https://www.zhengyupeng.top" target="_blank" rel="noopener">www.zhengyupeng.top</a>  </p>
<p>也都能访问到我的博客了!  </p>
<p><strong>最后总结一下心得吧:</strong>  </p>
<p>昨天一天和今天上午到十点多相当于在学习Java的进度上没有进展,<br>但是改完这个博客,也学到了很多的东西,了解到了很多东西,<br>并且改完这个博客心情都变好了,可以安心学习去了。<br>接下来传完的个博客我就继续学习Java了,<strong><code>冲冲冲!!!</code></strong></p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>11.20Java学习进度</title>
    <url>/2019/11/20/2019-11-20-20ribao/</url>
    <content><![CDATA[<h1 id="JavaWeb开发环境的配置-http协议与HttpServlet类"><a href="#JavaWeb开发环境的配置-http协议与HttpServlet类" class="headerlink" title="JavaWeb开发环境的配置,http协议与HttpServlet类:"></a>JavaWeb开发环境的配置,http协议与HttpServlet类:</h1><p><strong>tomcat配置:</strong>  </p>
<ol>
<li>下载tomcat  </li>
<li>解压到任意的英文目录  </li>
<li>将tomcat引入到项目中  </li>
</ol>
<p><strong>HTTP协议:</strong>  </p>
<pre><code>C/S: 下载客户端  热更新, 人工智能 学习算法  

B / S :  
</code></pre><p>缺点:端口不安全  </p>
<p>优点:只需要维护一端  </p>
<p><code>http协议</code>:超文本传输协议,是一个应用层的网络传输协议!<br><code>特点</code>:  </p>
<ol>
<li>简单,快速  </li>
<li>无连接协议,每次连接服务器只处理一次客户端的请求,处理完毕,立即断开  </li>
<li>无状态协议,处理请求,以及进行响应时,没有记忆能力!  </li>
<li>支持多种不同的数据提交方式,<code>GET/POST</code>等等  </li>
<li>数据传输很灵活,支持任意数据类型  </li>
</ol>
<p><strong>HTTP协议的组成部分:</strong>  </p>
<ol>
<li><p>请求:<br> 请求由四部分组成:  </p>
<ul>
<li>请求头:<br>  请求头部的信息,由一个个的键值对组成,描述的是有关客户端的信息  </li>
<li>请求体:<br>  GET请求没有请求体,当请求方式为POST时,存在请求体,请求体是用于存储数据的数据容器  </li>
<li>请求空行:<br>  请求头部与请求体之间的一行空白  </li>
<li>请求行:<br>  由一个个的键值对组成,描述的是:描述了请求的方式,远端服务器地址,以及所使用的协议版本等信息  </li>
</ul>
</li>
<li><p>响应:<br> 响应由三部分组成:  </p>
<ul>
<li>响应头:<br>  响应头部的信息,由一个个的键值对组成,描述的是有关服务器的信息  </li>
<li>响应体:<br>  服务器给客户端回复的主体内容  </li>
<li>响应行:<br>  描述了响应的协议版本,响应状态码,以及响应成功或失败的相关解释   </li>
</ul>
</li>
</ol>
<h4 id="开发环境下-代码部署到服务器后-访问的路径"><a href="#开发环境下-代码部署到服务器后-访问的路径" class="headerlink" title="开发环境下: 代码部署到服务器后,访问的路径:"></a>开发环境下: 代码部署到服务器后,访问的路径:</h4><pre><code>http://ip地址:端口号/项目名/文件名.后缀名  
</code></pre><h4 id="HttpServlet类"><a href="#HttpServlet类" class="headerlink" title="HttpServlet类:"></a>HttpServlet类:</h4><pre><code>简介:  
    是JavaWeb中的三大组件之一,  
    本质:就是运行在tomcat中的 java类

作用:  
    用于处理客户端的请求,以及对客户端进行响应
步骤:
</code></pre><ol>
<li>编写一个类,继承自HttpServlet  </li>
<li>重写父类的service(HttpSercletRequest request,HttpServletResponse response)方法  </li>
<li>在service方法中 对用户进行响应  </li>
</ol>
<p><strong>案例:</strong>  </p>
<pre><code>public class Servlet1 extends HttpServlet {
    /**
     * 
     * @param request   :   请求对象,包含了请求相关的所有信息
     * @param response  :   响应对象,tomcat提供的用于给客户端响应内容的各种工具
     * @throws ServletException
     * @throws IOException
     */
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 1. 设置响应的编码格式以及响应的内容类型
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        // 2. 获取用于打印响应体的打印流  
        PrintWriter pw = response.getWriter();
        // 3. 打印一些准备响应的内容
        pw.println(&quot;&lt;h1&gt;从前有座山&lt;/h1&gt;&quot;);
        pw.flush();
        // 当service方法执行完毕后,tomcat会将我们准备好的响应体发送给浏览器
    }
}
</code></pre><h3 id="将编写好的servlet-映射到一个网址上"><a href="#将编写好的servlet-映射到一个网址上" class="headerlink" title="将编写好的servlet 映射到一个网址上:"></a>将编写好的servlet 映射到一个网址上:</h3><pre><code>web3.0之前版本:  
    修改项目中的配置文件 web.xml  
    在web.xml根节点中 加入:  
</code></pre><ol>
<li><p>servlet节点, 用于将servlet类告知tomcat</p>
<pre><code> &lt;servlet&gt;
     &lt;servlet-name&gt;任意的标识符,给servlet起别名&lt;/servlet-name&gt;
     &lt;servlet-class&gt;包名.类名&lt;/servlet-class&gt;
 &lt;/servlet&gt;
</code></pre></li>
<li><p>servlet-mapping , 通过别名告知tomcat,某servlet的映射网址<br>映射网址,通常以/开头,例如: /demo1 , 访问网址: <a href="http://ip地址:端口号/项目名/demo1" target="_blank" rel="noopener">http://ip地址:端口号/项目名/demo1</a>  </p>
<pre><code>&lt;/servlet-mapping&gt;
 &lt;servlet-name&gt;要添加映射网址的别名&lt;/servlet-name&gt;
 &lt;url-pattern&gt;/映射的网址&lt;/url-pattern&gt;
&lt;servlet-mapping&gt;
</code></pre></li>
</ol>
<p>web3.0+ 版本:<br>在类前面加一句:  </p>
<pre><code>```
@WebServlet(&quot;/hello2&quot;)
```
</code></pre><p>或者直接创建一个Servlet文件</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>HttpServlet</tag>
      </tags>
  </entry>
  <entry>
    <title>11.18JAVA学习进度</title>
    <url>/2019/11/18/2019-11-18-18ribao/</url>
    <content><![CDATA[<h1 id="11-18Java学习进度"><a href="#11-18Java学习进度" class="headerlink" title="11.18Java学习进度"></a>11.18Java学习进度</h1><h2 id="解析xml属性操作-Xpath"><a href="#解析xml属性操作-Xpath" class="headerlink" title="解析xml属性操作,Xpath:"></a>解析xml属性操作,Xpath:</h2><pre><code>// 1. 加载xml文件到jvm中,形成数据流
InputStream is TestXML_1.class.getClassLoader().getResourceAsStream(&quot;test4.xml&quot;);

// 2. 创建解析对象  
SAXReader sax = new SAXReader();  

// 3. 获得文档对象(整个xml文件)[将数据流转换成一个文档对象]  
Document doc = sax.read(is);  

// 4. 获得根元素  
Element root = doc.getRootElement();  

// 5. 获得根元素下的所有子元素
List&lt;Element&gt; list = root.elements();

//System.out.println(list.size());  
//list.forEach( s -&gt; System.out.println(s));  

//for(Element e1: list){
//    List&lt;Element&gt; list2 = e1.elements();
//   for(Element e2 : list2){
//        System.out.println(e2.getName()+&quot;:&quot;+e2.getData());
//    }
//} 

for(Element e1 : list){
    Attribute type = e1.attribute(&quot;type&quot;);
    System.out.println(type.getValue());
}
</code></pre><p><strong>添加元素:</strong>  </p>
<pre><code>// 创建元素(节点)
Element student = root.addElement(&quot;student&quot;);
Element id = student.addElement(&quot;id&quot;);
id.setText(&quot;3&quot;);
Element name = student.addElement(&quot;name&quot;);
name.setText(&quot;curry&quot;);
Element age = student.addElement(&quot;age&quot;);
age.setText(&quot;30&quot;);

//写入xml文件中
FileOutputStream fos = new FileOutputStream(new File(&quot;D:/xx.xml&quot;));
OutputFormat format = new OutputFormat(&quot;\t\n&quot;,true,&quot;UTF-8&quot;);
XMLWriter xw = new XMLWriter(out,format);

//将整个文档对象写入文件中
xw.write(doc);
System.out.println(&quot;写入成功!&quot;);
xw.close();
</code></pre><p><strong>Xpath:</strong><br>xml文件 path路径  :</p>
<ol>
<li>xpath是一门在xml文档中快速查找信息的方式  </li>
<li>单纯的使用dom4j访问节点时,需要一层一层的处理,如果有了xpath,访问层级的节点就简单了  </li>
<li>使用xpath需要引包: jaxen-1.1-beta-7.jar  </li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>解析xml属性操作</tag>
        <tag>Xpath</tag>
      </tags>
  </entry>
  <entry>
    <title>11.16JAVA学习进度</title>
    <url>/2019/11/16/2019-11-16-16ribao/</url>
    <content><![CDATA[<h1 id="11-16Java学习进度"><a href="#11-16Java学习进度" class="headerlink" title="11.16Java学习进度"></a>11.16Java学习进度</h1><h2 id="数据库优化-XML"><a href="#数据库优化-XML" class="headerlink" title="数据库优化,XML:"></a>数据库优化,XML:</h2><h4 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化:"></a>数据库优化:</h4><ol>
<li><code>在进行表格查询时</code>,where子句中的条件执行顺序是从左至右,清除数据量较大的条件应该放在左边.(<code>特别注意:笛卡尔积消除条件必须放在左边</code>)<pre><code>10000 --&gt;9999 ---&gt;9998 ---&gt;999
10000 ---&gt;999 ---&gt;998
</code></pre></li>
<li><p><code>在进行表格查询时</code>,列名列表应避免<em>号! 数据库在执行查询操作时,会先将</em>号展开,转换为所有的列名,再进行查询.  </p>
</li>
<li><p><code>再进行表格查询时</code>,能使用where条件筛选的数据,应尽量避免使用having子句来筛选,因为where条件执行在having之前,再早起筛选掉大量数据,可以让程序执行的更顺畅.  </p>
</li>
<li><p><code>在进行多表查询时</code>,查询的表顺序是从左至右的,应把表中数据量最少的表放在查询的最右边.  </p>
</li>
<li><p><code>进行多表查询时</code>,应尽可能的给所有表添加别名,能明确的区分有冲突的列.  </p>
</li>
<li><p><code>在使用事务时</code>,应尽量多地commit,尽量早地commit.<br>原因:事务在未提交是,数据库会耗费大量内存,来缓存未提交的SQL结果.  </p>
</li>
<li><p><code>尽可能多的使用函数 来提高SQL执行的效率.</code>  </p>
</li>
<li><p><code>SQL语句编写时</code>,除字符串以外,应使用大写字母.<br>因为SQL语句执行时,会先将小写字母转化为大写字母再执行.  </p>
</li>
<li><p><code>应尽可能少的访问数据库(多次数据访问的结果可能相同,如果缓存起来,可以提高程序的执行效率)</code>  </p>
</li>
<li><p><code>在索引列上</code>,尽可能避免使用not来判断,not关键字入股判断了索引列,会导致此次查询索引失效,转而使用全表扫描的方式查询.  </p>
</li>
<li><p><code>在索引列上</code>,不能使用算数运算符,算数运算也会导致索引列使用,使用全表扫描的方式进行查询.  </p>
</li>
<li><p><code>在查询数据时</code>,如果需要使用&gt;或&lt;的条件,应替换为&gt;=或&lt;=<br><code>原因是&gt;和&lt;符号,查询时是按照&gt;=和&lt;=进行查询,然后再撤去=的结果.</code>  </p>
</li>
</ol>
<h4 id="XML"><a href="#XML" class="headerlink" title="XML:"></a>XML:</h4><p>X(extensible:可扩展的)M(markup标记/标签)L(language语言)<br>可扩展标记语言  </p>
<p><strong>XML语言的作用:</strong>  </p>
<ol>
<li>普通文件太慢,所以采用xml文件保存软件中的数据.  </li>
<li>网络上传递数据.  </li>
<li>配置文件 <em>.properties,  </em>.xml  </li>
</ol>
<p><strong>XML的特点:</strong>  </p>
<ol>
<li>平台无关性, 独立的语言  </li>
<li>90%的语言都支持xml,不支持的10%语言发布的时候,xml还没出世.  </li>
<li>xml具有自我描述性(内容自定义)<br>(1)html文件中,所有标签(元素)都是官方定义好的,我们直接引用<br>(2)xml文件中,所有元素自定义</li>
</ol>
<p><strong>xml语法规则:</strong>  </p>
<ol>
<li>xml文件中必须有根元素  </li>
<li>xml标签(元素)必须有开闭  </li>
<li>xml标签(元素)对大小写敏感  </li>
<li>xml标签(元素)必须正确的嵌套  </li>
<li>xml标签(元素)的属性必须加引号(单双引都可以)  </li>
</ol>
<p><strong>xml注释方式:</strong>  </p>
<pre><code>&lt;!--xml注释--&gt;
</code></pre><p><strong>CDATA区:</strong><br>在xml中书写特殊符号时,报错,忽略其本意,编程普通字符串  </p>
<pre><code>&lt;![CDATA[xxxx]]&gt;
&lt;xx&gt;&lt;![CDATA[ 10&lt;5 ]]&gt;&lt;/xx&gt;
</code></pre><p><strong>DTD文件:</strong><br>Document Type Definition(文档类型定义)<br>DTD的目的: 帮助你编写合法的代码  (可以规范编写的代码)<br>DTD和XML之间的关系:<br>类(人类)和对象(我)的关系<br>数据库表和行(一条记录)的关系  </p>
<p><strong>XSD文件:</strong><br>xsd是xml结构定义<br>xsd是dtd的替代品,比dtd高端<br>xsd的优点:<br>xsd的代码基于xml,没有专门的语法,和xml一样的解析和处理<br>xsd支持一系列的数据类型  </p>
<p><strong>解析XML:</strong>  </p>
<p>解析xml共有四种方式:  </p>
<ol>
<li>DOM解析  </li>
<li>SAX解析  </li>
<li>JDOM解析  </li>
<li>DOM4J解析  </li>
</ol>
<p>前两种属于基础方法,是官方提供的与平台无关的解析方式;<br>后两种属于扩展方法,他们是在基础的方法之上扩展出来的,只适用于java平台.  </p>
<p><strong>DOM解析:</strong>  </p>
<ol>
<li>dom解析的原理解析xml时候,把文档中的所有元素按照期出现的层次关系,在内存中构造出树形结构.  </li>
<li>dom的有点就是可以遍历和修改节点的内容  </li>
<li>缺点是内存压力较大,解析较慢  </li>
</ol>
<p><strong>SAX解析:</strong>  </p>
<ol>
<li>是一种xml解析的替代方法  </li>
<li>相对比dom方式,sax是一种速度更快,更有效的方法  </li>
<li>不能修改节点内容  </li>
</ol>
<p><strong>JDOM解析:</strong>  </p>
<ol>
<li>仅适用具体的类,而不用接口,不灵活  </li>
</ol>
<p><strong>DOM4J:</strong>  </p>
<ol>
<li>JDOM的一种智能分支,合并了许多超出基本xml文档功能  </li>
<li>著名的底层框架hibernate就是用dom4j来解析  </li>
</ol>
<p>dom4j性能最高,其次是SAX,dom和jdom表现不好(解析10M大小的xml文件,就内存溢出了。)  </p>
<p>DOM4J解析:需要引包:  </p>
<pre><code>// 1. 加载xml文件到jvm中,形成数据流
InputStream is TestXML_1.class.getClassLoader().getResourceAsStream(&quot;test4.xml&quot;);

// 2. 创建解析对象  
SAXReader sax = new SAXReader();  

// 3. 获得文档对象(整个xml文件)[将数据流转换成一个文档对象]  
Document doc = sax.read(is);  

// 4. 获得根元素  
Element root = doc.getRootElement();  

// 5. 获得根元素下的所有子元素
List&lt;Element&gt; list = root.elements();

//System.out.println(list.size());  
//list.forEach( s -&gt; System.out.println(s));  

for(Element e1: list){
    List&lt;Element&gt; list2 = e1.elements();
    for(Element e2 : list2){
        System.out.println(e2.getName()+&quot;:&quot;+e2.getData());
    }
}
</code></pre><p><strong>常见错误:</strong>  </p>
<ol>
<li>文件位置错误: xml文件要放在src下  </li>
<li>类型引用错误</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库优化</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>11.16技术分享</title>
    <url>/2019/11/16/2019-11-16-16jishu/</url>
    <content><![CDATA[<h1 id="11-16技术分享"><a href="#11-16技术分享" class="headerlink" title="11.16技术分享"></a>11.16技术分享</h1><h2 id="idea运行tomcat控制台乱码"><a href="#idea运行tomcat控制台乱码" class="headerlink" title="idea运行tomcat控制台乱码:"></a>idea运行tomcat控制台乱码:</h2><h3 id="1-首先设置idea的编码格式"><a href="#1-首先设置idea的编码格式" class="headerlink" title="1.首先设置idea的编码格式:"></a>1.首先设置idea的编码格式:</h3><p>File–&gt;Settings–&gt;File Encodings</p>
<p><img src="https://s2.ax1x.com/2019/11/20/MWMwvV.md.png" alt="idea编码格式">  </p>
<p>将所有编码格式统一设置成UTF-8。  </p>
<h3 id="2-再设置tomcat的编码格式"><a href="#2-再设置tomcat的编码格式" class="headerlink" title="2.再设置tomcat的编码格式:"></a>2.再设置tomcat的编码格式:</h3><p><img src="https://s2.ax1x.com/2019/11/20/MWMyE4.png" alt="tomcat设置">  </p>
<p>改变VM options为-Dfile.encoding=UTF-8:<br><img src="https://s2.ax1x.com/2019/11/20/MWMrbF.md.png" alt="tomcat编码格式"> </p>
<p><strong><code>完成上面的设置后还会有乱码,不要急</code></strong>  </p>
<h3 id="3-配置idea的文件设置"><a href="#3-配置idea的文件设置" class="headerlink" title="3.配置idea的文件设置:"></a>3.配置idea的文件设置:</h3><p>找到idea图标,右键,打开文件位置找到  </p>
<p><code>idea.exe.vmoptions</code>和<code>idea64.exe.vmoptions</code>文件  并打开文件  </p>
<p>在文件后面添加一行：-Dfile.encoding=UTF-8   </p>
<p>idae中的设置配置也要修改</p>
<p>help–&gt;Edit Custom VM Options…  </p>
<p>打开此配置 也在最后一行添加:-Dfile.encoding=UTF-8  </p>
<h3 id="4-修改tomcat的运行编码格式"><a href="#4-修改tomcat的运行编码格式" class="headerlink" title="4.修改tomcat的运行编码格式:"></a>4.修改tomcat的运行编码格式:</h3><p>进入到tomcat的根目录的bin目录下  </p>
<p>此时可以在文件地址栏输入cmd来启动dos窗口执行  </p>
<pre><code>catalina.bat run
</code></pre><p>(或者也可以直接cmd  然后cd到bin目录下 执行此命令)  </p>
<p>之后再用命令切换cmd的编码格式<br>“chcp 65001”切换cmd为utf8，”chcp 936”切换cmd为gbk  </p>
<p>这里我们使用chcp 65001来切换成utf8  </p>
<p>执行之后可以再运行一下</p>
<pre><code>catalina.bat run
</code></pre><p>看看命令是否都编程正常汉语,若都成正常汉语就是成功了!</p>
<p>然后重启idea即可.  </p>
<p><code>最后提一句:</code>  </p>
<p>自己改tomcat的logging.properties为GBk会导致调试时get/post参数乱码  </p>
<p>还是都改成UTF8稳妥。</p>
]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>idea控制台乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>11.15JAVA学习进度</title>
    <url>/2019/11/15/2019-11-15-15ribao/</url>
    <content><![CDATA[<h1 id="11-15Java学习进度"><a href="#11-15Java学习进度" class="headerlink" title="11.15Java学习进度"></a>11.15Java学习进度</h1><h4 id="JDBC事务-批处理-连接池"><a href="#JDBC事务-批处理-连接池" class="headerlink" title="JDBC事务,批处理,连接池:"></a>JDBC事务,批处理,连接池:</h4><p><strong>JDBC事务:</strong><br>在dos命令行操作oracle时,执行DML,需要结束事务(commit提交 或 rollback回退)<br>在JDBC中,事务是自动提交的,每执行一条DML语句,事务就自动提交一次<br>我们可以通过JDBC的事务API,开始事务的手动提交,将多条DML语句看作一个整体要么一起成功,要么一起失败.    </p>
<p><strong>事务特性:</strong><br>特性:  </p>
<p>事务是恢复和并发控制的基本单位。<br>事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。<br><code>原子性</code>（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。<br><code>一致性</code>（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。<br><code>隔离性</code>（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。<br><code>持久性</code>（durability）。持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。  </p>
<p><strong>JDBC事务操作格式:</strong><br>注意: 开启事务的手动提交,是通过连接对象完成的.<br>    某个数据连接对象的事务开启手动提交后,这个连接对象的事务需要手动控制,其他连接对象不受影响.<br>操作方法:  </p>
<ol>
<li><p>开始事务的手动提交:  </p>
<pre><code>conn.setAutoCommit(boolean flag);
参数含义: true表示自动提交 , false表示手动提交.
</code></pre></li>
<li><p>提交事务:  </p>
<pre><code> conn.commit();
</code></pre></li>
<li>回退事务到上次提交:  <pre><code> rollback();
</code></pre></li>
</ol>
<p><strong>预编译sql:</strong>  </p>
<pre><code>PreparedStatement prepareStatement = conn.prepareStatement(&quot;sql语句&quot;);  
</code></pre><p>注意: 方法名是<code>prepareStatement</code>,而返回类型是<code>PreparedStatement</code>  </p>
<p><strong>execute、executeUpdate区别:</strong>  </p>
<p> 不同1：  </p>
<p>execute可以执行查询语句，然后通过getResultSet，把结果集取出来。</p>
<p>executeUpdate不能执行查询语句。</p>
<p>不同2:</p>
<p>execute返回boolean类型，true表示执行的是查询语句，false表示执行的是insert,delete,update等等。</p>
<p>executeUpdate返回的是int，表示有多少条数据受到了影响。  </p>
<p><strong>批处理:</strong><br>将多条SQL语句放到一起批量处理,<br>批处理将多次对于数据库的操作次数,减少到了一次,提高了大量SQL语句一起执行时的性能.  </p>
<p>使用步骤:  </p>
<p>批处理使用Statement类操作<br>    步骤1. 将一条SQL语句加入到批处理中</p>
<pre><code>    ```
    statement.addBatch(String sql);
    ```  

步骤2. 执行批处理中的所有语句  
    ```
    Statement.executeBatch();
    ```  
</code></pre><p><strong>properties文件与类:</strong><br>常用于java的配置文件,<br>因为Properties文件 可以快速的与Properties类 进行转换.<br>里面不能中文,会被转换为Unicode编码。  </p>
<p>文件:<br>注释:  #开头表示注释行<br>键值对: 键与值之间使用等号连接,多个键值对之间使用换行分割  </p>
<p>如何将一个Properties文件,转换为java中的Map集合对象:<br>步骤:  </p>
<ol>
<li><p>创建Properties对象  </p>
<pre><code>Properties ppt = new Properties();
</code></pre></li>
<li><p>创建Properties文件的字节输入流  </p>
<pre><code>InputStream is = // 可以通过 new FileInputStream, 也可以通过ClassLoader等等  
</code></pre></li>
<li><p>将流加载到Properties对象  </p>
<pre><code>ppt.load(is);
</code></pre></li>
</ol>
<p><strong>连接池:</strong><br>有连接池创建连接,维护连接<br>我们需要使用连接是,从连接池中获取连接,<br>如果池中存在空闲连接,则拿去使用.<br>如果不存在空闲连接,且池未满,则再连接池中创建新的连接使用.<br>如果不存在空闲连接,且池已满,则排队等待空闲连接.</p>
<p>使用步骤:  </p>
<ol>
<li>引入相关的jar文件 </li>
</ol>
<ul>
<li>dbcp  : 连接池的代码  </li>
<li>poll  : 连接池的依赖库  </li>
</ul>
<ol start="2">
<li>创建一个properties文件,描述连接池的配置,内容如下:  </li>
</ol>
<ul>
<li>数据库连接地址<br>url=jdbc:oracle:thin:@localhost:1521:xe  </li>
<li>数据库驱动地址<br>driverClassName=oracle.jdbc.OracleDriver  </li>
<li>数据库账号<br>username=system  </li>
<li>数据库密码<br>password=123456  </li>
</ul>
<p><strong>扩展配置:</strong>  </p>
<ul>
<li>初始化连接池时,创建的连接数量:<br>initialSize=5  </li>
<li>最大允许存在的连接数量<br>maxActive=200  </li>
<li>空闲时允许保留的最大连接数量<br>maxIdle=10  </li>
<li>空闲时间允许保留的最小连接数量<br>minIdle=5  </li>
<li>排队等候的超时时间<br>maxWait=20000  </li>
</ul>
<ol start="3">
<li><p>将properties文件,转化为Properties对象.<br>Properties ppt = new Properties();<br>ppt.load(文件输入流);  </p>
</li>
<li><p>通过连接池工厂类(BasicDataSourceFactory),创建连接池对象(一次程序启动,创建一个连接池就够了.)<br>DataSource ds =BasicDataSourceFactory.createDataSource(ppt);  </p>
</li>
<li><p>通过连接池对象,获取池中的连接<br>Connection conn = ds.getConnection();</p>
</li>
<li><p>正常JDBC操作<br><strong>实例:</strong>  </p>
<pre><code>public class Demo {
 public static void main(String[] args) throws Exception {

     // 3. properties文件转换为Properties对象
     Properties ppt = new Properties();
     // 4. 加载文件的输入项
     InputStream is = Demo.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;);
     ppt.load(is);
     // 5. 通过工厂类床创建连接池
     DataSource ds = BasicDataSourceFactory.createDataSource(ppt);
     // 6. 通过连接池,获取其中的连接,并使用
     Connection conn = ds.getConnection();

     //正常的JDBC操作
     PreparedStatement state = conn.prepareStatement(&quot;insert into STUDENTS values (STUDENTS_STUID_SEQ.nextval,&#39;小刚&#39;,25)&quot;);
     int count = state.executeUpdate();
     System.out.println(count&gt;0?&quot;数据插入成功&quot;:&quot;数据插入失败&quot;);
 }
}
</code></pre></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JDBC事务</tag>
        <tag>SQL批处理</tag>
        <tag>连接池</tag>
      </tags>
  </entry>
  <entry>
    <title>11.14JAVA学习进度</title>
    <url>/2019/11/14/2019-11-14-14ribao/</url>
    <content><![CDATA[<h1 id="11-14Java学习进度"><a href="#11-14Java学习进度" class="headerlink" title="11.14Java学习进度"></a>11.14Java学习进度</h1><h4 id="防止sql注入-创建序列-工具类思想-配置文件思想-DAO"><a href="#防止sql注入-创建序列-工具类思想-配置文件思想-DAO" class="headerlink" title="防止sql注入,创建序列,工具类思想,配置文件思想,DAO:"></a>防止sql注入,创建序列,工具类思想,配置文件思想,DAO:</h4><p><strong>防止sql注入:</strong><br>使用PreparedStatement 替换 Statement:  </p>
<ol>
<li>可以防止拼接的sql注入, 原理就是你输入的数据不拼接,直接作为真实数据。  </li>
<li>采用预编译,会提前生成sql的执行计划,提高执行效率。  </li>
<li>拼接sql 每次sql是不同的 这回给数据库服务器的sql造成冲击,无法实现批处理。  </li>
<li>由于不拼接sql, 程序员出错的概率会降低, 提高编程质量和速度。   </li>
</ol>
<pre><code>String newSql = &quot;select from students where stuid = ?&quot;;
</code></pre><p>可以更安全的防止sql注入  </p>
<p><strong>创建序列:</strong>  </p>
<pre><code>create sequence students_stuid_seq;
</code></pre><p>一张表对应一个序列  </p>
<pre><code>String newSql = &quot;insert into students values(
    &quot;+&quot;students_stuid_seq.nextval,?,?)&quot;;
</code></pre><p><strong>工具类的思想:</strong><br>将多个文件会重复使用的类封装到一起,使用时直接调用,减少代码的复用度。  </p>
<p><strong>src路径又叫源码路径,或者类路径</strong></p>
<p><strong>一个类要得到类的加载器方法:</strong><br>类名.class.getClassLoader();</p>
<p><strong>配置文件的思想:</strong><br>将工具类中的数据提取出来额外放置,易于用户改变而不触碰源码  </p>
<p><strong>DAO思想:</strong><br>Data Access Object 数据访问对象<br>它是对数据访问过程封装的对象  </p>
<p><strong>编写DAO:</strong>  </p>
<ol>
<li>根据需求编写DAO 对应的接口  </li>
<li>使用DBUtil 工具类 结合JDBC编程得五步 实现接口中对应的方法  </li>
</ol>
<pre><code>Connection conn     连接对象
Statement state     执行环境
ResultSet result     结果集对象
</code></pre>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>工具类思想</tag>
        <tag>DAO</tag>
      </tags>
  </entry>
  <entry>
    <title>11.13JAVA学习进度</title>
    <url>/2019/11/13/2019-11-13-13ribao/</url>
    <content><![CDATA[<h1 id="11-13Java学习进度"><a href="#11-13Java学习进度" class="headerlink" title="11.13Java学习进度"></a>11.13Java学习进度</h1><h4 id="JDBC-oracle常用表结构操作-防止sql注入"><a href="#JDBC-oracle常用表结构操作-防止sql注入" class="headerlink" title="JDBC,oracle常用表结构操作,防止sql注入:"></a>JDBC,oracle常用表结构操作,防止sql注入:</h4><p><strong>JDBC访问数据库的步骤:</strong>  </p>
<ol>
<li>加载驱动  </li>
<li>获取连接 Connection  </li>
<li>定义sql 并获取sql的执行环境 Statement  </li>
<li>执行sql 处理sql 返回值<br> select 返回ResultSet 遍历<br> dml 返回int 代表影响数据行数  </li>
<li>释放资源<br> Connection Statement ResultSet  </li>
</ol>
<p><strong>oracle常用表结构操作:</strong><br>常用表结构操作</p>
<p>–添加表字段<br>   alter  table  tablename  add(columnName  columnType); </p>
<p>–删除字段的语法：<br>   alter  table  tablename  drop(columnName);</p>
<p>–修改字段名<br>   alter  table tableName rename column oldCName to newCName;</p>
<p>–修改数据类型<br>   alter  table  tableName  modify(columnName 数据类型);</p>
<p>–删除触发器<br>   drop  trigger  triggerName;</p>
<p>–删除序列<br>   drop  sequence  sequenceName;</p>
<p>–修改表名字</p>
<p>   alter  table  old_table_name  rename  to  new_table_name;</p>
<p>–修改字段为非空</p>
<p>   alter  table  tableName  modify  columnName  not  null  enable  novalidate;</p>
<p>–修改表字段为空</p>
<p>   alter  table  tableName  modify  columnName  default  null;</p>
<p><strong>防止sql注入:</strong><br>使用PreparedStatement 替换 Statement:  </p>
<ol>
<li>可以防止拼接的sql注入, 原理就是你输入的数据不拼接,直接作为真实数据。  </li>
<li>采用预编译,会提前生成sql的执行计划,提高执行效率。  </li>
<li>拼接sql 每次sql是不同的 这回给数据库服务器的sql造成冲击,无法实现批处理。  </li>
<li>由于不拼接sql, 程序员出错的概率会降低, 提高编程质量和速度。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>oracle常用表结构操作</tag>
      </tags>
  </entry>
  <entry>
    <title>11.12技术分享</title>
    <url>/2019/11/12/2019-11-12-12jishu/</url>
    <content><![CDATA[<h1 id="批处理-强制删除"><a href="#批处理-强制删除" class="headerlink" title="批处理:强制删除"></a>批处理:强制删除</h1><h4 id="批处理文件编辑"><a href="#批处理文件编辑" class="headerlink" title="批处理文件编辑:"></a>批处理文件编辑:</h4><pre><code>DEL /F /A /Q \\?\%1
RD /S /Q \\?\%1
</code></pre><p>将上边代码另存为.bat文件<br>将需要删除的文件拖到文件上就可以实现强制删除.<br>%1可以替换为特定路径,此时双击即可实现对特定路径的删除.<br>这个批处理常用于普通手段无法删除的文件  </p>
<p>另外在实际使用中可以在这两条指令后加&gt;nul，运行时将不显示命令。 </p>
<p>代码参数：</p>
<p>del 删除命令.  </p>
<p>/F 强制删除只读文件.  </p>
<p>/S 从所有子目录删除指定文件.  </p>
<p>/Q 安静模式。删除全局通配符时，不要求确认.  </p>
<p>%systemdrive% 系统文件夹，如C:\windows，有的朋友将系统装在D中，则表示D:\WINDOWS </p>
<p>%1默认为使用此批处理时输入的第一个值  </p>
<p>*.(特定文件后缀名) 指文件的通配符  </p>
<p>如<em>.tmp,</em>.log</p>
<p>全句意思是：强制删除系统文件夹下所有的格式为tmp的文件(哪怕文件是只读的)，并且在删除时不用向用户询问是否继续或终止! </p>
<p>RD [/S] [/Q] [驱动器:]路径 </p>
<p>/S 除目录本身外，还将删除指定目录下的所有子目录和<br>文件。用于删除目录树。 </p>
<p>/Q 安静模式，加 /S 时，删除目录树结构不再要求确认</p>
<hr>
<p>DEL /F /A /Q \?\%1<br>意思是以静默模式强制删除所有根目录及只读文件；<br>RD /S /Q \?\%1<br>意思是以静默模式强制删除所有子目录及文件。 </p>
<p>\?\看作一种统一路径。<br>?代表任何电脑，首先肯定搜索本地计算机，\.\把?换成.的话就表示本机了。   </p>
<p>批处理每次能处理的变量从%0—%9共10个，其中%0默认给批处理文件名使用，%1默认为使用此批处理时输入的的第一个值.  </p>
<p>同理：%2—%9指输入的第2-9个值。</p>
]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>强制删除</tag>
      </tags>
  </entry>
  <entry>
    <title>10.26JAVA学习进度</title>
    <url>/2019/10/26/2019-10-26-26ribao/</url>
    <content><![CDATA[<h1 id="10-26Java学习进度"><a href="#10-26Java学习进度" class="headerlink" title="10.26Java学习进度"></a>10.26Java学习进度</h1><h4 id="泛型机制-Queue集合-Set集合-Map集合"><a href="#泛型机制-Queue集合-Set集合-Map集合" class="headerlink" title="泛型机制,Queue集合,Set集合,Map集合:"></a>泛型机制,Queue集合,Set集合,Map集合:</h4><p><strong>泛型机制基本概念:</strong><br>通常情况下集合中可以存放不同类型的对象，本质上是将这些对象全部看做Object类型放入的，因此从集合中取出元素时也是Object类型，为了表达元素最真实的数据类型就需要强制类型转换，而强制类型转换可能发生类型转换异常。<br>为了避免上述错误的发生，从jdk1.5开始提出泛型机制，也就是在集合名称的右侧使用&lt;数据类型&gt;的方式明确要求该集合可以存放的元素类型，若放入其它类型则编译报错    </p>
<p>如：</p>
<pre><code>List lt1 = new LinkedList();   - 可以放入任意类型对象，取出麻烦
List&lt;String&gt; lt1 = new LinkedList&lt;String&gt;(); - 只能放入String类型，取出方便
</code></pre><p><strong>原理分析:</strong><br>泛型的本质就是参数化类型，也就是让数据类型作为参数传递，集合定义中的E相当于形式参数负责占位，而使用集合时&lt;&gt;中的数据类型相当于实际参数负责给形式参数初始化，当初始化完毕后所有E被替换为实际参数表示的类型进行使用。<br>由于E支持的数据类型非常广泛，因此得名为”泛型”.<br>如:</p>
<pre><code> // 其中i叫做形式参数，负责占位                
 // 其中E叫做形式参数，负责占位
   // int i = 5;    
    E = String;
   // int i = 10;
    E = Student;
   public void show(int i) {
       public interface List&lt;E&gt; {
       ...
       }
   }
   // 其中5叫做实际参数，用于给形式参数初始化
   其中String叫做实际参数
    show(5); 
    List&lt;String&gt; lt1 = ...;
    show(10);                                    
    List&lt;Student&gt; lt2 = ...;
</code></pre><p><strong>Queue集合:</strong><br><strong>基本概念:</strong>  </p>
<p>java.util.Queue集合是Collection集合的子集合，与List集合是平级关系。<br>该集合的主要实现类是：LinkedList类，因为该类在增删方面有一定的优势。<br>该集合用于描述具有先进先出特征的数据结构，叫做队列。 </p>
<p><strong>Queue接口中主要方法如下:</strong>  </p>
<table>
<thead>
<tr>
<th style="text-align:center">Queue接口的常用方法</th>
<th style="text-align:center">功能描述  </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean offer(E e)</td>
<td style="text-align:center">将一个对象添加至对位,若成功则返回true </td>
</tr>
<tr>
<td style="text-align:center"> E poll()</td>
<td style="text-align:center">从队首删除并返回一个元素  </td>
</tr>
<tr>
<td style="text-align:center"> E peek()</td>
<td style="text-align:center">返回队首的元素(但并不删除)   </td>
</tr>
</tbody>
</table>
<p><strong>Set集合:</strong><br><strong>基本概念:</strong><br>java.util.Set集合是Collection集合的子集合，与List集合以及Queue集合平级关系<br>该集合与List集合的主要区别在于：元素没有先后次序并且不允许重复的元素。<br>该集合的主要实现类有：HashSet类 和 TreeSet类。<br>其中HashSet类的底层采用哈希表进行数据管理的。<br>其中TreeSet类的底层采用二叉树进行数据管理的。  </p>
<p><strong>HashSet集合放入元素的过程:</strong><br>1.先调用元素的hashCode()方法得到哈希码,通过算法计算在哈希表中的位置。<br>2.如果该位置没有元素，直接放入即可。<br>3.如果该位置有元素，调用元素的equals()方法比较是不是相等。<br>4.如果相等，则保留旧元素丢弃新元素。<br>5.如果不相等，则放入该位置的链表中下一个元素  </p>
<p><strong>使用迭代器来访问集合中所有元素:</strong>  </p>
<pre><code>Iterator&lt;String&gt; it = s1.iterator();
while(it.hasNext()) {
    System.out.println(&quot;获取到的元素是：&quot; + it.next());
}
</code></pre><p><strong>使用StringBuilder类和迭代器实现toString方法的效果:</strong> </p>
<pre><code>// 构造StringBuilder类型的对象用于拼接
        StringBuilder sb1 = new StringBuilder();
        // 使用迭代器取出集合中的每个元素并拼接到StringBuilder对象中
        sb1.append(&quot;集合中的元素有：[&quot;);
        // 重新获取迭代器，或者叫重置迭代器[one, two, three]
        it = s1.iterator();
        while(it.hasNext()) {
            //sb1.append(it.next()).append(&quot;,&quot;).append(&quot; &quot;);
            String ts = it.next();
            // 当条件成立时证明该元素不是最后一个元素
            if(it.hasNext()) {
                sb1.append(ts).append(&quot;,&quot;).append(&quot; &quot;);
            } else {
                sb1.append(ts).append(&quot;]&quot;);
            }
        }
        // 最后多余的逗号和空格删除
        //sb1.delete(sb1.length()-2,sb1.length()).append(&quot;]&quot;);
        // 打印最终的拼接结果
        System.out.println(sb1); //[one, two, three]
</code></pre><p><strong>注意:</strong><br>当使用迭代器迭代集合中的所有元素时，若使用集合中的remove方法来删除元素，则会出现ConcurrentModificationException并发修改异常，以后的开发中应该使用迭代器的remove方法来删除元素。  </p>
<p><strong>增强版的for循环(for each结构):</strong>  </p>
<p>(1)语法格式</p>
<pre><code>   for(元素类型 变量名 : 数组名/集合名) {
      循环体;
   }
</code></pre><p>(2)执行流程<br>   不断地从数组或集合中取出一个元素并赋值给变量并执行循环体，直到处理完毕所有元素为止。  </p>
<p><strong>总结:</strong><br>遍历Set集合的方式有三种：toString()、for each结构、迭代器方式<br>遍历List集合的方式有四种：除了上述3种方式外，还有get方法。  </p>
<p><strong>Map集合基本概念:</strong>  </p>
<p>java.util.Map&lt;K,V&gt;集合中操作元素的基本单位是：单对元素，其中类型参数如下：<br>    K - 此映射所维护的键(key)的类型<br>    V - 映射值(value)的类型<br>该集合中不允许出现重复的键，每个键最多只能映射到一个值。<br>该集合的主要实现类有：HashMap类 和 TreeMap类。<br>其中HashMap类的底层是采用哈希表进行数据管理的。<br>其中TreeMap类的底层是采用二叉树进行数据管理的。  </p>
<p><strong>Map集合的遍历方式:</strong><br>迭代方式一: 迭代Key </p>
<pre><code>map = ...//初始化map
Set&lt;Character&gt; keySet = map.keySet();
for(Iterator&lt;Character&gt;i=
    keySet.iterator();i.hasNext();){
        Character key = i.next();
        Integer value = map.get(key);
        System.out.println(key+&quot;:&quot;+value);
    }
</code></pre><p>迭代方式二: 迭代Entry</p>
<pre><code>map = ...//初始化map
Set&lt;Entry&lt;Character,Integer&gt;&gt;
    entries=map.entrySet();
for(Entry&lt;Character,Integer&gt; e:entries){
    Character kry = e.getKey();
    Integer value = e.getValue();
    System.out.println(key+&quot;:&quot;+value);
}
</code></pre>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>泛型机制</tag>
        <tag>Queue集合</tag>
        <tag>Set集合</tag>
        <tag>Map集合</tag>
      </tags>
  </entry>
  <entry>
    <title>10.25JAVA学习进度</title>
    <url>/2019/10/25/2019-10-25-25ribao/</url>
    <content><![CDATA[<h1 id="10-25Java学习进度"><a href="#10-25Java学习进度" class="headerlink" title="10.25Java学习进度"></a>10.25Java学习进度</h1><h4 id="String类的常用方法-StringBuilder类和StringBuffer类-日期相关的类-Collection集合-List集合"><a href="#String类的常用方法-StringBuilder类和StringBuffer类-日期相关的类-Collection集合-List集合" class="headerlink" title="String类的常用方法,StringBuilder类和StringBuffer类,日期相关的类,Collection集合,List集合:"></a>String类的常用方法,StringBuilder类和StringBuffer类,日期相关的类,Collection集合,List集合:</h4><p><strong>String类的基本方法:</strong><br>检测字符串是否为”回文”:</p>
<pre><code>String str = &quot;上海自来水来自上海&quot;;
for(int i = 0; i&lt;str.length()/2; i++){
    if(str.charAt(i)!= str.charAt(str.length()-1-i)){
        System.out.println(&quot;不是回文&quot;);
        return;
    }
}
System.out.println(&quot;是回文&quot;);
</code></pre><p><strong>StringBuilder类和StringBuffer类:</strong>  </p>
<p>由于String类型描述的字符串内容是个常量不可更改，当程序中出现大量类似的字符串时需要单独存放从而浪费内存空间，若希望使用一块内存空间进行存储并且可以修改字符串内容，则应该使用StringBuilder类和StringBuffer类。</p>
<p>其中StringBuffer类，支持线程安全，访问的效率比较低 </p>
<p>其中StringBuilder类，不支持线程安全，访问的效率比较高    </p>
<p><strong>StringBuilder类的常用方法:</strong>  </p>
<table>
<thead>
<tr>
<th style="text-align:center">StringBuilder类的常用方法</th>
<th style="text-align:center">功能描述  </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"> StringBuilder append(String str)</td>
<td style="text-align:center">追加字符串 </td>
</tr>
<tr>
<td style="text-align:center"> StringBuilder insert(int offset,String str)</td>
<td style="text-align:center">插入字符串  </td>
</tr>
<tr>
<td style="text-align:center"> StringBuilder delete(int start, int end)</td>
<td style="text-align:center">删除字符串  </td>
</tr>
<tr>
<td style="text-align:center"> StringBuilder replace(int start, int end, String str)</td>
<td style="text-align:center">替换字符串 </td>
</tr>
<tr>
<td style="text-align:center"> StringBuilder reverse()</td>
<td style="text-align:center">字符串反转  </td>
</tr>
</tbody>
</table>
<p> <strong>日期相关的类:</strong>  </p>
<p> <strong>Date类基本概念:</strong><br> java.util.Date类用于描述特定的瞬间，可以精确到毫秒。  </p>
<p> <strong>SimpleDateFormat类基本概念:</strong><br> java.text.SimpleDateFormat类主要用于实现日期和文本之间的相关转换。  </p>
<p> <strong>Calendar类基本概念:</strong><br>java.util.Calendar类用于取代Date类来描述年月日时分秒的特定瞬间。   </p>
<p><strong>Collection集合:</strong><br><strong>集合框架:</strong><br><img src="https://s2.ax1x.com/2019/11/20/MWMa3q.md.jpg" alt="Collection框架"><br><img src="https://s2.ax1x.com/2019/11/20/MWMdg0.md.jpg" alt="Collection框架详细">  </p>
<p><strong>集合的由来:</strong><br>当需要在程序中记录单个数据内容时，则声明一个变量即可；<br>当需要在程序中记录多个类型相同的数据内容时，则声明一个一维数组即可；<br>当需要在程序中记录多个类型不同的数据内容时，则构造一个对象即可；<br>当需要在程序中记录多个类型相同的对象时，则声明一个对象数组即可；<br>当需要在程序中记录多个类型不同的对象时，则声明一个集合即可；  </p>
<p><strong>集合框架结构:</strong><br>在Java语言中集合框架的顶层是：java.util.Collection集合 和 java.util.Map集合<br>其中Collection集合中操作元素的基本单位是：单个元素。<br>其中Map集合中操作元素的基本单位是：单对元素。<br>在以后的开发中很少直接使用Collection集合，而是使用该集合的子集合：List集合、Queue集合、Set集合等。  </p>
<p><strong>Collection集合基本概念:</strong><br>java.util.Collection集合是集合框架的根接口，其它接口是该接口的子接口。  </p>
<p><strong>Collection集合的常用方法:</strong>  </p>
<table>
<thead>
<tr>
<th style="text-align:center">Collection集合的常用方法</th>
<th style="text-align:center">功能描述  </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean add(E e)</td>
<td style="text-align:center">向集合中添加对象 </td>
</tr>
<tr>
<td style="text-align:center"> boolean contains(Object o)</td>
<td style="text-align:center">判断是否包含指定对象  </td>
</tr>
<tr>
<td style="text-align:center"> boolean remove(Object o)</td>
<td style="text-align:center">从集合中删除对象  </td>
</tr>
<tr>
<td style="text-align:center"> void clear()</td>
<td style="text-align:center">清空集合 </td>
</tr>
<tr>
<td style="text-align:center"> int size()</td>
<td style="text-align:center">返回包含对象的个数  </td>
</tr>
<tr>
<td style="text-align:center"> boolean isEmpty()</td>
<td style="text-align:center">判断是否为空   </td>
</tr>
</tbody>
</table>
<h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合:"></a>List集合:</h2><p><strong>基本概念:</strong><br>java.util.List集合是Collection集合的子集合，该集合中元素有先后次序且允许重复<br>该集合的主要实现类有：ArrayList类、 LinkedList类、Stack类、Vector类等。</p>
<p>其中ArrayList类的底层是采用动态数组进行数据管理，访问方便，增删不方便。  </p>
<p>其中LinkedList类的底层是采用链表进行数据管理，增删方便，访问不方便。  </p>
<p>其中Stack类主要用于描述具有后进先出特征的数据结构，叫做栈，last in first out<br>该类的底层是采用数组进行数据的管理。  </p>
<p>其中Vector类的底层采用数组进行数据的管理，与ArrayList类相比属于线程安全的类，因此效率比较低，在以后的开发中推荐使用ArrayList类取代之。</p>
<p><strong>常用的方法:</strong><br>List集合的常用方法 | 功能描述<br> :-: | :-:<br>void add(int index,E element) | 向集合中指定位置添加元素<br> boolean addAll(int index,Coolection&lt;?extends E&gt; c) | 向集合中添加所有元素<br> E get(int index) | 从集合中获取指定位置元素<br> E set(int index,E element) | 修改指定位置的元素<br> E remove(int index) | 删除指定位置的元素     </p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>String类</tag>
        <tag>Collection集合</tag>
        <tag>List集合</tag>
      </tags>
  </entry>
  <entry>
    <title>10.24JAVA学习进度</title>
    <url>/2019/10/24/2019-10-24-24ribao/</url>
    <content><![CDATA[<h1 id="10-24Java学习进度"><a href="#10-24Java学习进度" class="headerlink" title="10.24Java学习进度"></a>10.24Java学习进度</h1><h4 id="Object类-包装类和数学处理类-String类"><a href="#Object类-包装类和数学处理类-String类" class="headerlink" title="Object类,包装类和数学处理类,String类:"></a>Object类,包装类和数学处理类,String类:</h4><p><strong>Object类:</strong><br>常用的包<br>java.lang包 - 该包是Java语言中的核心包，该包中的内容由Java虚拟机自动导入<br>如：  String类、System类等<br>java.util包 - 该包是Java语言中的工具包，里面包含了大量的工具类和集合类等<br>如：Scanner类、Random类等<br>java.io包   - 该包是Java语言中的输入输出包，里面包含了大量读写文件的类等<br>如：FileOutputStream类、FileInputStream类等<br>java.net包  - 该包是Java语言中的网络包，里面包含了大量网络编程的类等<br>如：ServerSocket类、Socket类等  </p>
<p><strong>Object类基本概念:</strong><br>java.lang.Object类是所有类层次结构的根类，任何类都是该类的直接或间接子类。  </p>
<p><strong><em>Object常用的方法:</em></strong><br>Object() - 使用无参方式构造对象。<br>boolean equals(Object obj) - 用于判断调用对象是否与参数对象相等。  </p>
<ul>
<li>该方法默认比较两个对象的地址，与 == 运算符结果相同。</li>
<li>为了使得该方法比较两个对象的内容，则需要重写该方法。</li>
<li>若该方法重写后，则应该重写hashCode方法来维护  hashCode方法的常规协定  </li>
</ul>
<p>int hashCode() - 用于获取调用对象的哈希码值(内存地址的编号)。  </p>
<ul>
<li>若调用equals方法的结果相等，则各自调用hashCode方法的结果相同。 </li>
<li>若调用equals方法的结果不相等，则各自调用hashCode方法的结果不相同。</li>
<li>为了维护上述的常规协定与equals方法结果保持一致，就需要重写该方法  </li>
</ul>
<p>String toString() - 用于获取对象的字符串形式。  </p>
<ul>
<li>该方法默认返回的字符串为：包名.类名@哈希码值的十六进制形式</li>
<li>为了返回更有意义的数据内容则需要重写该方法</li>
<li>当字符串内容与引用进行连接时，自动调用toString方法</li>
<li>当使用print或println方法打印引用时，会自动调用toString方法</li>
</ul>
<p><strong>包装类和数学处理类:</strong><br>如:</p>
<pre><code>Person p = new Person();  - 声明Person类型的引用指向Person类型的对象
   int num = 10;             - 声明一个int类型的变量num初始值为10
   public class MyInteger {
      private int num = 10;
   }
   MyInteger it = new MyInteger();
</code></pre><p><strong>包装类的概念:</strong><br>由于Java语言是一门纯面向对象编程语言，而8种基本数据类型声明的变量并不是对象，为了满足Java语言的特性就需要对这些变量进行对象化处理，而实现该功能的相关类就叫做包装类。  </p>
<p><strong>包装类的分类:</strong><br>int  =&gt; java.lang.Integer类<br>char =&gt; java.lang.Character类<br>其它类型对应的包装类就是将首字母变成大写  </p>
<p><strong>Integer类基本概念:</strong><br>(1)基本概念<br>   java.lang.Integer类是int类型的包装类，里面包含了一个int类型的成员变量。<br>   该类由final关键字修饰表示不能被继承。</p>
<p>(2)常用的方法<br>   Integer(int value) - 根据参数指定的整数构造对象<br>   Integer(String s) - 根据参数指定的字符串构造对象<br>   该类重写了equals()、hashCode()、toString()方法<br>   int intValue() - 用于获取调用对象中的整数数据并返回。<br>   static Integer valueOf(int i) - 根据参数指定的整数返回对应的Integer对象。<br>   static int parseInt(String s) - 用于将String类型转换为int类型并返回。  </p>
<p><strong>BigDecimal类:</strong><br><strong>BigDecimal类基本概念:</strong><br>由于float类型和double类型的运算可能会有误差，为了实现精确运算则需要借助java.math.BigDecimal类型加以描述。   </p>
<p><strong>BigDecimal类常用方法:</strong><br>BigDecimal(String val) - 根据参数指定的字符串构造对象。<br>BigDecimal add(BigDecimal augend) - 用于计算调用对象和参数对象的和并返回<br>BigDecimal subtract(BigDecimal subtrahend) - 用于计算调用对象和参数对象的差并返回。<br>BigDecimal multiply(BigDecimal multiplicand) - 用于计算调用对象和参数对象的积并返回。<br>BigDecimal divide(BigDecimal divisor) - 用于计算调用对象和参数对象的商并返回。  </p>
<p><strong>String类:</strong><br><strong>String类基本概念:</strong>  </p>
<p>java.lang.String类用于描述字符串，Java应用程序中所有字符串字面值都可以作为String类型的对象加以描述，如：”abc”等。<br>   该类描述的字符串内容是个常量，一旦创建完毕后则不能更改，因此可以被共享。</p>
<p><strong>常量池:</strong><br>由于String类型描述的字符串内容是个常量不可改变，因此Java虚拟机提供了一个常量池，当Java程序中出现字符串内容时就放入常量池中，若后续出现重复的字符串内容则直接使用池中已有的对象而不需再次创建，从而提高了性能。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>String类</tag>
        <tag>Object类,</tag>
        <tag>包装类和数学处理类,</tag>
      </tags>
  </entry>
  <entry>
    <title>10.23JAVA学习进度</title>
    <url>/2019/10/23/2019-10-23-23ribao/</url>
    <content><![CDATA[<h1 id="10-23Java学习进度"><a href="#10-23Java学习进度" class="headerlink" title="10.23Java学习进度"></a>10.23Java学习进度</h1><h4 id="访问控制-final关键字-多态-抽象类-接口-匿名内部类"><a href="#访问控制-final关键字-多态-抽象类-接口-匿名内部类" class="headerlink" title="访问控制,final关键字,多态,抽象类,接口,匿名内部类:"></a>访问控制,final关键字,多态,抽象类,接口,匿名内部类:</h4><p><strong>访问控制:</strong><br>常用的访问控制符 访问控制符 访问权限 本类 本包中的类 子类 其它包中的其它类</p>
<hr>
<pre><code> public       公有的      ok        ok        ok          ok  
 protected    保护的      ok        ok        ok          no
 啥也不写      默认的      ok        ok        no          no
 private      私有的      ok        no        no          no
</code></pre><p>a.public修饰的内容可以在任意位置使用；<br>b.private修饰的内容只能在本类中使用；<br>c.通常情况下，成员变量都使用private修饰，成员方法都使用public修饰；</p>
<p><strong>final关键字:</strong><br>基本概念:<br>final本意为”最终的，不可更改的”，该关键字可以修饰类、成员方法、成员变量等。<br>使用方式:<br>final关键字修饰类表示该类不能被继承。 </p>
<ul>
<li>为了防止滥用继承带来的危害</li>
<li>如：java.lang.String类等  </li>
</ul>
<p>final关键字修饰成员方法表示该方法不能被重写但可以被继承。</p>
<ul>
<li>为了防止不经意间造成的方法重写</li>
<li>如：java.text.DateFormat类中的format方法等  </li>
</ul>
<p>final关键字修饰成员变量表示该成员变量必须初始化而且不能更改。  </p>
<ul>
<li>为了防止不经意间造成数值的更改。</li>
<li>如：java.lang.Thread类中的MAX_PRIORITY等  </li>
</ul>
<blockquote>
<p>扩展:<code>在以后的开发中很少单独使用static关键字或final关键字修饰成员变量，通常都是使用public static final共同修饰成员变量来表达常量的含义。  常量的命名规则是：要求所有字母大写，不同单词之间采用下划线连接，如：
   public static final double PI = 3.14;</code></p>
</blockquote>
<p><strong>多态:</strong><br>基本概念:<br>多态主要指同一种事物表现出来的多种形态。<br>语法格式:<br>父类类型 引用变量名 = new 子类类型();<br>如：</p>
<pre><code>   Person pw = new Worker();
   pw.show();
</code></pre><p>解析：  </p>
<p>编译阶段调用Person类中show方法，在运行阶段调用Worker类中重写以后的show方法  </p>
<p>多态的效果  </p>
<p>(1)当父类的引用指向子类的对象时，父类的引用可以直接调用父类独有的方法；<br>(2)当父类的引用指向子类的对象时，父类的引用不可以直接调用子类独有的方法；<br>(3)对于父子类都有的非静态成员方法来说，编译阶段调用父类版本，运行阶段调用子类重写以后的版本；<br>(4)对于父子类都有的静态方法来说，编译和运行阶段调用父类版本，隶属于类层级，因此与指向的对象无关；  </p>
<p><strong>引用数据类型之间的转换:</strong>  </p>
<p>(1)引用数据类型之间的转换分为：自动类型转换和强制类型转换。  </p>
<p>其中自动类型转换主要指从小范围到大范围之间的转换，也就是子类到父类的转换<br>其中强制类型转换主要指从大范围到小范围之间的转换，也就是父类到子类的转换  </p>
<p>(2)引用数据类型之间的转换必须发生在父子类之间，否则编译报错。<br>(3)若转换到的目标类型是子类类型但不是该引用真正指向的子类类型，则编译通过，运行阶段发生类型转换异常。<br>(4)为了避免上述错误的发生，可以使用instanceof进行判断，具体格式如下：<br>if(引用变量名 instanceof 数据类型) - 判断引用变量指向的对象是否为后面类型</p>
<p><strong>多态的意义:</strong>  </p>
<p>多态的实际意义在于可以屏蔽不同子类的差异性实现通用的编程，但可以调用不同的方法带来不同的结果。  </p>
<p><strong>抽象类的概念:</strong><br>抽象方法的概念<br>抽象方法就是指不能具体实现的方法，也就是没有方法体并使用abstract关键字修饰  </p>
<p>语法格式：<br>访问控制符 abstract 返回值类型 方法名称(形参列表);<br>如：  </p>
<pre><code>  public abstract void cry();  
</code></pre><p><strong>注意事项:</strong>  </p>
<p>(1)抽象类中可以有成员变量、构造方法以及成员方法；<br>(2)抽象类中可以有抽象方法也可以没有抽象方法；<br>(3)拥有抽象方法的类必须是抽象类，因此严格来说，具有抽象方法并且使用abstract关键字修饰的类才算真正意义上的抽象类。  </p>
<p><strong>实际意义:</strong><br>抽象类的意义不在于自身创建对象而在于被继承，当一个类继承抽象类后必须重写抽象类中的抽象方法，否则该类也变成抽象类。<br>也就是说抽象类对子类具有强制性和规范性，因此叫做模板设计模式。</p>
<p><strong>经验：</strong><br>在以后的开发中推荐使用多态的语法格式，当父类的引用指向子类的对象时，那么父类引用直接调用的所有方法一定是父类拥有的方法，若希望更换子类时，只需要将new关键字后面的类型修改而其它地方无需更改立即生效，从而提高了代码的可维护性。<br>该方式的缺点就是：父类引用不能直接访问子类独有的方法，若访问则需要强转。   </p>
<p><strong>接口基本概念:</strong><br>接口就是一种比抽象类还抽象的类，体现为所有成员方法都是抽象方法。<br>定义类的关键字是class，而定义接口的关键字是interface。<br>继承类的关键字是extends，而实现接口的关键字是implements。<br><strong>类和接口之间的关系:</strong><br>类和类之间的关系:      使用extends关键字表达继承的关系     支持单继承<br>类和接口之间的关系:    使用implemets关键字表达实现的关系   支持多实现<br>接口和接口之间的关系:  使用extends关键字表达继承的关系     支持多继承    </p>
<p><strong><em>抽象类和接口之间的区别(笔试题):</em></strong><br>(1)定义抽象类的关键字是abstract class，而定义接口的关键字是interface。<br>(2)继承抽象类的关键字是extends，而实现接口的关键字是implements。<br>(3)继承抽象类支持单继承，而实现接口可以多实现。<br>(4)抽象类中可以有构造方法，而接口中不可以有构造方法。<br>(5)抽象类中可以有成员变量，而接口中只可以有常量。<br>(6)抽象类中可以有成员方法，而接口中只可以有抽象方法。<br>(7)抽象类中增加方法可以不影响子类，而接口中增加方法通常都影响子类。<br>(8)从jdk1.8开始允许接口中出现非抽象方法，但需要使用default关键字修饰。  </p>
<p><strong>匿名内部类:</strong><br>语法格式:</p>
<pre><code>接口/父类类型 引用变量名 = new 接口/父类类型(){ 方法的重写 };
</code></pre><p><strong>经验的分享:</strong><br>当接口类型的引用作为方法的形参时，实参的传递方式有两种：<br>a.自定义类实现接口，然后创建该类的对象作为实参传递；<br>b.使用匿名内部类的语法格式来得到接口类型的引用作为实参传递；   </p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>访问控制</tag>
        <tag>关键字</tag>
        <tag>接口</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>10.22JAVA学习进度</title>
    <url>/2019/10/22/2019-10-22-22ribao/</url>
    <content><![CDATA[<h1 id="10-22Java学习进度"><a href="#10-22Java学习进度" class="headerlink" title="10.22Java学习进度"></a>10.22Java学习进度</h1><h4 id="封装-static关键字-单例设计模式-继承与方法的重写"><a href="#封装-static关键字-单例设计模式-继承与方法的重写" class="headerlink" title="封装,static关键字,单例设计模式,继承与方法的重写:"></a>封装,static关键字,单例设计模式,继承与方法的重写:</h4><p><strong>封装基本概念:</strong><br>为了避免对成员变量的赋值合法但是不合理,与现实生活不符,为了避免这种现象采用封装.<br>封装可以保证成员变量的合理性.</p>
<p><strong>封装的实现流程:</strong><br>(1)私有化成员变量，使用private关键字修饰；<br>(2)提供公有的get和set方法，在方法体中进行合理值的判断；<br>(3)在构造方法中调用set方法进行合理值的判断；<br><strong><em>对于封装的实现,大框架可以在编译器里实现:</em></strong><br><em>(1)eclipse中用右键-Source(alt+shift+s)中的带Generate的一些选项实现</em><br><em>(2)idea中用右键-Generate…(alt+insert)选项中选项实现</em></p>
<p><strong>static关键字:</strong><br>使用static关键字修饰成员变量表达静态的含义，该成员变量由对象层级提升为类层级被所有对象共享，该成员变量随着类的加载准备就绪，与是否创建对象无关。<br>static关键字就是把对象级提高到类级,在<code>类加载</code>时就准备完成了,而不需要创建对象(new)。<br>静态的成员(属性和方法)可以用 对象. 调用,但是一般推荐用 类名. 调用  </p>
<p><strong>类加载只做一次,包括:</strong><br>(1)类名. 时会类加载.<br>(2)new对象 时会类加载.<br>(3)程序员可以用程序加载,比如Class.forName()</p>
<p><strong>使用方式:</strong><br>(1)在非静态的成员方法中既能访问非静态的成员也能访问静态的成员；<br>(成员：成员变量 + 成员方法， 静态成员被所有对象共享)<br>(2)在静态的成员方法中只能访问静态的成员不能访问非静态的成员；<br>(成员：成员变量 + 成员方法， 调用静态方法时可能还没有创建对象)<br>(3)只有隶属于类层级被所有对象共享的内容才可以使用static修饰；<br>(不能滥用static关键字)</p>
<p><strong>单例设计模式:</strong><br>(1)基本概念<br>   在某些特殊场合中一个类对外提供且只提供一个对象，这样的类叫做单例类。<br>   而设计单例类的思想和模式叫做单例设计模式，主要用于固定的场合。</p>
<p>(2)实现流程<br>   a.私有化构造方法，使用private关键字修饰；<br>   b.声明本类类型的引用指向本类类型的对象，使用private static共同修饰；<br>   c.提供公有的get方法负责将成员变量的数值返回出去，使用static关键字修饰；  </p>
<p>(3)实现方式<br>   单例设计模式的实现方式有两种：饿汉式 和 懒汉式，在以后的开发中推荐饿汉式。</p>
<pre><code>public class Singleton {

    // 2.提供本类类型的引用指向本类类型的对象
    // Person p = new Person();
    private static Singleton sin = new Singleton(); //饿汉式
    private static Singleton sin = null;            //懒汉式

    // 1.私有化构造方法，使用private关键字修饰
    // private修饰构造方法表示该方法只能在本类的内部使用
    private Singleton(){}

    // 3.提供公有的get方法负责将成员变量返回出去
    public static Singleton getInstance() {
        //return sin;
        if(null == sin) {
            sin = new Singleton();
        }
        return sin;
    }
}
</code></pre><p><strong>继承的基本概念:</strong><br>当多个类之间有相同的特征和行为时，可以将相同的内容提取出来组成一个公共类，让多个类吸收公共类中已有特征和行为而在多个类的内部编写自己独有特征和行为的方式，叫做继承。<br>使用继承可以提高代码的复用性和扩展性以及可维护性。<br>在Java语言中使用extends(扩展)关键字来表达继承关系。  </p>
<p>如：<br>   public class Student extends Person {}  - 表示Student类继承自Person类<br>   其中Person类叫做基类、父类、超类<br>   其中Student类叫做派生类、子类、孩子类    </p>
<p><strong><em>注意事项:</em></strong>  </p>
<p>(1)子类可以继承父类的成员变量和成员方法，其中私有成员变量可以继承但不可以直接使用，子类不可以继承父类的构造方法和私有方法。<br>(2)无论使用何种方式构造子类对象时，都会自动调用父类中的无参构造方法来初始化从父类中继承下来的成员变量，相当于在子类构造方法第一行增加代码:super()的效果。<br>(3)Java语言中只支持单继承不支持多继承，也就是一个子类只能有一个父类，但一个父类可以有多个子类。</p>
<p><strong>方法的重写(override):</strong><br>(1)基本概念<br>   若从父类中继承下来的方法不满足子类的需求时，就需要在子类中重新写一个与父类中一样的方法来覆盖从父类中继承的版本，这种方式就叫做重写。</p>
<p>(2)重写的原则(笔试题)<br>  a.要求方法名相同、参数列表相同、返回值类型相同，从jdk1.5开始允许返回子类类型<br>  b.要求方法的访问权限不能变小，可以相同或者变大。<br>  c.要求不能抛出更大的异常(异常机制)。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>封装</tag>
        <tag>static关键字</tag>
        <tag>继承与方法的重写</tag>
        <tag>单例设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>10.21JAVA学习进度</title>
    <url>/2019/10/21/2019-10-21-21ribao/</url>
    <content><![CDATA[<h1 id="10-21Java学习进度"><a href="#10-21Java学习进度" class="headerlink" title="10.21Java学习进度"></a>10.21Java学习进度</h1><h4 id="封装-static关键字-单例设计模式"><a href="#封装-static关键字-单例设计模式" class="headerlink" title="封装,static关键字,单例设计模式:"></a>封装,static关键字,单例设计模式:</h4><p><strong>封装基本概念:</strong><br>为了避免对成员变量的赋值合法但是不合理,与现实生活不符,为了避免这种现象采用封装.<br>封装可以保证成员变量的合理性.</p>
<p><strong>封装的实现流程:</strong><br>(1)私有化成员变量，使用private关键字修饰；<br>(2)提供公有的get和set方法，在方法体中进行合理值的判断；<br>(3)在构造方法中调用set方法进行合理值的判断；<br><strong><em>对于封装的实现,大框架可以在编译器里实现:</em></strong><br><em>(1)eclipse中用右键-Source(alt+shift+s)中的带Generate的一些选项实现</em><br><em>(2)idea中用右键-Generate…(alt+insert)选项中选项实现</em></p>
<p><strong>static关键字:</strong><br>使用static关键字修饰成员变量表达静态的含义，该成员变量由对象层级提升为类层级被所有对象共享，该成员变量随着类的加载准备就绪，与是否创建对象无关。<br>static关键字就是把对象级提高到类级,在<code>类加载</code>时就准备完成了,而不需要创建对象(new)。<br>静态的成员(属性和方法)可以用 对象. 调用,但是一般推荐用 类名. 调用  </p>
<p><strong>类加载只做一次,包括:</strong><br>(1)类名. 时会类加载.<br>(2)new对象 时会类加载.<br>(3)程序员可以用程序加载,比如Class.forName()</p>
<p><strong>使用方式:</strong><br>(1)在非静态的成员方法中既能访问非静态的成员也能访问静态的成员；<br>(成员：成员变量 + 成员方法， 静态成员被所有对象共享)<br>(2)在静态的成员方法中只能访问静态的成员不能访问非静态的成员；<br>(成员：成员变量 + 成员方法， 调用静态方法时可能还没有创建对象)<br>(3)只有隶属于类层级被所有对象共享的内容才可以使用static修饰；<br>(不能滥用static关键字)</p>
<p><strong>单例设计模式:</strong><br>(1)基本概念<br>   在某些特殊场合中一个类对外提供且只提供一个对象，这样的类叫做单例类。<br>   而设计单例类的思想和模式叫做单例设计模式，主要用于固定的场合。</p>
<p>(2)实现流程<br>   a.私有化构造方法，使用private关键字修饰；<br>   b.声明本类类型的引用指向本类类型的对象，使用private static共同修饰；<br>   c.提供公有的get方法负责将成员变量的数值返回出去，使用static关键字修饰；  </p>
<p>(3)实现方式<br>   单例设计模式的实现方式有两种：饿汉式 和 懒汉式，在以后的开发中推荐饿汉式。</p>
<pre><code>public class Singleton {

    // 2.提供本类类型的引用指向本类类型的对象
    // Person p = new Person();
    private static Singleton sin = new Singleton(); //饿汉式
    private static Singleton sin = null;            //懒汉式

    // 1.私有化构造方法，使用private关键字修饰
    // private修饰构造方法表示该方法只能在本类的内部使用
    private Singleton(){}

    // 3.提供公有的get方法负责将成员变量返回出去
    public static Singleton getInstance() {
        //return sin;
        if(null == sin) {
            sin = new Singleton();
        }
        return sin;
    }
}
</code></pre><p><strong>继承的基本概念:</strong><br>当多个类之间有相同的特征和行为时，可以将相同的内容提取出来组成一个公共类，让多个类吸收公共类中已有特征和行为而在多个类的内部编写自己独有特征和行为的方式，叫做继承。<br>   使用继承可以提高代码的复用性和扩展性以及可维护性。<br>   在Java语言中使用extends(扩展)关键字来表达继承关系。  </p>
<p>如：<br>   public class Student extends Person {}  - 表示Student类继承自Person类<br>   其中Person类叫做基类、父类、超类<br>   其中Student类叫做派生类、子类、孩子类  </p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>封装</tag>
        <tag>static关键字</tag>
        <tag>单例设计</tag>
      </tags>
  </entry>
  <entry>
    <title>10.19JAVA学习进度</title>
    <url>/2019/10/19/2019-10-19-19ribao/</url>
    <content><![CDATA[<h1 id="10-19Java学习进度"><a href="#10-19Java学习进度" class="headerlink" title="10.19Java学习进度"></a>10.19Java学习进度</h1><h4 id="构造方法-方法重载-this关键字-方法的传参和调用"><a href="#构造方法-方法重载-this关键字-方法的传参和调用" class="headerlink" title="构造方法,方法重载,this关键字,方法的传参和调用:"></a>构造方法,方法重载,this关键字,方法的传参和调用:</h4><p><strong>学习了构造方法的概念和使用</strong><br>无参和有参构造方法的使用</p>
<p><strong>方法的重载概念和体现形式</strong><br>几个类的方法名相同,参数列表不同,就是重载<br>在创建对象时候会根据不同参数调用不同构造方法  </p>
<p><strong>this关键字的使用方式,原理:</strong><br>在构造方法中代表当前正在构造的对象<br>在成员方法中代表当前正在调用的对象   </p>
<p><em>使用方式:</em><br>(1)当形参变量和成员变量同名是,在构造方法或成员方法中通常优先使用形参变量,若希望使用成员变量就需要在变量名的前面加上<code>this.</code>进行说明<br>(2)在构造方法的第一行使用<code>this</code>(实参)的方式可以调用本类中的其他构造方法</p>
<p><strong>this关键字的作用:</strong><br>所有成员变量不能重名,再同一区域的局部变量不能重名,但是成员变量可以重命名.<br>在局部变量的作用区域外,变量名代表成员变量,在局部变量的作用域之间,代表局部变量,如果想使用成员变量,需要<code>this.</code>的方式访问  </p>
<p>在方法中可以通过调用关键字表示”调用该方法的那个对象”.  </p>
<p><strong>this关键字和空值:</strong><br>引用类型变量用于存放对象的地址,可以给引用类型赋值为null,表示不指向任何对象.<br>当某个引用类型变量为null时无法对对象实施访问,<br>此时通过引用访问成员变量或调用方法会产生<code>NullPointerException</code>异常(空指针异常)</p>
<p><strong>方法的传参和递归调用:</strong><br><em>方法的传参过程:</em><br>(1)main方法是程序的入口，为main方法中的局部变量开辟内存空间并初始化；<br>(2)调用max方法时为max方法的形参变量开辟内存空间；<br>(3)使用实参变量给形参变量进行赋值操作，执行max方法的方法体；<br>(4)当max方法结束后释放形参变量的内存空间；<br>(5)main方法中的res得到max方法的返回值然后继续向下执行；<br>(6)当main方法结束后释放局部变量的内存空间；</p>
<p><code>a.当基本数据类型的变量作为方法的参数传递时，形参变量的改变不会影响到实参;</code><br><code>b.当引用数据类型的变量作为方法的参数传递时，形参变量指向的内容发生改变后会影响到实参变量指向的内容；</code><br><code>c.当引用数据类型的变量作为方法的参数传递时，形参变量改变指向后再改变指向的内容时不会影响到实参变量指向的内容；</code></p>
<p><em>递归调用:</em>  </p>
<h3 id="调用方法的本质就是根据方法名跳过去"><a href="#调用方法的本质就是根据方法名跳过去" class="headerlink" title="调用方法的本质就是根据方法名跳过去"></a>调用方法的本质就是根据方法名跳过去</h3><p>(1)基本概念:<br>方法叫做递归。<br>如：</p>
<pre><code>   void show(){
      show();
   }
</code></pre><p>案例：<br>   自定义成员方法实现参数n阶乘的计算并返回。  </p>
<p>解析：</p>
<pre><code>   5! = 5 * 4 * 3 * 2 * 1;
   4! = 4 * 3 * 2 * 1;
   3! = 3 * 2 * 1;
   2! = 2 * 1;
   1! = 1;

   n! = n * (n-1) * (n-2) * ... * 1;

   5! = 5 * 4!;
   4! = 4 * 3!;
   3! = 3 * 2!;
   2! = 2 * 1!;
   1! = 1;

   n! = n * (n-1)!;
</code></pre><p><strong>递推:</strong></p>
<pre><code>int show(int n){
    int res = 1;
    for(int i = n; i &gt; 1; i--){
        res *=i;
    }
    return res;
}
</code></pre><p><strong>递归:</strong>  </p>
<pre><code>if(1 == n){
    return 1;
}
return n * show(n-1); 
</code></pre><p><strong>(2)注意事项:</strong>  </p>
<p>a.必须找到递归的规律和退出条件；<br>b.使用递归使得问题简单化而不是复杂化；<br>c.若递归影响到程序的执行性能则使用递推取代之；</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>构造方法,方法重载</tag>
        <tag>this关键字</tag>
        <tag>方法的传参和调用</tag>
      </tags>
  </entry>
  <entry>
    <title>10.18JAVA学习进度</title>
    <url>/2019/10/18/2019-10-18-18ribao/</url>
    <content><![CDATA[<h1 id="10-18Java学习进度"><a href="#10-18Java学习进度" class="headerlink" title="10.18Java学习进度"></a>10.18Java学习进度</h1><h4 id="数组元素之间的操作-号码的生成和去重-面向对象的基本概念和三大特征-了解了类和对象的概念"><a href="#数组元素之间的操作-号码的生成和去重-面向对象的基本概念和三大特征-了解了类和对象的概念" class="headerlink" title="数组元素之间的操作,号码的生成和去重,面向对象的基本概念和三大特征,了解了类和对象的概念:"></a>数组元素之间的操作,号码的生成和去重,面向对象的基本概念和三大特征,了解了类和对象的概念:</h4><p>学习了数组元素之间的拷贝  </p>
<p>统计拆分的原理和实现:求出一串数字各数字出现的次数  </p>
<p>双色球号码的生成和去重<br>去重方法:<br>当前元素与之前元素对比如果有相同的就使用i– 再重新生成一遍当前数组下标的元素  </p>
<p>面向对象的基本概念:<br>万物皆对象!!<br>面向对象就是指以特征和行为的观点去分析现实事物的方式  </p>
<p>c语言是面向过程<br>c++是既面向过又面向对象<br>java是面向对象</p>
<p>面向对象编程的三大特征:<br>封装、继承、多态</p>
<p>了解了对象和类的概念</p>
<p>类的定义:</p>
<pre><code>class 类名{

}
</code></pre><p>成员变量定义的语法格式:</p>
<pre><code>class 类名{
    数据类型 成员变量名 = 初始值;(初始值通常省略)
}
</code></pre><p>对象的创建:</p>
<pre><code>new 类名();
</code></pre><p>对象的引用:(例)</p>
<pre><code>new Person();

Person p = new Person();
</code></pre><p>成员方法:</p>
<pre><code>class 类名{
    返回值类型 成员方法名(形参列表){
        成员方法体
    }
}
</code></pre><p>(例):</p>
<pre><code>class Person{
    viod show(){
        System.out.println(&quot;测试&quot;);
    }
}
</code></pre><p>(返回数据类型要与形参列表相同)  </p>
<p>成员方法的调用:<br>p.show();</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数组元素之间的操作</tag>
        <tag>号码的生成和去重</tag>
        <tag>面向对象的基本概念和三大特征</tag>
        <tag>了解了类和对象的概念</tag>
      </tags>
  </entry>
  <entry>
    <title>10.17JAVA学习进度</title>
    <url>/2019/10/17/2019-10-17-17ribao/</url>
    <content><![CDATA[<h1 id="10-17Java学习进度"><a href="#10-17Java学习进度" class="headerlink" title="10.17Java学习进度"></a>10.17Java学习进度</h1><h3 id="对java的简单了解和入门-简单的逻辑结构和循环结构-简单的数组操作"><a href="#对java的简单了解和入门-简单的逻辑结构和循环结构-简单的数组操作" class="headerlink" title="对java的简单了解和入门,简单的逻辑结构和循环结构,简单的数组操作"></a>对java的简单了解和入门,简单的逻辑结构和循环结构,简单的数组操作</h3><p>第一课:</p>
<p>了解了java的历史<br>看了基础的helloworld打印</p>
<p>第二课:</p>
<p>学习了变量<br>进制转换<br>还有各种数据类型</p>
<p>第三课:<br>学习了各种关系运算符,算数运算符<br>三目运算符<br>If else结构</p>
<p>第四课:<br>学习了循环结构,for循环嵌套<br>While循环</p>
<p>第五课:</p>
<p>学习了数组的操作,增删改查,<br>二维数组的操作</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>对java的简单了解和入门</tag>
        <tag>简单的逻辑结构和循环结构</tag>
        <tag>简单的数组操作</tag>
      </tags>
  </entry>
  <entry>
    <title>10.14</title>
    <url>/2019/10/14/2019-10-14-14jishu/</url>
    <content><![CDATA[<h1 id="看板娘代码"><a href="#看板娘代码" class="headerlink" title="看板娘代码:"></a>看板娘代码:</h1><pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;/&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt;
</code></pre>]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>看板娘</tag>
      </tags>
  </entry>
  <entry>
    <title>10.13</title>
    <url>/2019/10/13/2019-10-13-13jishu/</url>
    <content><![CDATA[<h1 id="今天发现了一个时间小人的特效-很有意思"><a href="#今天发现了一个时间小人的特效-很有意思" class="headerlink" title="今天发现了一个时间小人的特效 很有意思:"></a>今天发现了一个时间小人的特效 很有意思:</h1><pre><code>&lt;div&gt;
&lt;embed wmode=&quot;transparent&quot; src=&quot;http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.swf&quot; quality=&quot;high&quot; bgcolor=&quot;#ffffff&quot; width=&quot;160&quot; height=&quot;70&quot; name=&quot;honehoneclock&quot; align=&quot;middle&quot; allowscriptaccess=&quot;always&quot; type=&quot;application/x-shockwave-flash&quot; pluginspage=&quot;http://www.macromedia.com/go/getflashplayer&quot;&gt;
&lt;/div&gt;
</code></pre><p>或者:  </p>
<pre><code>&lt;script charset=&quot;Shift_JIS&quot; src=&quot;http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.js&quot;&gt;&lt;/script&gt;
</code></pre>]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>小人特效</tag>
      </tags>
  </entry>
  <entry>
    <title>9.28技术分享</title>
    <url>/2019/09/28/2019-09-28-28jishu/</url>
    <content><![CDATA[<h1 id="博客链接实现对QQ的跳转对话"><a href="#博客链接实现对QQ的跳转对话" class="headerlink" title="博客链接实现对QQ的跳转对话:"></a>博客链接实现对QQ的跳转对话:</h1><blockquote>
<p>每个博客加QQ的图标位置都不同,这里只讲解一下实现QQ的跳转对话。  </p>
</blockquote>
<p><strong>代码:</strong><br>实际实现这个效果的代码很简单,一行代码的事:  </p>
<pre><code>https://wpa.qq.com/msgrd?v=3&amp;uin=1848240419&amp;site=qq&amp;menu=yes
</code></pre><p>复制这行代码,<code>将其中的QQ号换成你自己的</code>,粘到你超链接的地方即可!  </p>
<p><strong>开启“QQ在线状态”服务:</strong>  </p>
<ol>
<li><p>首先要登陆腾讯推广的官方网站进行设置：</p>
<p> 官网地址是<a href="http://shang.qq.com/index.php" target="_blank" rel="noopener">http://shang.qq.com/index.php</a>  </p>
</li>
<li><p>然后进入推广工具:<br><img src="https://s2.ax1x.com/2019/11/22/MToQh9.png" alt="推广工具">  </p>
</li>
</ol>
<p>要是博客的话加个超链接没必要,像客服似的  </p>
<p>我们点击左侧的设置,然后向下翻翻到安全级别设置  </p>
<p><img src="https://s2.ax1x.com/2019/11/22/MT78eK.png" alt="安全级别设置">  </p>
<p>设置成完全公开!  第一次可能没什么反应 可以再刷新一下网页,然后弹出来立即免费开通,点就是了,<br>然后再回设置里面看看安全级别设置是否改成!</p>
<ol start="3">
<li>如果陌生人不能跳转,在自己QQ客户端的安全设置:  </li>
</ol>
<p>权限设置–&gt; 防骚扰 –&gt; 将临时会话都勾上<br><img src="https://s2.ax1x.com/2019/11/22/MTL8cd.png" alt="防骚扰"></p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>QQ跳转</tag>
      </tags>
  </entry>
  <entry>
    <title>9.27技术分享</title>
    <url>/2019/09/27/2019-09-27-27jishu/</url>
    <content><![CDATA[<h1 id="今天发现了git克隆下来的远程库特别大"><a href="#今天发现了git克隆下来的远程库特别大" class="headerlink" title="今天发现了git克隆下来的远程库特别大:"></a>今天发现了git克隆下来的远程库特别大:</h1><p>经过查询之后发现是每次推送之后都会留下记录缓存，这样很多没用的记录就会占用多余的空间，别人克隆的时候也会多耗费时间，今天我查到了一个清除无用记录的方法。</p>
<blockquote>
<p>首先进入你的本地库</p>
</blockquote>
<p>cd zhengyupengzz.github.io</p>
<blockquote>
<p>新建并切换到一个分支</p>
</blockquote>
<p>git checkout –orphan latest_branch</p>
<blockquote>
<p>选中全部文件</p>
</blockquote>
<p>git add -A</p>
<blockquote>
<p>提交</p>
</blockquote>
<p>git commit -am “Reinitialize”</p>
<blockquote>
<p>删除原分支</p>
</blockquote>
<p>git branch -D master</p>
<blockquote>
<p>将本分支改为原分支名</p>
</blockquote>
<p>git branch -m master</p>
<blockquote>
<p>推送到远程分支</p>
</blockquote>
<p>git push -f origin master</p>
<blockquote>
<p>现在你再去GitHub上去看提交分支的记录，会发现只有一次提交了</p>
</blockquote>
<blockquote>
<p>可以删除本地库重新将远程库克隆下来，这次就没有那些多余的提交记录了！</p>
</blockquote>
<p><a href="https://blog.csdn.net/yolohohohoho/article/details/90607229" target="_blank" rel="noopener">参考博客地址</a></p>
]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>git清理</tag>
      </tags>
  </entry>
  <entry>
    <title>9.27七十周年心得</title>
    <url>/2019/09/27/2019-09-27-27xinde/</url>
    <content><![CDATA[<h1 id="今天看了很多关于国家的视频-发现这七十年发展的是真不容易"><a href="#今天看了很多关于国家的视频-发现这七十年发展的是真不容易" class="headerlink" title="今天看了很多关于国家的视频,发现这七十年发展的是真不容易"></a>今天看了很多关于国家的视频,发现这七十年发展的是真不容易</h1><p>70年的风雨征程，带来了祖国繁荣强大，如同阳光照亮了我们的前程，指明了我们前进的方向，带领全国各族人民从贫穷走向富裕，从胜利走向辉煌。</p>
<p>　　中华人民共和国国旗旗面为红色象征革命。旗上的五颗五角星及其相互关系象征共产党领导下的革命人民大团结。星用黄色是为着在红地上显出光明，四颗小五角星各有一角正对着大星的中心点，表示围绕着一个中心而团结。每逢国庆，去天安门广场看升国旗是无数人心中的梦想。因此，利用国庆长假去北京游玩的人们，通常会赶早来到天安门广场看国旗班的军人升旗，以表达对祖国的无比热爱，看着五星红旗徐徐升起，心中的激动无以言表。每年10月1日是我国的国庆节，我国于1999年修订发布《全国年节及纪念日放假办法》，将国庆节与相邻的周六、日组合为7天的国庆长假，被称之为“国庆黄金周”，用放假的形式，让老百姓共同感受国庆的欢乐。</p>
<p>　　回首这70年，中华人民走得每一步都是步履蹒跚，每一步都付出了巨大牺牲。但是如今中国经过几十年来的艰苦建设，已取得了“乘长风，破万里浪”的迅猛发展:《辉煌中国》之《圆梦工程》透过港珠澳大桥、胡麻岭隧道、郑万铁路、复兴号、上海洋山港自动化码头、中国移动互联网等一个个超级工程，领略五年来一张张中国基础建设的大网，如何编织起人民走向幸福、美好的希望版图，托举起中华民族伟大复兴的中国梦。</p>
<p>面对飘扬的国旗亿万双眼睛注视五星红旗冉冉升起,亿万颗心灵伴随祖国母亲一起搏动。抬头仰望,发现鲜艳的国旗已在共和国的上空飘扬了半个世纪。在世纪之交的今天,共和国已走过了七十个春秋。七十年前，”洋油” ”洋面” 还充斥着中国的大江南北;七十年后，许多国产已遍及世界各地。</p>
<p>七十年前,我们的祖先还把汉代的耕梨插进二十世纪的农田;七十年后,现代化机械已开进中国的农家。<br>七十年前,港澳游子还站在金门望厦门;五十年后,归国侨胞已站在厦门望金门。-样的遥望,却是两样的情形。<br>七十年里，萧瑟秋风今又是，换了人间。</p>
<p>依旧淳朴中隐着聪慧,荒中透着俊季，可再也听不见那血泪凝结的叹息,更也找不到贫贱不堪的足印，再也寻不见你昔日枯瘦蹒跚的身影,麦穗和齿轮构筑的太阳,伸出金色的臂膀擎着一片晴空,逶道而来,斩断阴霾的剑光在普照众生的沧桑。</p>
<p>你傲然屹立于世界的东方,不管身边的风云如何的变幻,始终坚定地沿真理的方向勇往直前。你般迎着八面春风,在辐射的节奏里,眺望着更加灿烂的前程。</p>
<p>我灵魂的纤绳永系向你风帆的桅杆;我手中的彩笔,永远写你壮重的风姿;</p>
<p>面对飘扬国旗，血液在奔涌，思绪在沸腾,理想的根须在土里扎得更深。面对飘扬的国旗,我们已把自己溶入母亲炙热的胸襟。</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>9.26日报</title>
    <url>/2019/09/26/2019-09-26-26ribao/</url>
    <content><![CDATA[<h1 id="今天也是收获颇丰的一天"><a href="#今天也是收获颇丰的一天" class="headerlink" title="今天也是收获颇丰的一天:"></a>今天也是收获颇丰的一天:</h1><p>因为要学四个数据库,再ubuntu安装比较麻烦,所以我刷回了Windows系统.</p>
<p>但是安装了虚拟机的deep系统也是基于linux的.</p>
<p>今天已经将四个数据库安装完成,环境也配置好了.</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>9.19阶段感悟</title>
    <url>/2019/09/19/2019-09-19-19ganwu/</url>
    <content><![CDATA[<h1 id="从加入兄弟会到现在的感悟与总结"><a href="#从加入兄弟会到现在的感悟与总结" class="headerlink" title="从加入兄弟会到现在的感悟与总结"></a>从加入兄弟会到现在的感悟与总结</h1><p>从听说兄弟会的学习模式开始,我就一直盼望着加入兄弟会,然而我也确实很幸运地通过面试加入进了兄弟会.</p>
<p>刚加入时候是迷茫的,不知道该做些什么,遇见问题无从下手,仅仅是安装ubuntu系统就花费了一整天的时间.</p>
<p>当然兄弟会的教官也教了我们自学效率比较高的方式,查阅资料和向已经学会的同学交流请教,我觉得这很符合现在公司里面的学习方式,进到公司里面不会被特意地教学只能自己根据资料和向前辈请教来快速提升自己.</p>
<p>在掌握了这种自学方式之后,我觉得比平时上课老师教课的学习效率还要高,不只是学习进度可以随自己调,更重要的是<code>不困!!!</code>,说实话到兄弟会一来我还没有过上课时候困得神志模糊那种感觉,有的也仅仅是眼睛的疲劳.</p>
<p>这种精神的清醒我觉得得益于明确的学习目标,和自己自由的时间分配,在每一天都没有打盹的情况下,我觉得学习效率高多了.</p>
<p>再就是兄弟会的成员构成,有php的,java的,python的,有原来学习各种学科的同学,所以在我们的目标是最少学习两门语言的情况下,这种成员构成就有很好的学习氛围.</p>
<p>当在一门学科遇到了问题的时候,可以很容易地请教到其他学过这门科目的同学,在那些官方的知识被人性化的整理之后,比原来官方文档更容易理解了.</p>
<p>还有听书环节,我觉得不光是要听那些名人名书的理念,更要注重的是看看这些名人是怎么想到从更高的角度去看待某一件事,用我们一位教官说的话就是,”格局”,当一个人格局大了,他的人生观价值观自然就不同与普通人,目标不同前进的动力也会不同.</p>
<blockquote>
<p>最后总结一下:</p>
</blockquote>
<p>加入了兄弟会,我的学习方式彻底改变了,效率变得更高了,人生格局也发现了改变,目标也更加远大.在兄弟会了不单单学习了知识,更让精神又成长了一步.</p>
<p>最后希望兄弟会的兄弟们都能顺利地完成兄弟会的任务,顺利地走上自己预想的那条人生轨迹.</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>9.18连接远程服务器</title>
    <url>/2019/09/18/2019-09-18-18jishu/</url>
    <content><![CDATA[<h1 id="连接远程服务器-上传文件方法"><a href="#连接远程服务器-上传文件方法" class="headerlink" title="连接远程服务器,上传文件方法"></a>连接远程服务器,上传文件方法</h1><blockquote>
<p>安装rdesktop</p>
</blockquote>
<p>  sudo apt-get install rdesktop</p>
<blockquote>
<p>连接服务器</p>
</blockquote>
<p>  rdesktop IP -u Administrator -r disk:app=/home/USER/桌面/node</p>
<p>  连接远程服务器，并把位于/home/USER/桌面/node里的内容虚拟出一个映射盘在服务器上。</p>
<p>  -f 全屏</p>
<p>  -u xxxxxx 登录用户，可选</p>
<p>  -p xxxxxx 登录密码，可选</p>
<p>  -r clipboard:PRIMARYCLIPBOARD 重要，剪贴板可以与远程桌面交互</p>
<p>  -a 16 颜色，可选，不过最高就是16位</p>
<p>  -r disk:wj=/home/magicgod映射虚拟盘，可选，会在远程机器的网上邻居里虚拟出一个映射盘，功能很强，甚至可以是软盘或光盘</p>
<blockquote>
<p>安装nodejs</p>
</blockquote>
<p>1.下载地址：<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/download/</a> 选择相应的版本下载,这里下载的是windows的zip文件。</p>
<p>2.解压缩</p>
<p>  将下载的文件解压到要安装的位置，并新建两个目录：</p>
<p>  node-global :npm全局安装位置</p>
<p>  node-cache：npm 缓存路径</p>
<p>3.配置</p>
<p>  将node.exe 所在的目录添加到path环境变量，这样我们在使用命令行时就可以在任意路径使用node命令</p>
<p>那么node-global:npm全局安装位置，node-cache：npm缓存路径 又是怎么与npm发生关系呢？</p>
<p> 通过如下命令进行配置：</p>
<p>npm config set prefix “C:\Program Files\node\node-global”</p>
<p>npm config set cache “C:\Program Files\node\node-cache”</p>
<p>4.在命令行中输入如下命令测试</p>
<p>  node -v</p>
<p>  npm -v</p>
<blockquote>
<p>访问域名访问到项目</p>
</blockquote>
<p>我使用的是 phpstudy 使用很方便</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>远程连接服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>9.16技术分享文档</title>
    <url>/2019/09/16/2019-09-16-16jishu/</url>
    <content><![CDATA[<h1 id="jquery-常用事件整理"><a href="#jquery-常用事件整理" class="headerlink" title="jquery 常用事件整理"></a>jquery 常用事件整理</h1><blockquote>
<p>鼠标点击事件</p>
</blockquote>
<p>click</p>
<blockquote>
<p>鼠标双击事件</p>
</blockquote>
<p>dblclick</p>
<blockquote>
<p>鼠标指针进入事件</p>
</blockquote>
<p>mouseenter</p>
<blockquote>
<p>鼠标指针离开事件</p>
</blockquote>
<p>mouseleave</p>
<blockquote>
<p>鼠标指针悬停</p>
</blockquote>
<p>hover</p>
<blockquote>
<p>字段内按键次数</p>
</blockquote>
<pre><code>$(&quot;input&quot;).keypress(function(){
    $(&quot;span&quot;).text(i+=1);   
});
</code></pre><blockquote>
<p>键盘被按下时改变颜色</p>
</blockquote>
<pre><code>$(&quot;input&quot;).keydown(function(){
    $(&quot;input&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;);
});
</code></pre><blockquote>
<p>键盘松开时改变颜色</p>
</blockquote>
<pre><code>    $(&quot;input&quot;).keyup(function(){
        $(&quot;input&quot;).css(&quot;background-color&quot;,&quot;pink&quot;);
    });
</code></pre><blockquote>
<p>提交表单时</p>
</blockquote>
<p>submit</p>
<blockquote>
<p>改变时</p>
</blockquote>
<p>change</p>
<blockquote>
<p>获得焦点时</p>
</blockquote>
<p>focus</p>
<blockquote>
<p>失去焦点时</p>
</blockquote>
<p>blur</p>
<blockquote>
<p>全部加载时</p>
</blockquote>
<p>load</p>
<blockquote>
<p>调整大小</p>
</blockquote>
<p>resize</p>
<blockquote>
<p>元素滚动</p>
</blockquote>
<p>scroll</p>
<blockquote>
<p>离开时</p>
</blockquote>
<p>unload</p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>9.10日报</title>
    <url>/2019/09/10/2019-09-10-10ribao/</url>
    <content><![CDATA[<h1 id="今天也是收获颇丰的一天-在同学那学到了很多"><a href="#今天也是收获颇丰的一天-在同学那学到了很多" class="headerlink" title="今天也是收获颇丰的一天,在同学那学到了很多:"></a>今天也是收获颇丰的一天,在同学那学到了很多:</h1><p>今天上午开始去背的倒计时,但是背了挺长时间背得效率也不是那么高.</p>
<p>然后看了同学自己按照自己的思路写的代码,感觉思路清晰多了.</p>
<p>今天学到了,看代码不要按照固有思路去看  别人的代码也未必是最好的代码,自己捋请思路写一遍也许效果更好.</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>9.09日报</title>
    <url>/2019/09/09/2019-09-09-09ribao/</url>
    <content><![CDATA[<h1 id="今天考考了两个js特效的实现页面-总结一下"><a href="#今天考考了两个js特效的实现页面-总结一下" class="headerlink" title="今天考考了两个js特效的实现页面,总结一下:"></a>今天考考了两个js特效的实现页面,总结一下:</h1><p>在做选项卡页面的时候,忘记了引用jqery文件,导致一直运行失败 还好在最后的时候想了起来.</p>
<p>还有样式要记得加上浮动效果比较好,</p>
<p>这两个页面我样式做的都不是很好看,css要复习复习了.</p>
<p>下午和晚自习又看了几个页面,明天争取顺利考过.</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>9.07技术分享文档</title>
    <url>/2019/09/07/2019-09-07-07jishu/</url>
    <content><![CDATA[<h1 id="今天分享几个经过细心挑选了的较高质量的壁纸网站"><a href="#今天分享几个经过细心挑选了的较高质量的壁纸网站" class="headerlink" title="今天分享几个经过细心挑选了的较高质量的壁纸网站:"></a>今天分享几个经过细心挑选了的较高质量的壁纸网站:</h1><p><a href="http://www.jj20.com/" target="_blank">娟娟壁纸</a></p>
<p><a href="http://pic.netbian.com/" target="_blank">彼岸图网</a></p>
<p><a href="https://bz.zzzmh.cn/" target="_blank">极简壁纸</a></p>
<p><a href="https://alpha.wallhaven.cc/" target="_blank">wallhaven</a></p>
<p><a href="https://pixabay.com/" target="_blank">pixabay</a></p>
<p><a href="https://wallpaperscraft.com/" target="_blank">wallpaperscraft</a></p>
<p><a href="http://simpledesktops.com/" target="_blank">Simple Desktops(极简风)</a></p>
<p><a href="https://www.gamewallpapers.com/" target="_blank">GameWallpapers(游戏专题壁纸)</a></p>
<p><a href="https://wallpapercave.com/" target="_blank">Wallpaper Cave</a></p>
<p><a href="https://www.moviemania.io/" target="_blank">Moviemania(电影壁纸)</a></p>
<p><a href="https://unsplash.com/" target="_blank">unsplash(摄影壁纸)</a></p>
<p><a href="https://www.pexels.com/" target="_blank">pexels(高质量图片社区)</a><br><a href="https://www.pexels.com/videos/" target="_blank">视频专区</a></p>
<p><a href="https://gratisography.com/" target="_blank">gratisography(艺术,脑洞图片)</a></p>
]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>壁纸</tag>
      </tags>
  </entry>
  <entry>
    <title>9.06git命令详细整理之二</title>
    <url>/2019/09/06/2019-09-06-06jishu/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/afei__/article/details/51476529" target="_blank" rel="noopener">git命令整理博客1</a></p>
<p><strong>还有大家一起整理了挺全的命令整理：</strong></p>
<blockquote>
<p>查看远程库配置信息</p>
</blockquote>
<p>git remote show 远程库名</p>
<blockquote>
<p>给远程地址添加别名</p>
</blockquote>
<p>git remote add 别名 远程库地址</p>
<blockquote>
<p>修改远程库名字</p>
</blockquote>
<p>git remote rename 老名字 新名字</p>
<blockquote>
<p>删除远程库</p>
</blockquote>
<p>git remote rm 库名</p>
<blockquote>
<p>分支取下来自动合并</p>
</blockquote>
<p>git pull</p>
<blockquote>
<p>加注标签  -m后跟说明</p>
</blockquote>
<p>git tag -a 标签名 -m”说明”</p>
<blockquote>
<p>给原来的标签加说明</p>
</blockquote>
<p>git tag -s v1.5 -m”说明”</p>
<blockquote>
<p>轻量级标签</p>
</blockquote>
<p>git tag 标签名 -lw</p>
<blockquote>
<p>发送标签到远程服务器</p>
</blockquote>
<p>git push origin 标签名</p>
<blockquote>
<p>创建分支</p>
</blockquote>
<p>git branch 分支名</p>
<blockquote>
<p>切换分支</p>
</blockquote>
<p>git chechout 分知名</p>
<blockquote>
<p>改变head指针指向位置</p>
</blockquote>
<p>git reset –hard 回退历史的索引值</p>
<blockquote>
<p>显示当前HEAD指针在哪</p>
</blockquote>
<p>git reset –hard</p>
<blockquote>
<p>取消缓存</p>
</blockquote>
<p>git reset HEAD 文件名</p>
<blockquote>
<p>合并分支</p>
</blockquote>
<p>git merge 分支</p>
<blockquote>
<p>删除分支</p>
</blockquote>
<p>git branch -d 分支名</p>
<blockquote>
<p>查看所有分支信息,列出所有本地分支</p>
</blockquote>
<p>git branch</p>
<blockquote>
<p>查看各个分支最后一次提交的对象</p>
</blockquote>
<p>git branch -v</p>
<blockquote>
<p>查看哪些分支已被并入当期分支</p>
</blockquote>
<p>git branch –merge</p>
<blockquote>
<p>查看尚未合并的工作</p>
</blockquote>
<p>git branch –no-merged</p>
<blockquote>
<p>推送分支到远程仓库</p>
</blockquote>
<p>git push 远程库名 分支名</p>
<blockquote>
<p>跟踪远程分支</p>
</blockquote>
<p>git checkout –track orgin/master</p>
<blockquote>
<p>分享标签</p>
</blockquote>
<p>git push origin 标签名</p>
<blockquote>
<p>分享所有标签</p>
</blockquote>
<p>git push origin -tag</p>
<blockquote>
<p>推送本地分支</p>
</blockquote>
<p>git push origin 分支名</p>
<blockquote>
<p>删除远程分支</p>
</blockquote>
<p>git rm origin:分支名</p>
<blockquote>
<p>新建一个目录,将其初始化为git代码库</p>
</blockquote>
<p>git init</p>
<blockquote>
<p>编辑git配置文件</p>
</blockquote>
<p>git config -e [–global]</p>
<blockquote>
<p>查看git的配置信息</p>
</blockquote>
<p>git config –list</p>
<blockquote>
<p>设置提交代码时的用户信息</p>
</blockquote>
<p>git config [–global] user.name “[name]”</p>
<blockquote>
<p>设置提交代码时的邮箱信息</p>
</blockquote>
<p>git config [–global] user.email “[email address]”</p>
<blockquote>
<p>添加指定文件到暂存区</p>
</blockquote>
<p>git add [file1] [file2]</p>
<blockquote>
<p>添加当前目录的所有文件到暂存区</p>
</blockquote>
<p>git add .</p>
<blockquote>
<p>对于同一个文件的多处变化,可以实现分次提交</p>
</blockquote>
<p>git add -p</p>
<blockquote>
<p>提交暂存区到仓库区</p>
</blockquote>
<p>git commit -m””</p>
<blockquote>
<p>提交暂存区的制定文件到仓库区</p>
</blockquote>
<p>git commit [file1][file2]  -m””</p>
<blockquote>
<p>提交工作区自上次commit之后的变化,直接到仓库区</p>
</blockquote>
<p>git commit -a </p>
<blockquote>
<p>提交时显示所有diff信息</p>
</blockquote>
<p>git commit -v</p>
<blockquote>
<p>使用一次新的commit,替代上次提交,</p>
</blockquote>
<p>git commit –amend -m””</p>
<blockquote>
<p>重做上一次comit,并包括指定文件的新变化</p>
</blockquote>
<p>git commit –aend [file1][file2]</p>
<blockquote>
<p>列出所有远程分支</p>
</blockquote>
<p>git branch -r</p>
<blockquote>
<p>列出所有本地分支和远程分支</p>
</blockquote>
<p>git branch -a</p>
<blockquote>
<p>新建一个分支</p>
</blockquote>
<p>git branch 分支名</p>
<blockquote>
<p>新建一个分支并切到该分支</p>
</blockquote>
<p>git checkout -b 分支名</p>
<blockquote>
<p>新建一个分支,指向指定commit的哈希值</p>
</blockquote>
<p>git branch [branch][commit]</p>
<blockquote>
<p>新建一个分支,与指定的远程分子建立追踪关系</p>
</blockquote>
<p>git branch –track [branch] [remote-branch]</p>
<blockquote>
<p>切换到指定分支</p>
</blockquote>
<p>git checkout [branch-name]</p>
<blockquote>
<p>切换到上一个分支</p>
</blockquote>
<p>git checkout -</p>
<blockquote>
<p>新建一个分支,指向某个tag</p>
</blockquote>
<p>git checkout -b [branch][tag]</p>
<blockquote>
<p>建立追踪关系,在现有分支与指定的远程分支之间</p>
</blockquote>
<p>git branch –set-upstream [branch] [remote-branch]</p>
<blockquote>
<p>选择一个commit,合并进当前分支</p>
</blockquote>
<p>git cherry-pick[commit]</p>
<blockquote>
<p>删除分支</p>
</blockquote>
<p>git branch -d [branch-name]</p>
<blockquote>
<p>删除远程分支</p>
</blockquote>
<p>git push origin –delete [branch-name]</p>
<blockquote>
<p>删除远程分支</p>
</blockquote>
<p>git branch -dr [remote/branch]</p>
<blockquote>
<p>列出所有tag</p>
</blockquote>
<p>git tag</p>
<blockquote>
<p>新建一个tag在当前commit</p>
</blockquote>
<p>git tag [tag]</p>
<blockquote>
<p>新建一个tag在指定commit</p>
</blockquote>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>9.05git命令详细整理</title>
    <url>/2019/09/05/2019-09-05-05jishu/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/afei__/article/details/51476529" target="_blank" rel="noopener">git命令整理博客1</a></p>
<p><strong>还有大家一起整理了挺全的命令整理：</strong></p>
<blockquote>
<p>初始化git库，在当前目录新建一个git代码库</p>
</blockquote>
<p>git init</p>
<blockquote>
<p>git库，下载一个项目和它的整个代码历史</p>
</blockquote>
<p>git clone</p>
<blockquote>
<p>添加追踪文件，如果不写文件名就是该目录下的所有文件添加跟踪,添加指定目录到暂存区，包括子目录</p>
</blockquote>
<p>git add 文件名</p>
<blockquote>
<p>提交到暂存区</p>
</blockquote>
<p>git commit -m””</p>
<blockquote>
<p>检查当前文件状态</p>
</blockquote>
<p>git  status</p>
<blockquote>
<p>检查工作区和暂存区的差别</p>
</blockquote>
<p>git diff</p>
<blockquote>
<p>查看上次提交和未暂存的差别</p>
</blockquote>
<p>git diff –cached [file]</p>
<blockquote>
<p>分支之间的区别</p>
</blockquote>
<p>git diff    原分支  目标分支</p>
<blockquote>
<p>删除文件</p>
</blockquote>
<p>git rm  要删除的文件</p>
<blockquote>
<p>将文件在暂存区删除，也就是取消跟踪，停止追踪指定文件，但该文件会保留在工作区</p>
</blockquote>
<p>git rm –cached  文件</p>
<blockquote>
<p>移动文件/修改文件名并将这个改名放入暂存区</p>
</blockquote>
<p>git mv</p>
<blockquote>
<p>检查提交记录</p>
</blockquote>
<p>git log</p>
<blockquote>
<p>记录显示在一行</p>
</blockquote>
<p>git log –oneine</p>
<blockquote>
<p>显示之前的修改记录</p>
</blockquote>
<p>git reflog</p>
<blockquote>
<p>修改最后提交，也可以说是撤销最后一次提交</p>
</blockquote>
<p>git commit –amend</p>
<blockquote>
<p>抛弃修改命令，回到之前版本，回复暂存区的制定文件到工作区</p>
</blockquote>
<p>git checkout 文件名</p>
<blockquote>
<p>把暂存区的修改撤销掉</p>
</blockquote>
<p>git reset HEAD file</p>
<blockquote>
<p>查看当时配置的有那些远程库，加上-v显示对应的克隆地址</p>
</blockquote>
<p>git remote</p>
<blockquote>
<p>从远程仓库抓取数据</p>
</blockquote>
<p>git fetch origin</p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>9.4日报</title>
    <url>/2019/09/04/2019-09-04-04ribao/</url>
    <content><![CDATA[<blockquote>
<p><code>今天下午考了一个node聊天室，一个js的轮播图。</code>  </p>
</blockquote>
<h1 id="考试总结："><a href="#考试总结：" class="headerlink" title="考试总结："></a>考试总结：</h1><pre><code>今天的考试只有一个半小时就要做出一个聊天室和一个轮播图，正常来说一个半小时做两个基本是完不成的，所以大家都被罚了一下。

然后在进行考试总结的时候我们发现了老师是考验我们团队协作能力而不是自己写出来。
</code></pre><p><strong>心得：</strong></p>
<p>团队协作效率比个人高得多，平时要多与大家交流技术性问题，做项目时候更要多交流一下功能怎么实现的。</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>9.03lamp环境搭建</title>
    <url>/2019/09/03/2019-09-03-03jishu/</url>
    <content><![CDATA[<h1 id="lamp环境的搭建方法与我遇到的问题"><a href="#lamp环境的搭建方法与我遇到的问题" class="headerlink" title="lamp环境的搭建方法与我遇到的问题"></a>lamp环境的搭建方法与我遇到的问题</h1><p>首先我在网上找到了一个很全的安装教程：</p>
<p><a href="https://www.cnblogs.com/opsprobe/p/9126411.html" target="_blank" rel="noopener">lamp安装教程</a></p>
<p>还有一个mysql安装教程：</p>
<p><a href="https://www.cnblogs.com/opsprobe/p/9126864.html" target="_blank" rel="noopener">mysql安装教程</a></p>
<h3 id="在配置lamp的时候也遇到了几个问题，我整理了一下："><a href="#在配置lamp的时候也遇到了几个问题，我整理了一下：" class="headerlink" title="在配置lamp的时候也遇到了几个问题，我整理了一下："></a>在配置lamp的时候也遇到了几个问题，我整理了一下：</h3><p><em>在配置了phpMyAdmin结束的时候我遇到了这种问题:</em></p>
<p><strong>phpMyAdmin错误：缺少mbstring扩展名 请检查您的PHP配置</strong></p>
<blockquote>
<p>处理方法：运行以下两段代码即可</p>
</blockquote>
<p>sudo apt-get install phpmyadmin php-mbstring php-gettext</p>
<p>systemctl restart apache2</p>
<h4 id="我还遇到了mysql数据库的root密码忘记了，比较尴尬…："><a href="#我还遇到了mysql数据库的root密码忘记了，比较尴尬…：" class="headerlink" title="我还遇到了mysql数据库的root密码忘记了，比较尴尬…："></a>我还遇到了mysql数据库的root密码忘记了，比较尴尬…：</h4><blockquote>
<p>处理方法：在文件中修改一下root密码</p>
</blockquote>
<p>1.在终端输入</p>
<p>sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</p>
<p>2.在文件内搜索skip-external-locking,在下面添加一行:</p>
<p>skip-grant-tables</p>
<p>3.重启mysql</p>
<p>sudo service mysql restart</p>
<p>4.在终端输入命令mysql,进入mysql</p>
<p>5.使用命令use mysql;切换到mysql数据库</p>
<p>6.修改root密码</p>
<p>UPDATE mysql.user SET authentication_string=password(‘你想设置的密码’) WHERE User=’root’ AND Host =’localhost’;</p>
<p>7.修改字段plugin(Plugin字段标识可以用于验证用户身份的插件，如果字段为空，服务器使用内建授权验证机制验证用户身份)</p>
<p>UPDATE user SET plugin=”mysql_native_password”;</p>
<p>8.刷新权限,输入命令</p>
<p>flush privileges;</p>
<p>9.退出mysql</p>
<p>quit;</p>
<p>10.回到设置的文件内(/etc/mysql/mysql.conf.d/mysqld.cnf)内把添加的命令注释掉</p>
<p>sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</p>
<p>将skip-grant-tables删除。</p>
<p><a href="https://www.cnblogs.com/wuzdandz/p/10790458.html" target="_blank" rel="noopener">此方法参考博客</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>lamp安装</tag>
      </tags>
  </entry>
  <entry>
    <title>9.2日报</title>
    <url>/2019/09/02/2019-09-02-02ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p><code>今天开始回去翻看之前的git,vim,linux,js笔记，今天看完了git,vim。明天继续看linux命令与js语法。我整理了一下不太熟的命令在这里。</code>  </p>
</blockquote>
<h1 id="不太熟悉的命令："><a href="#不太熟悉的命令：" class="headerlink" title="不太熟悉的命令："></a>不太熟悉的命令：</h1><p>git mergr -m”合并”&lt;分支名&gt;          将指定分支合并到当前分支</p>
<p>git pull <remote> <remote branch>:<branch>          同步指定分支的合并，有追踪关系的</branch></remote></remote></p>
<p>git pull origin dev:master          将远程dev与本地master合并</p>
<p>git pull origin dev         将远程dev合并到当前分支</p>
<p>git stash           贮藏当前工作区的修改，没有commit的</p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>8.30日报</title>
    <url>/2019/08/30/2019-08-30-30ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p><code>今天开始学node的socket模块，在网上查了各种资源勉强做出来一个简易的多人聊天室，也遇到了一些问题。</code>  </p>
</blockquote>
<h1 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><p>在关闭端口时总会出现关闭不完全的情况，我在网上寻找了这种方法：</p>
<p>lsof -i :端口号            查询该端口占用情况</p>
<p>kill -9  查询出对应的PID                  关闭端口进程</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>端口占用</tag>
      </tags>
  </entry>
  <entry>
    <title>8.30技术文档</title>
    <url>/2019/08/30/2019-08-30-30jishu/</url>
    <content><![CDATA[<h1 id="js的常用语法（整理版）"><a href="#js的常用语法（整理版）" class="headerlink" title="js的常用语法（整理版）"></a>js的常用语法（整理版）</h1><blockquote>
<p>今天在看node的空闲时间又重新整理了之前的js语法：</p>
</blockquote>
<pre><code class="pre">        连接外部js文件：
        &lt;script src=&quot;js文件&quot;&gt;&lt;/script&gt;

        alert()     弹出警告框

        document.write()        将内容写到HTML文档中

        innerHTML=&quot;写入到HTML元素&quot;

        console.log()       写入到浏览器的控制台

        document.write(&quot;&lt;h1&gt;&lt;这是一个标题/h1&gt;&quot;)
        直接写入到html输出流

改变html内容：
&lt;p id=&quot;demo&quot;&gt;哈哈哈&lt;/p&gt;
&lt;script&gt;
        function myFunction(){  //定义一个类
            x=document.getElementById(&quot;demo&quot;);  //找到元素，获取
            //获取类元素：gitElementsByClassName
            //获取标签元素：gitElementsByTagName
            x.innerHTML=&quot;Hello&quot;;    //改变内容
            x.style.color=&quot;#ff0000&quot;;    //改变样式
        }
&lt;/script&gt;
&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点这里&lt;/button&gt;


&lt;button onclick=&quot;getElementById(&#39;demo&#39;).innerHTML=Date()&quot;&gt;时间&lt;/button&gt;
        //点击后修改demo处文字为Date

&lt;button onclick=&quot;this.innerHTML=Date()&quot;&gt;时间&lt;/button&gt;
        //点击后修改按钮上的内容为Date
</code></pre>
<p><strong>常见的HTML事件：</strong></p>
<pre><code>onchange        HTML元素改变

onclick         用户点击HTML元素

onmouseover         用户在HTML元素上移动鼠标

onmouseout          用户从一个HTML元素上移开鼠标

onkeydown           用户按下键盘按键

onload          浏览器已完成页面的加载

字符串.lenght           字符串长度
</code></pre><p><strong>setInterval()</strong>       间隔指定毫秒书不停地执行指定代码<br><strong>setTimeout()</strong>        在指定毫秒数后执行指定代码</p>
<p>myVar=setTimeout(function(){alert(“Hello”)},3000);<br>            //等待3秒后弹出Hello</p>
<p>clearTimeout(myVar);        停止执行</p>
<p>clearInterval(myVar);        停止执行</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>8.29日报</title>
    <url>/2019/08/29/2019-08-29-29ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p><code>今天完成了计时器的考核，关于计时器与属性获取基本掌握90%，轮播图效果80%，后面开始看node,但是刚开始看进度10%</code>  </p>
</blockquote>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>今天在做计时器效果与轮播图效果都是自己在网上寻找的教程与例子，当自己努力做出来的成果成果的时候是很开心的，很有动力。</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>8.29技术文档</title>
    <url>/2019/08/29/2019-08-29-29jishu/</url>
    <content><![CDATA[<h1 id="简易的图片轮播"><a href="#简易的图片轮播" class="headerlink" title="简易的图片轮播"></a>简易的图片轮播</h1><p>今天主要学习了轮播图的原理和简易制作，以下是我轮播图的代码：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;轮播图&lt;/title&gt;
    &lt;style type=&quot;text/css&quot;&gt;

        p{
            text-align: center;
            font-size: 25px;
            color: rgb(95, 152, 160);
            font-family: fantasy;

        }

        .imgBox{
            position: absolute;
            left: 25%;
            border-top: 2px solid rgb(95, 152, 160);
            width: 50%;
            height: 500px;
        }

        .imgBox img{
           width: 50%;
            margin: 0 auto;
            padding-top: 30px;

        }

        .img1{
            display: block;
        }

        .img2{
            display: none;
        }

        .img3{
            display: none;
        }
        .btn-ctrl{
            position: relative;
            top: 20%;
            cursor: pointer;
            font-size: 36px;
            color: red;
            font-weight: 500;
        }
        #btn-prev{
            left: 0px;
            float: left;
        }
        #btn-next{
            right: 0px;
            float: right;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;图片轮播&lt;/p&gt;

&lt;div class=&quot;imgBox&quot;&gt;
        &lt;div id=&quot;btn-prev&quot; class=&quot;btn-ctrl&quot; onclick=&quot;clock(0)&quot;&gt;&amp;lt;&lt;/div&gt;
        &lt;div id=&quot;btn-next&quot; class=&quot;btn-ctrl&quot; onclick=&quot;clock(1)&quot;&gt;&amp;gt;&lt;/div&gt;
    &lt;img class=&quot;img-slide img1&quot;  src=&quot;images/1.jpg&quot;&gt;
    &lt;img class=&quot;img-slide img2&quot;  src=&quot;images/2.jpg&quot;&gt;
    &lt;img class=&quot;img-slide img3&quot;  src=&quot;images/3.jpg&quot;&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var index=0;
    function changeImg() {
        index++;
        var a=document.getElementsByClassName(&quot;img-slide&quot;);
        if(index&gt;=a.length) index=0;
        for(var i=0;i&lt;a.length;i++){
            a[i].style.display=&#39;none&#39;;
        }
        a[index].style.display=&#39;block&#39;;
    }
    function clock(cc){
        switch(cc){
            case 0:
                index=index-2;
                if(index&lt;-1) index=1;
                break;
            case 1:
               index;
                break;
        }
    }
      setInterval(changeImg,2000);
&lt;/script&gt;
&lt;/html&gt;
</code></pre><p>原理：用js获取图片的类组成数组，利用循环将所有图片都先隐藏，再利用图片数组下标逐个显示。</p>
]]></content>
      <categories>
        <category>特效</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>8.28日报</title>
    <url>/2019/08/28/2019-08-28-28ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p><code>今天下午学习了JS基础，学习了 定时器和选择对象并修改内容，还看了一些基础语法。</code>  </p>
</blockquote>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>今天学习的新任务是JS ，原来学过一些php也有一些基础学得还不算慢，总体来说今天的学习效率还可以。</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>8.28技术文档</title>
    <url>/2019/08/28/2019-08-28-28jishu/</url>
    <content><![CDATA[<h1 id="JS常用知识"><a href="#JS常用知识" class="headerlink" title="JS常用知识"></a>JS常用知识</h1><blockquote>
<p>直接写入html输出流：</p>
</blockquote>
<p><code>document.write(&quot;&lt;h1&gt;这是一个标题&lt;/h1&gt;&quot;);</code></p>
<blockquote>
<p>改变html内容：</p>
</blockquote>
<pre><code>&lt;p id=&quot;demo&quot;&gt;111&lt;/p&gt;
&lt;script&gt;
    function myFunction()  //定义一个类
    {
        var x=document.getElementById(&quot;demo&quot;); //找到元素
        x.innerHTML = &quot;hello&quot;; //改变内容
        x.style.color = &quot;#ff0000&quot;;
    }
&lt;/script&gt;
&lt;button onclick=&quot;myFunction()&quot;&gt;点我&lt;/button&gt;

</code></pre><blockquote>
<p>显示数据  </p>
</blockquote>
<pre><code>    alert()   弹出警告框  

    document.write() 将内容写到HTML文档中

    innerHTML= &quot;写入到HTML元素&quot;

    console.log() 写入到浏览器的控制台
</code></pre><p>let 声明的变量是局部变量<br>const 用来声明常量</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>8.27技术文档</title>
    <url>/2019/08/27/2019-08-27-27jishu/</url>
    <content><![CDATA[<h1 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h1><blockquote>
<p>TCP/IP协议简介:  </p>
</blockquote>
<p>TCP/IP传输协议，即传输控制/网络协议，也叫作网络通讯协议。它是在网络的使用中的最基本的通信协议。TCP/IP传输协议对互联网中各部分进行通信的标准和方法进行了规定。并且，TCP/IP传输协议是保证网络数据信息及时、完整传输的两个重要的协议。TCP/IP传输协议是严格来说是一个四层的体系结构，应用层、传输层、网络层和数据链路层都包含其中。</p>
<blockquote>
<p>TCP/IP协议的组成:  </p>
</blockquote>
<p>TCP/IP协议在一定程度上参考了OSI的体系结构。OSI模型共有七层，从下到上分别是物理层、数据链路层、网络层、运输层、会话层、表示层和应用层。</p>
]]></content>
      <categories>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>8.27日报</title>
    <url>/2019/08/27/2019-08-27-27ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p><code>linux命令已通过考核，但是还有一些没有太熟练，学习进度95%，下午绘制了聊天室的流程图和思维导图基本绘制完成进度90%。</code>  </p>
</blockquote>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><blockquote>
<p>今天的不足与感悟</p>
</blockquote>
<h3 id="今天的不足"><a href="#今天的不足" class="headerlink" title="今天的不足"></a>今天的不足</h3><p>已经给了半天时间看文档，考试linux命令时候还勾抹几次，命令定义不明确，意思相近的有很多没有明确区分。</p>
<h3 id="今天的感悟"><a href="#今天的感悟" class="headerlink" title="今天的感悟"></a>今天的感悟</h3><p>背东西时候要专注，有效率不能左看一眼又看一眼，这个看会了再看下一个</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>8.26技术文档</title>
    <url>/2019/08/26/2019-08-26-26jishu/</url>
    <content><![CDATA[<h1 id="linux常用命令整合版"><a href="#linux常用命令整合版" class="headerlink" title="linux常用命令整合版"></a>linux常用命令整合版</h1><p><strong>关机 (系统的关机、重启以及登出 ):</strong><br>shutdown -h now 关闭系统<br>init 0 关闭系统<br>telinit 0 关闭系统<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启<br>reboot 重启<br>logout 注销   </p>
<p><strong>文件和目录:</strong><br>cd /home 进入 ‘/ home’ 目录’<br>cd .. 返回上一级目录<br>cd ../.. 返回上两级目录<br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br>cd - 返回上次所在的目录<br>pwd 显示工作路径<br>ls 查看目录中的文件<br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br>ls -a 显示隐藏文件<br>ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构<br>lstree 显示文件和目录由根目录开始的树形结构<br>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>mkdir dir1 dir2 同时创建两个目录<br>mkdir -p /tmp/dir1/dir2 创建一个目录树<br>rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>mv dir1 new_dir 重命名/移动 一个目录<br>cp file1 file2 复制一个文件<br>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码   </p>
<p><strong>文件搜索 :</strong><br>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录   </p>
<p>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件 </p>
<p>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件     </p>
<p>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件     </p>
<p>find / -name *.rpm -exec chmod 755 ‘{}’ \; 搜索以 ‘.rpm’ 结尾的文件并定义其权限 </p>
<p>find / -xdev -name *.rpm 搜索以 ‘.rpm’   结尾的文件，忽略光驱、捷盘等可移动设备 </p>
<p>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置   </p>
<p>which halt 显示一个二进制文件或可执行文件的完整路径 </p>
<p><strong>备份:</strong><br>dump [选项] 备份后文件名  原文件或目录选项：<br>-0~9  九个备份级别<br>-f文件名： 指定备份后的文件名<br>-u： 备份成功后，把备份时间记录在/etc/dumpdates文件<br>-v：显备份过程中更多的输出信息<br>-j ：把文件压缩为.bz2格式<br>-W：显示允许被dump的分区备份登等级及备份时间<br>例： dump -0uj -f /root/boot.bak.bz2 /boot<br><strong>备份命令，先执行一次完全备份，并压缩和更新备份时间:</strong><br>cat /etc/dumpdates<br><strong>查看备份时间文件 :</strong><br>cp install.log /boot/<br><strong>复制日志文件到boot分区 :</strong><br>dump -1uj -f /root/boot,bak1.bz2 /boot/<br><strong>增量备份/boot分区，并压缩:</strong><br>dump -W<br><strong>查询分区的备份时间及备份级别 :</strong><br>备份文件或目录，只能用0级别进行完全备份，并且不支持增量备份：<br>dump -0j -f /root/etc.dump.bz2 /etc/  </p>
<p><strong>恢复备份:</strong><br>restore [模式选项] [选项]<br>有四种模式不能混用。<br>-C：比较备份数据和实际数据的变化<br>-i：进入交互模式，手工选择需要恢复的文件<br>-t：查看模式，用于查看文件中拥有哪些数据<br>-r：还原模式，用于数据还原<br>选项：<br>-f：指定备份文件的文件名</p>
<p><strong>磁盘空间:</strong><br>df -h 显示已经挂载的分区列表 </p>
<p>ls -lSr |more 以尺寸大小排列文件和目录 </p>
<p>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’ </p>
<p>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小 </p>
<p>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小<br>为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)</p>
<p>dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ |<br>sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) </p>
<p><strong>用户和群组</strong><br>groupadd group_name 创建一个新用户组 </p>
<p>groupdel group_name 删除一个用户组 </p>
<p>groupmod -n new_group_name old_group_name 重命名一个用户组 </p>
<p>useradd -c “Name Surname “ -g admin -d /home/user1 -s /</p>
<p>bin/bash user1 创建一个属于 “admin” 用户组的用户 </p>
<p>useradd user1 创建一个新用户 </p>
<p>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录) </p>
<p>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/<br>nologin user1 修改用户属性 </p>
<p>passwd 修改口令 </p>
<p>passwd user1 修改一个用户的口令 (只允许root执行) </p>
<p>chage -E 2005-12-31 user1 设置用户口令的失效期限 </p>
<p>pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户 </p>
<p>grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组 </p>
<p>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组</p>
<p>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消 </p>
<p>ls -lh 显示权限 </p>
<p>ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示 </p>
<p>chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 </p>
<p>chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 </p>
<p>chown user1 file1 改变一个文件的所有人属性 </p>
<p>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 </p>
<p>chgrp group1 file1 改变文件的群组 </p>
<p>chown user1:group1 file1 改变一个文件的所有人和群组属性 </p>
<p>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件 </p>
<p>chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 </p>
<p>chmod u-s /bin/file1 禁用一个二进制文件的 SUID位 </p>
<p>chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 </p>
<p>chmod g-s /home/public 禁用一个目录的 SGID 位 </p>
<p>chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 </p>
<p>chmod o-t /home/public 禁用一个目录的 STIKY 位 </p>
<p>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消 </p>
<p>chattr +a file1 只允许以追加方式读写文件 </p>
<p>chattr +c file1 允许这个文件能被内核自动压缩/解压 </p>
<p>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件 </p>
<p>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接 </p>
<p>chattr +s file1 允许一个文件被安全地删除 </p>
<p>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 </p>
<p>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件 </p>
<p>lsattr 显示特殊的属性 </p>
<p><strong>打包和压缩文件:</strong></p>
<p>file 文件名 ：查文件类型（可看是用哪一种方式压缩的）</p>
<p>tar -zxvf a.tar.gz -C ./test ：解压tar.gz到当前目录下的<br>test目录</p>
<p>tar -zcvf /opt/c.tar.gz ./a/ ：压缩tar.gz（把当前目录下的a目录及目录下所有文件压缩为 /opt/目录下的c.tar.gz，这样tar -zxvf c.tar.gz解压出来带有目录a）</p>
<p>tar -jxvf a.tar.bz2 ：解压tar.bz2（到当前目录）</p>
<p>tar -jcvf c.tar.bz2 ./a/ ：压缩tar.bz2（把当前目录下的a目录及目录下所有文件压缩到当前目录下为c.tar.gz2）</p>
<p>unzip a.zip ：解压zip（到当前目录）</p>
<p>unzip -o mdmtest.war -d /opt/mdm ：推荐使用unzip解压war包（-o覆盖原有文件，-d指定文件解压后存储的目录）</p>
<p>zip -r c.zip ./a/ :压缩zip(把当前目录下的a目录及目录下所有文件压缩到当前目录下为c.zip</p>
<p>bzip2 -k file1 ： 压缩一个 ‘file1’ 的文件（-k表示保留源文件）（bzip2格式，比gzip好）</p>
<p>bzip2 -d -k file1.bz2 ： 解压一个叫做 ‘file1.bz2’的文件</p>
<p>gzip file1 ： 压缩一个叫做 ‘file1’的文件（gzip格式）（不能保留源文件）</p>
<p>gzip -9 file1 ： 最大程度压缩</p>
<p>gzip -d file1.gz ： 解压缩一个叫做 ‘file1’的文件</p>
<p><strong>APT 软件工具 (Debian, Ubuntu 以及类似系统):</strong>  </p>
<p>apt-get install package_name 安装/更新一个 deb 包 </p>
<p>apt-cdrom install package_name 从光盘安装/更新一个 deb 包 </p>
<p>apt-get update 升级列表中的软件包 </p>
<p>apt-get upgrade 升级所有已安装的软件 </p>
<p>apt-get remove package_name 从系统删除一个deb包 </p>
<p>apt-get check 确认依赖的软件仓库正确 </p>
<p>apt-get clean 从下载的软件包中清理缓存 </p>
<p>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 </p>
<p><strong>查看文件内容:</strong><br>cat file1 从第一个字节开始正向查看文件的内容 </p>
<p>tac file1 从最后一行开始反向查看一个文件的内容 </p>
<p>more file1 查看一个长文件的内容 </p>
<p>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作 </p>
<p>head -2 file1 查看一个文件的前两行 </p>
<p>tail -2 file1 查看一个文件的最后两行 </p>
<p>tail -f /var/log/messages 实时查看被添加到一个文件中的内容 </p>
<p><strong>文本处理:</strong><br>cat file1 file2 … | command &lt;&gt; </p>
<p>file1_in.txt_or_file1_out.txt general syntax for text </p>
<p>manipulation using PIPE, STDIN and STDOUT </p>
<p>cat file1 | command( sed, grep, awk, grep, etc…) &gt;<br>result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中 </p>
<p>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 </p>
<p>grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug” </p>
<p>grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇 </p>
<p>grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行 </p>
<p>grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug” </p>
<p>sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2” </p>
<p>sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行 </p>
<p>sed ‘/ *#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行 </p>
<p>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容 </p>
<p>sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行 </p>
<p>sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行 </p>
<p>sed -e ‘s/ *$//‘ example.txt 删除每一行最后的空白字符 </p>
<p>sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部 </p>
<p>sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容 </p>
<p>sed -n ‘5p;5q’ example.txt 查看第5行 </p>
<p>sed -e ‘s/00*/0/g’ example.txt 用单个零替换多个零 </p>
<p>cat -n file1 标示文件的行数 </p>
<p>cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行 </p>
<p>echo a b c | awk ‘{print $1}’ 查看一行第一栏 </p>
<p>echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏 </p>
<p>paste file1 file2 合并两个文件或两栏的内容 </p>
<p>paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分 </p>
<p>sort file1 file2 排序两个文件的内容 </p>
<p>sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) </p>
<p>sort file1 file2 | uniq -u 删除交集，留下其他的行 </p>
<p>sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) </p>
<p>comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容 </p>
<p>comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容 </p>
<p>comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 </p>
<p><strong>网络 - （以太网和WIFI无线）:</strong></p>
<p>sudo ifconfig 查看网卡信息</p>
<p>ifconfig eth0 显示一个以太网卡的配置 </p>
<p>ifup eth0 启用一个 ‘eth0’ 网络设备 </p>
<p>ifdown eth0 禁用一个 ‘eth0’ 网络设备 </p>
<p>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址 </p>
<p>ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing) </p>
<p>dhclient eth0 以dhcp模式启用 ‘eth0’ </p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>8.26日报</title>
    <url>/2019/08/26/2019-08-26-26ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p><code>今天看了一天的linux命令但是侧重点不够明确，常用的命令也基本认识了，学习linux命令70%。</code>  </p>
</blockquote>
<blockquote>
<p><code>今天按照网上的材料整理了一些linux常用命令，分享了技术博客。</code></p>
</blockquote>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><blockquote>
<p>今天的不足与感悟</p>
</blockquote>
<h3 id="今天的不足"><a href="#今天的不足" class="headerlink" title="今天的不足"></a>今天的不足</h3><p>今天是我们组技术分享的时间，我讲的是html，虽然事先做好了ppt，但是上台还是有些放不开，不够灵活，只是死板地讲</p>
<h3 id="今天的感悟"><a href="#今天的感悟" class="headerlink" title="今天的感悟"></a>今天的感悟</h3><p>上台演讲的事还是要多练习，还要多和大家沟通，才会一点点地会站在前面讲项目</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>8.23日报</title>
    <url>/2019/08/23/2019-08-23-23ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p><code>今天把vim常用命令整理得差不多了，vim进度90%，今天开始看的linux命令，但是感觉看的很乱，进度40%。</code>  </p>
</blockquote>
<blockquote>
<p><code>今天按照网上的材料整理了一些linux常用命令，分享了技术博客。</code></p>
</blockquote>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><blockquote>
<p>今天的不足与感悟</p>
</blockquote>
<h3 id="今天的不足"><a href="#今天的不足" class="headerlink" title="今天的不足"></a>今天的不足</h3><p>今天心不够静，看到属性多了就乱了，不知道从哪开背起，后来慢慢的静下来从头看也看了好几个命令。</p>
<h3 id="今天的感悟"><a href="#今天的感悟" class="headerlink" title="今天的感悟"></a>今天的感悟</h3><p>代码还是多敲，实践起来记忆得才快，代码敲得多了自然就会了。</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>8.23技术文档</title>
    <url>/2019/08/23/2019-08-23-23jishu/</url>
    <content><![CDATA[<h1 id="linux常用命令整理之一"><a href="#linux常用命令整理之一" class="headerlink" title="linux常用命令整理之一"></a>linux常用命令整理之一</h1><p><strong>关机 (系统的关机、重启以及登出 ):</strong><br>shutdown -h now 关闭系统<br>init 0 关闭系统<br>telinit 0 关闭系统<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启<br>reboot 重启<br>logout 注销   </p>
<p><strong>文件和目录:</strong><br>cd /home 进入 ‘/ home’ 目录’<br>cd .. 返回上一级目录<br>cd ../.. 返回上两级目录<br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br>cd - 返回上次所在的目录<br>pwd 显示工作路径<br>ls 查看目录中的文件<br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br>ls -a 显示隐藏文件<br>ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构<br>lstree 显示文件和目录由根目录开始的树形结构<br>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>mkdir dir1 dir2 同时创建两个目录<br>mkdir -p /tmp/dir1/dir2 创建一个目录树<br>rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>mv dir1 new_dir 重命名/移动 一个目录<br>cp file1 file2 复制一个文件<br>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码   </p>
<p><strong>文件搜索 :</strong><br>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录   </p>
<p>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件 </p>
<p>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件     </p>
<p>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件     </p>
<p>find / -name *.rpm -exec chmod 755 ‘{}’ \; 搜索以 ‘.rpm’ 结尾的文件并定义其权限 </p>
<p>find / -xdev -name *.rpm 搜索以 ‘.rpm’   结尾的文件，忽略光驱、捷盘等可移动设备 </p>
<p>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置   </p>
<p>which halt 显示一个二进制文件或可执行文件的完整路径 </p>
<p><strong>备份:</strong><br>dump [选项] 备份后文件名  原文件或目录选项：<br>-0~9  九个备份级别<br>-f文件名： 指定备份后的文件名<br>-u： 备份成功后，把备份时间记录在/etc/dumpdates文件<br>-v：显备份过程中更多的输出信息<br>-j ：把文件压缩为.bz2格式<br>-W：显示允许被dump的分区备份登等级及备份时间<br>例： dump -0uj -f /root/boot.bak.bz2 /boot<br><strong>备份命令，先执行一次完全备份，并压缩和更新备份时间:</strong><br>cat /etc/dumpdates<br><strong>查看备份时间文件 :</strong><br>cp install.log /boot/<br><strong>复制日志文件到boot分区 :</strong><br>dump -1uj -f /root/boot,bak1.bz2 /boot/<br><strong>增量备份/boot分区，并压缩:</strong><br>dump -W<br><strong>查询分区的备份时间及备份级别 :</strong><br>备份文件或目录，只能用0级别进行完全备份，并且不支持增量备份：<br>dump -0j -f /root/etc.dump.bz2 /etc/  </p>
<p><strong>恢复备份:</strong><br>restore [模式选项] [选项]<br>有四种模式不能混用。<br>-C：比较备份数据和实际数据的变化<br>-i：进入交互模式，手工选择需要恢复的文件<br>-t：查看模式，用于查看文件中拥有哪些数据<br>-r：还原模式，用于数据还原<br>选项：<br>-f：指定备份文件的文件名</p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>8.22技术文档</title>
    <url>/2019/08/22/2019-08-22-22jishu/</url>
    <content><![CDATA[<h1 id="vim常用命令整理"><a href="#vim常用命令整理" class="headerlink" title="vim常用命令整理"></a>vim常用命令整理</h1><blockquote>
<p>打开或新建一个文件，光标在第一行首</p>
</blockquote>
<p>vim 文件名</p>
<blockquote>
<p>恢复上次vim打开时崩溃的文件</p>
</blockquote>
<p>vim -r 文件名</p>
<blockquote>
<p>以只读方式放入vim编辑器中</p>
</blockquote>
<p>vim -R 文件名</p>
<blockquote>
<p>打开文件，光标在最后一行首部</p>
</blockquote>
<p>vim + 文件名</p>
<blockquote>
<p>在光标前插入输入的文本</p>
</blockquote>
<p>i</p>
<blockquote>
<p>在光标后插入输入的文本</p>
</blockquote>
<p>a</p>
<blockquote>
<p>在光标所在的行首插入文本</p>
</blockquote>
<p>I（大写i）</p>
<blockquote>
<p>在光标所在行的行尾插入文本</p>
</blockquote>
<p>A</p>
<blockquote>
<p>在光标所在行下面插入新一行，光标在行首</p>
</blockquote>
<p>o</p>
<blockquote>
<p>在光标所在行上面插入新一行，光标在行首</p>
</blockquote>
<p>O</p>
<blockquote>
<p>查找指定字符</p>
</blockquote>
<p>/指定字符</p>
<blockquote>
<p>查找以指定字符为行首的行</p>
</blockquote>
<p>/^指定字符</p>
<blockquote>
<p>查找以指定字符为行尾的行</p>
</blockquote>
<p>/指定字符$</p>
<blockquote>
<p>从光标处向后查找字符串</p>
</blockquote>
<p>?abc<br>按 n 向后查询下一个符合字符<br>按 N 向前查询上一个符合字符</p>
<blockquote>
<p>替换光标所在的字符</p>
</blockquote>
<p>r</p>
<blockquote>
<p>从光标所在位置开始替换字符，直到按esc结束</p>
</blockquote>
<p>R</p>
<blockquote>
<p>将当前所在行所有a1换成a2</p>
</blockquote>
<p>:s/a1/a2/g</p>
<blockquote>
<p>将文件中n1到n2行的所有a1换成a2</p>
</blockquote>
<p>:n1,n2s/a1/a2/g</p>
<blockquote>
<p>将文件中所有a1换成a2</p>
</blockquote>
<p>:g/a1/a2/g</p>
<blockquote>
<p>删除光标所在位置的字符</p>
</blockquote>
<p>x</p>
<blockquote>
<p>删除光标位置到行尾内容</p>
</blockquote>
<p>D</p>
<blockquote>
<p>删除光标所在行</p>
</blockquote>
<p>dd</p>
<blockquote>
<p>删除包括当前行的n行文本</p>
</blockquote>
<p>ndd</p>
<blockquote>
<p>删除光标所在行直到文件末尾所有内容</p>
</blockquote>
<p>dG</p>
<p><code>被删除的文件并不是真正删除，而是放进了剪切板中</code></p>
<blockquote>
<p>将剪切板内容复制到光标后</p>
</blockquote>
<p>p(小写)</p>
<blockquote>
<p>将剪贴板中的内容复制到光标前</p>
</blockquote>
<p>P(大写)</p>
<blockquote>
<p><code>ctrl + c  块选择</code> </p>
</blockquote>
<p>y  复制选定的字符   </p>
<blockquote>
<p>将光标所在行复制到剪切板，前面加数字n，可以复制多行</p>
</blockquote>
<p>yy</p>
<blockquote>
<p>将光标位置单词复制到剪切板</p>
</blockquote>
<p>yw</p>
<blockquote>
<p>保存并退出</p>
</blockquote>
<p>:wq</p>
<blockquote>
<p>不保存就退出</p>
</blockquote>
<p>:q</p>
<blockquote>
<p>保存</p>
</blockquote>
<p>:w</p>
<blockquote>
<p>另存为</p>
</blockquote>
<p>:w 文件名</p>
<p><code>命令后面加! 增加强制性</code></p>
<blockquote>
<p>保存文本并退出v，<code>更通用的一个vim命令</code></p>
</blockquote>
<p>x!</p>
<blockquote>
<p>直接退出vim编辑器</p>
</blockquote>
<p>ZZ</p>
<blockquote>
<p>与下一行数据合并</p>
</blockquote>
<p>J</p>
<blockquote>
<p>复原前一个动作</p>
</blockquote>
<p>u</p>
<blockquote>
<p>重复前一个动作</p>
</blockquote>
<p> <code>.</code> </p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>8.22日报</title>
    <url>/2019/08/22/2019-08-22-22ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p><code>git已经基本完成，今天学习了如何使用vim和vim的常用命令，已经大致地过了一遍，vim学习进度大约70%。</code>  </p>
</blockquote>
<blockquote>
<p><code>并且今天还按照网上的材料整理了一下常用命令，分享了技术博客。</code></p>
</blockquote>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><blockquote>
<p>今天的不足与感悟</p>
</blockquote>
<h3 id="今天的不足"><a href="#今天的不足" class="headerlink" title="今天的不足"></a>今天的不足</h3><p>vim的常用语法挺简单的，但是我看了两节课没去怎么实践去敲，感觉边敲边记会更快一些。</p>
<h3 id="今天的感悟"><a href="#今天的感悟" class="headerlink" title="今天的感悟"></a>今天的感悟</h3><p>代码还是多敲，实践起来记忆得才快，代码敲得多了自然就会了。</p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>8.21日报</title>
    <url>/2019/08/21/2019-08-21-21ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p><code>今天勉强通过了老师的测试 git完成度在90%，并且今天整理了git常用命令。</code></p>
</blockquote>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><blockquote>
<p>今天的不足与感悟</p>
</blockquote>
<h3 id="今天的不足"><a href="#今天的不足" class="headerlink" title="今天的不足"></a>今天的不足</h3><p>考试的时候在写 git commit时候忘记先使用 git status 看一看，平时自己记笔记的时候还特意记过这一点，考试的时候还忘记了，这种马虎要长记性。还有今天学习效率问题，虽然勉强过了老师的考试，但是今天在学习时间的学习效率自我感觉很差 看的git官方后面的概念文档很蒙，感觉今天往后看没什么太大进度，只有一点大致了解。</p>
<h3 id="今天的感悟"><a href="#今天的感悟" class="headerlink" title="今天的感悟"></a>今天的感悟</h3><p>在一个知识点搞不明白时候一定要自己亲手自己实验几遍，实验几遍不会再去问其他同学，其他同学有问题也要勤看，尽管自己也不能会，等他解决问题之后再去看看他怎么解决的，以后注意同样问题。<br>总之个人的发展离不开团体。</p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>8.21技术文档</title>
    <url>/2019/08/21/2019-08-21-21jishu/</url>
    <content><![CDATA[<h1 id="git常用命令整理"><a href="#git常用命令整理" class="headerlink" title="git常用命令整理"></a>git常用命令整理</h1><blockquote>
<p>初始化代码库</p>
</blockquote>
<p>git init     文件名</p>
<blockquote>
<p>克隆远程仓库</p>
</blockquote>
<p>git clone 远程仓库地址</p>
<blockquote>
<p>添加文件到暂存区</p>
</blockquote>
<p>git add 文件  (对文件进行跟踪，再用一次就是将跟踪的文件放到暂存区) </p>
<p>添加当前所有文件到暂存区 git add.或者git add –all</p>
<blockquote>
<p>删除文件,并将这次删除放入暂存区</p>
</blockquote>
<p>git rm  </p>
<blockquote>
<p>停止追踪指定文件，但文件会保留在工作区</p>
</blockquote>
<p>git rm  –cached</p>
<blockquote>
<p>改名文件，并将这个改名放入暂存区</p>
</blockquote>
<p>git mv 老文件名 新文件名</p>
<blockquote>
<p>提交暂存区到仓库区</p>
</blockquote>
<p>git commit -m [备注]</p>
<blockquote>
<p>提交暂存区的指定文件到仓库区</p>
</blockquote>
<p>git commit 文件 -m [备注] （加-a直接提交到仓库区）</p>
<blockquote>
<p>重新提交一次commit，修改提交的备注</p>
</blockquote>
<p>git commit –amend -m [备注]</p>
<blockquote>
<p>重新提交一次commit，并指定文件的新变化</p>
</blockquote>
<p>git commit –amend 文件</p>
<blockquote>
<p>显示有变更的文件</p>
</blockquote>
<p>git status <code>每次commit的时候建议先git status 看一下</code></p>
<blockquote>
<p>显示当前分支的提交历史</p>
</blockquote>
<p>git log</p>
<blockquote>
<p>显示当前分支的操作记录 （包括回退的操作）</p>
</blockquote>
<p>git reflog</p>
<blockquote>
<p>根据关键词搜索历史</p>
</blockquote>
<p>git log -S 关键词</p>
<blockquote>
<p>把暂存区的文件 恢复到工作区</p>
</blockquote>
<p>git checkout 文件名</p>
<blockquote>
<p>恢复暂存区所有文件到工作区</p>
</blockquote>
<p>git checkout .</p>
<blockquote>
<p>回退暂存区的指定文件,工作区不变</p>
</blockquote>
<p>git reset 文件</p>
<blockquote>
<p>回退暂存区与工作区</p>
</blockquote>
<p>git reset –hard</p>
<blockquote>
<p>回退到指定历史：</p>
</blockquote>
<p>git reset 历史</p>
<blockquote>
<p>回退到指定历史操作，同时重置暂存区和工作区</p>
</blockquote>
<p>git reset –hard 历史</p>
<blockquote>
<p>新建一个历史，用来撤销指定的历史并应用到当前分支</p>
</blockquote>
<p>git revert 历史</p>
<blockquote>
<p>显示暂存区和工作区差异</p>
</blockquote>
<p>git diff</p>
<blockquote>
<p>显示暂存区和上一次提交的差异</p>
</blockquote>
<p>git diff –cached 文件</p>
<blockquote>
<p>列出所有本地分支</p>
</blockquote>
<p>git branch</p>
<blockquote>
<p>列出所有远程分支</p>
</blockquote>
<p>git branch -r</p>
<blockquote>
<p>列出所有分支</p>
</blockquote>
<p>git branch -a</p>
<blockquote>
<p>新建分支</p>
</blockquote>
<p>git branch 新分支名称</p>
<blockquote>
<p>新建分支并且切换到该分支</p>
</blockquote>
<p>git checkout -b 新分支名</p>
<blockquote>
<p>新建分支，与制定远程分支建立追踪关系</p>
</blockquote>
<p>git branch –track 分支名 远程分支名</p>
<blockquote>
<p>切换分支</p>
</blockquote>
<p>git checkout 分支名</p>
<blockquote>
<p>在现有分支和制定远程分支之间建立追踪关系</p>
</blockquote>
<p>git branch –set-upstream 分支名 远程分支名</p>
<blockquote>
<p>合并指定分支到当前分支</p>
</blockquote>
<p>git merge 分支名</p>
<blockquote>
<p>删除分支</p>
</blockquote>
<p>git branch -d 分支名</p>
<blockquote>
<p>删除远程分支</p>
</blockquote>
<p>git push origin –delete 远程分支名<br>git branch -dr 远程库/分支名</p>
<blockquote>
<p>下载远程仓库的所有变动</p>
</blockquote>
<p>git fetch 远程仓库</p>
<blockquote>
<p>显示所有远程仓库 </p>
</blockquote>
<p>git remote -v</p>
<blockquote>
<p>查看某个远程库的信息</p>
</blockquote>
<p>git remote show 远程库</p>
<blockquote>
<p>增加一个远程库，并命名</p>
</blockquote>
<p>git remote add 起的名 远程库的地址</p>
<blockquote>
<p>取回远程库的变化，并与本地分支自动合并</p>
</blockquote>
<p>git pull 远程库 分支(如果提示无关历史无法合并，<br>可以使用：–allow-unrelated-histories)</p>
<blockquote>
<p>上传本地指定分支到远程库</p>
</blockquote>
<p>git push  远程库 分支</p>
<blockquote>
<p>强行推送分支到远程仓库</p>
</blockquote>
<p>git push 远程库 –force </p>
<blockquote>
<p>推送所有分支到远程仓库</p>
</blockquote>
<p>git pus 远程库 –all</p>
<blockquote>
<p>隐藏未提交的修改，用于后续恢复到当前工作目录：</p>
</blockquote>
<p>git stash</p>
<blockquote>
<p>将隐藏的修改应用到当前分支对应目录上</p>
</blockquote>
<p>git stash pop</p>
<blockquote>
<p>列出所有标签</p>
</blockquote>
<p>git tag</p>
<blockquote>
<p>在当前操作历史上添加标签</p>
</blockquote>
<p>git tag 标签名</p>
<blockquote>
<p>新建一个标签在指定历史</p>
</blockquote>
<p>git tag 标签名 历史</p>
<blockquote>
<p>删除本地标签</p>
</blockquote>
<p>git tag -d 标签名</p>
<blockquote>
<p>删除远程标签</p>
</blockquote>
<p>git push origin :refs/tags/标签名</p>
<blockquote>
<p> 查看标签信息</p>
</blockquote>
<p>git show 标签名</p>
<blockquote>
<p>提交指定标签</p>
</blockquote>
<p>git push 远程库 标签</p>
<blockquote>
<p>提交所有标签</p>
</blockquote>
<p>git push 远程库 –tags</p>
<blockquote>
<p>新建一个分支 指向某个标签</p>
</blockquote>
<p>git checkout -b 分支名 标签</p>
<h3 id="最后放上一张网上找到的git常用命令表："><a href="#最后放上一张网上找到的git常用命令表：" class="headerlink" title="最后放上一张网上找到的git常用命令表："></a>最后放上一张网上找到的git常用命令表：</h3><p><img src="https://s2.ax1x.com/2019/11/20/MWMBuT.md.png" alt="git常用命令"></p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>8.20日报</title>
    <url>/2019/08/20/2019-08-20-20ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p>今天对git的一些基础命令熟练度80%，又继续往后看官方的文档，关于git的实际工作流程，看了举的几个例子，也大致了解了工作流程。</p>
</blockquote>
<p> <strong>git团队工作大致流程例子：</strong> </p>
<p> 有一个远程仓库  </p>
<p> 第一个人，克隆了仓库，作了些更新，在本地提交。   </p>
<p> 第二个开发者，一样这么做：克隆仓库，提交更新。</p>
<p> 现在，第二个人将她的工作推送到服务器上，第一个人 也尝试推送自己的工作上去。</p>
<p>第一个人的推送操作被驳回，因为 第二个人已经推送了新的数据上去。</p>
<p>这时候第一个人需要把远程库的更新拉下来同步才能完成推送。</p>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><blockquote>
<p>今天的不足与感悟</p>
</blockquote>
<h3 id="今天的不足"><a href="#今天的不足" class="headerlink" title="今天的不足"></a>今天的不足</h3><p>今天看git官方文档的概念文档了，但是感觉自己看得很笼统，学习效率很低，导致越看越有点蒙。</p>
<h3 id="今天的感悟"><a href="#今天的感悟" class="headerlink" title="今天的感悟"></a>今天的感悟</h3><p>今天我的U盘出现了没办法打开的情况，在ubuntu的系统上也不是很容易下u盘修复的工具，自己弄了1个多小时无果后寻求了老师的帮助，老师几下就解决了问题。这让我深深地体会到了经验的重要，一定要多去实践，经验才是知识进步的堆积。</p>
]]></content>
      <categories>
        <category>git进度</category>
      </categories>
      <tags>
        <tag>git命令</tag>
      </tags>
  </entry>
  <entry>
    <title>8.19日报</title>
    <url>/2019/08/19/2019-08-19-19ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p>今天又进一步地熟练了git的命令，以及深入地了解到了git分支的流程和使用方法</p>
</blockquote>
<p>分支的主要作用就是多个人可以同时利用分支修改自己要实现的的功能模块，然后再上传到远程仓库，达到多人同时作业，大大提高了开发效率。</p>
<p> <strong>主要知识点：</strong> </p>
<p> 创建分支：   git branch </p>
<p>查看分支：   git branch</p>
<p>切换分支：  git checkout</p>
<p>创建分支并转到： git checkout -b</p>
<p>删除分支： git branch -d</p>
<p>合并当前分支与指定分支： git merge</p>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><blockquote>
<p>今天的不足与感悟</p>
</blockquote>
<h3 id="今天的不足"><a href="#今天的不足" class="headerlink" title="今天的不足"></a>今天的不足</h3><p>今天轮到我上台讲知识点了，但是没有去准备太多的知识点去讲，基础知识也不够扎实，出现了很多预料之外的错误，准备不够充分。</p>
<h3 id="今天的感悟"><a href="#今天的感悟" class="headerlink" title="今天的感悟"></a>今天的感悟</h3><p>上台之后逻辑不是很清楚，先讲什么后讲什么，让我理解到了程序员不光要会敲代码也要会表达。</p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>8.17日报</title>
    <url>/2019/08/17/2019-08-17-17ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p>今天我深入了解并学习了git</p>
</blockquote>
<h4 id="今天下来我对于git的理解："><a href="#今天下来我对于git的理解：" class="headerlink" title="今天下来我对于git的理解："></a>今天下来我对于git的理解：</h4><p>经过阅读了官方文档和前辈们整理的博客，我了解到了git对于项目开发的重要性，每个人可以根据不同的需求创建分支，修改自己的功能模块，然后再重新合并到服务器上的代码</p>
<h4 id="今天的学习成果："><a href="#今天的学习成果：" class="headerlink" title="今天的学习成果："></a>今天的学习成果：</h4><p> 今天已经把博客基本做出一个可以交付的初成品了，下午开始学习git语法，现在已经了解了git的一些基础语法，也大概了解了git的工作原理与操作。</p>
<p> <strong>今日不足：</strong>  电脑的有线网不知为何无法连接，在寻找各种方法解决无果后甚至重做系统，导致了浪费了过多的学习时间。git的学习效率也不够高，感觉看得很乱，看文档没有条理性，静不下心来看文档。</p>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><blockquote>
<p>今天的不足与感悟</p>
</blockquote>
<h3 id="今天的不足"><a href="#今天的不足" class="headerlink" title="今天的不足"></a>今天的不足</h3><p>今天将自己做的博客上交检查了，在一个之前完成的功能出现了问题，自己没有在交项目时候提前看一下，这件事我会记住的。</p>
<h3 id="今天的感悟"><a href="#今天的感悟" class="headerlink" title="今天的感悟"></a>今天的感悟</h3><p>交项目的时候一定要将自己的所有功能都检查一边，不要因为之前解决了就不再看那个功能了，否则也许改别的时候把功能改了，否则自己麻烦别人也麻烦。</p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>8.16日报</title>
    <url>/2019/08/16/2019-08-16-16ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p>今天主要学习了ubuntu系统的安装与git的使用</p>
</blockquote>
<h4 id="关于ubuntu系统的安装"><a href="#关于ubuntu系统的安装" class="headerlink" title="关于ubuntu系统的安装"></a>关于ubuntu系统的安装</h4><p>在网上下载了u盘启动盘制作，将自己的u盘做成了启动盘<br>，经过四五次的反复安装与思考终于安装成功了。</p>
<p> <strong>今日不足：</strong> 由于第一次接触ubuntu系统，准备又不够充分，导致了安装了四五次才能够成功。</p>
<p><em>关于git的使用</em></p>
<p> 今天布置的任务是成功在github上发布自己的博客，我从最开始的不知道git是什么，在网上一步步地查询，逐渐深入了解到了git与github，最终成功创建了github并构建了存储库。</p>
<p> <strong>今日不足：</strong> 在使用jekyll模板时候修改模板时没有参考官方文档，自己乱打文档去寻找，大大降低了进度。</p>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><blockquote>
<p>今天的不足与感悟</p>
</blockquote>
<h3 id="今天的不足"><a href="#今天的不足" class="headerlink" title="今天的不足"></a>今天的不足</h3><p>短短的一天自学模式，我就已经发现了自己的很多问题：不喜欢查看官方文档，不喜欢多问问做出来的同学喜欢自己抠问题。</p>
<h3 id="今天的感悟"><a href="#今天的感悟" class="headerlink" title="今天的感悟"></a>今天的感悟</h3><p>永远都有学的比较好的和学的一般的，既然自己学的不够好就要付出更加多的努力。</p>
]]></content>
      <categories>
        <category>系统与命令</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
</search>
