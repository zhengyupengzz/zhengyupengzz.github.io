<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>11.20心得</title>
    <url>/2019/11/20/2019-11-20-20ribao/</url>
    <content><![CDATA[<h1 id="JavaWeb开发环境的配置"><a href="#JavaWeb开发环境的配置" class="headerlink" title="JavaWeb开发环境的配置:"></a>JavaWeb开发环境的配置:</h1><p><strong>tomcat配置:</strong>  </p>
<ol>
<li>下载tomcat  </li>
<li>解压到任意的英文目录  </li>
<li>将tomcat引入到项目中  </li>
</ol>
<p><strong>HTTP协议:</strong>  </p>
<pre><code>C/S: 下载客户端  热更新, 人工智能 学习算法  

B / S :  
</code></pre><p>缺点:端口不安全  </p>
<p>优点:只需要维护一端  </p>
<p><code>http协议</code>:超文本传输协议,是一个应用层的网络传输协议!<br><code>特点</code>:  </p>
<ol>
<li>简单,快速  </li>
<li>无连接协议,每次连接服务器只处理一次客户端的请求,处理完毕,立即断开  </li>
<li>无状态协议,处理请求,以及进行响应时,没有记忆能力!  </li>
<li>支持多种不同的数据提交方式,<code>GET/POST</code>等等  </li>
<li>数据传输很灵活,支持任意数据类型  </li>
</ol>
<p><strong>HTTP协议的组成部分:</strong>  </p>
<ol>
<li><p>请求:<br> 请求由四部分组成:  </p>
<ul>
<li>请求头:<br>  请求头部的信息,由一个个的键值对组成,描述的是有关客户端的信息  </li>
<li>请求体:<br>  GET请求没有请求体,当请求方式为POST时,存在请求体,请求体是用于存储数据的数据容器  </li>
<li>请求空行:<br>  请求头部与请求体之间的一行空白  </li>
<li>请求行:<br>  由一个个的键值对组成,描述的是:描述了请求的方式,远端服务器地址,以及所使用的协议版本等信息  </li>
</ul>
</li>
<li><p>响应:<br> 响应由三部分组成:  </p>
<ul>
<li>响应头:<br>  响应头部的信息,由一个个的键值对组成,描述的是有关服务器的信息  </li>
<li>响应体:<br>  服务器给客户端回复的主体内容  </li>
<li>响应行:<br>  描述了响应的协议版本,响应状态码,以及响应成功或失败的相关解释   </li>
</ul>
</li>
</ol>
<h4 id="开发环境下-代码部署到服务器后-访问的路径"><a href="#开发环境下-代码部署到服务器后-访问的路径" class="headerlink" title="开发环境下: 代码部署到服务器后,访问的路径:"></a>开发环境下: 代码部署到服务器后,访问的路径:</h4><pre><code>http://ip地址:端口号/项目名/文件名.后缀名  
</code></pre><h4 id="HttpServlet类"><a href="#HttpServlet类" class="headerlink" title="HttpServlet类:"></a>HttpServlet类:</h4><pre><code>步骤:
</code></pre><ol>
<li>编写一个类,继承自HttpServlet  </li>
<li>重写父类的service(HttpSercletRequest request,HttpServletResponse response)方法  </li>
<li>在service方法中 对用户进行响应  </li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>11.20心得</title>
    <url>/2019/11/20/2019-11-20-20xinde/</url>
    <content><![CDATA[<h1 id="对于博客模板的修改"><a href="#对于博客模板的修改" class="headerlink" title="对于博客模板的修改:"></a>对于博客模板的修改:</h1><blockquote>
<p>由于19号发现了之前自己的博客模板有一些没改好的地方,便下决心这次要彻底改好一个博客模板</p>
</blockquote>
<p>所以19号的整整一天就都是在找模板,看效果的  </p>
<p>然后晚自习的时候就已经确定好了这个模板,开始着手修改  </p>
<p>由于不太了解博客里面元素和.ejs文件的构造 在改一些东西的时候总会有报错  </p>
<p>后来想到了把所有文件打开  然后去查找那个关键字  </p>
<p>由于有一些js基础,这么一查找到,想做些修改也不是很难  </p>
<p>在将一些404图片修改了,把多余的文字修改了之后  </p>
<blockquote>
<p>后续又对博客进行了一些优化  </p>
</blockquote>
<p>首先将<code>Valine</code>评论区的 ID 和 Key 换成了自己注册的LeanCloud 的ID 和 Key  </p>
<p>还将github博客也推到了coding 这个仓库可以让国内访问github可以快一些  </p>
<p>并将自己之前购买的域名都绑定到了自己的博客上:  </p>
<p><a href="http://zhengyupeng.top" target="_blank" rel="noopener">zhengyupeng.top</a>  </p>
<p><a href="https://www.zhengyupeng.top" target="_blank" rel="noopener">www.zhengyupeng.top</a>  </p>
<p>也都能访问到我的博客了!  </p>
<p><strong>最后总结一下心得吧:</strong>  </p>
<p>昨天一天和今天上午到十点多相当于在学习Java的进度上没有进展,<br>但是改完这个博客,也学到了很多的东西,了解到了很多东西,<br>并且改完这个博客心情都变好了,可以安心学习去了。<br>接下来传完的个博客我就继续学习Java了,<strong><code>冲冲冲!!!</code></strong></p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>11.20心得</title>
    <url>/2019/11/20/2019-11-21-21jishu/</url>
    <content><![CDATA[<h1 id="对谷歌插件的导入导出"><a href="#对谷歌插件的导入导出" class="headerlink" title="对谷歌插件的导入导出:"></a>对谷歌插件的导入导出:</h1><ol>
<li>导出谷歌插件</li>
</ol>
<p>在你的电脑中找到谷歌的安装的位置   </p>
<p>正常情况下默认为<code>C:\Users\Administrator\AppData\Local\Google\Chrome\User Data\Default\Extensions</code></p>
<p>这个路径下存放的都是谷歌浏览器中安装的插件  </p>
<p>将此目录下的插件文件复制即可</p>
<ol start="2">
<li>判断文件分别对应哪个插件  </li>
</ol>
<p>在插件这个目录下 文件名都是随机生成的, 所以我们没办法直接在这里区分哪个插件  </p>
<p>我们可以点进每个文件夹 它的下级目录就是一个版本号 , 在谷歌的扩展程序中寻找与之相同的插件  </p>
<p>那这个文件夹就是对应的插件了 </p>
<ol start="3">
<li>如何导入谷歌插件</li>
</ol>
<p>设置—&gt; 左侧栏扩展程序 —&gt; 右上角确定开启开发者模式 —&gt; 加载已解压的扩展程序  </p>
<p>然后在文件中找到之前复制导出的那些文件夹,<code>注意:要选中加载的文件夹 是乱码名下那个版本号名的文件夹!</code>  </p>
<blockquote>
<p>这里再分享一个安装插件的小技巧  </p>
</blockquote>
<p><strong>有时候我们在网上下载下来的是.crx文件,然而谷歌有时候会安装不上这种文件</strong><br><strong>这时候可以将.crx文件后缀名改为<code>.zip</code>或者其他压缩文件后缀名,然后再解压,之后的导入插件步骤同上</strong></p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>谷歌插件</tag>
      </tags>
  </entry>
  <entry>
    <title>11.18JAVA学习进度</title>
    <url>/2019/11/18/2019-11-18-18ribao/</url>
    <content><![CDATA[<h1 id="11-18Java学习进度"><a href="#11-18Java学习进度" class="headerlink" title="11.18Java学习进度"></a>11.18Java学习进度</h1><h2 id="解析xml属性操作-Xpath"><a href="#解析xml属性操作-Xpath" class="headerlink" title="解析xml属性操作,Xpath:"></a>解析xml属性操作,Xpath:</h2><pre><code>// 1. 加载xml文件到jvm中,形成数据流
InputStream is TestXML_1.class.getClassLoader().getResourceAsStream(&quot;test4.xml&quot;);

// 2. 创建解析对象  
SAXReader sax = new SAXReader();  

// 3. 获得文档对象(整个xml文件)[将数据流转换成一个文档对象]  
Document doc = sax.read(is);  

// 4. 获得根元素  
Element root = doc.getRootElement();  

// 5. 获得根元素下的所有子元素
List&lt;Element&gt; list = root.elements();

//System.out.println(list.size());  
//list.forEach( s -&gt; System.out.println(s));  

//for(Element e1: list){
//    List&lt;Element&gt; list2 = e1.elements();
//   for(Element e2 : list2){
//        System.out.println(e2.getName()+&quot;:&quot;+e2.getData());
//    }
//} 

for(Element e1 : list){
    Attribute type = e1.attribute(&quot;type&quot;);
    System.out.println(type.getValue());
}
</code></pre><p><strong>添加元素:</strong>  </p>
<pre><code>// 创建元素(节点)
Element student = root.addElement(&quot;student&quot;);
Element id = student.addElement(&quot;id&quot;);
id.setText(&quot;3&quot;);
Element name = student.addElement(&quot;name&quot;);
name.setText(&quot;curry&quot;);
Element age = student.addElement(&quot;age&quot;);
age.setText(&quot;30&quot;);

//写入xml文件中
FileOutputStream fos = new FileOutputStream(new File(&quot;D:/xx.xml&quot;));
OutputFormat format = new OutputFormat(&quot;\t\n&quot;,true,&quot;UTF-8&quot;);
XMLWriter xw = new XMLWriter(out,format);

//将整个文档对象写入文件中
xw.write(doc);
System.out.println(&quot;写入成功!&quot;);
xw.close();
</code></pre><p><strong>Xpath:</strong><br>xml文件 path路径  :</p>
<ol>
<li>xpath是一门在xml文档中快速查找信息的方式  </li>
<li>单纯的使用dom4j访问节点时,需要一层一层的处理,如果有了xpath,访问层级的节点就简单了  </li>
<li>使用xpath需要引包: jaxen-1.1-beta-7.jar  </li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>解析xml属性操作</tag>
        <tag>Xpath</tag>
      </tags>
  </entry>
  <entry>
    <title>11.16技术分享</title>
    <url>/2019/11/16/2019-11-16-16jishu/</url>
    <content><![CDATA[<h1 id="11-16技术分享"><a href="#11-16技术分享" class="headerlink" title="11.16技术分享"></a>11.16技术分享</h1><h2 id="idea运行tomcat控制台乱码"><a href="#idea运行tomcat控制台乱码" class="headerlink" title="idea运行tomcat控制台乱码:"></a>idea运行tomcat控制台乱码:</h2><h3 id="1-首先设置idea的编码格式"><a href="#1-首先设置idea的编码格式" class="headerlink" title="1.首先设置idea的编码格式:"></a>1.首先设置idea的编码格式:</h3><p>File–&gt;Settings–&gt;File Encodings</p>
<p><img src="http://zhengyupeng.top/images/idea%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F.png" alt="idea编码格式">  </p>
<p>将所有编码格式统一设置成UTF-8。  </p>
<h3 id="2-再设置tomcat的编码格式"><a href="#2-再设置tomcat的编码格式" class="headerlink" title="2.再设置tomcat的编码格式:"></a>2.再设置tomcat的编码格式:</h3><p><img src="http://zhengyupeng.top/images/tomcat%E8%AE%BE%E7%BD%AE.png" alt="tomcat设置">  </p>
<p>改变VM options为-Dfile.encoding=UTF-8:<br><img src="http://zhengyupeng.top/images/tomcat%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F.png" alt="tomcat编码格式"> </p>
<p><strong><code>完成上面的设置后还会有乱码,不要急</code></strong>  </p>
<h3 id="3-配置idea的文件设置"><a href="#3-配置idea的文件设置" class="headerlink" title="3.配置idea的文件设置:"></a>3.配置idea的文件设置:</h3><p>找到idea图标,右键,打开文件位置找到  </p>
<p><code>idea.exe.vmoptions</code>和<code>idea64.exe.vmoptions</code>文件  并打开文件  </p>
<p>在文件后面添加一行：-Dfile.encoding=UTF-8   </p>
<p>idae中的设置配置也要修改</p>
<p>help–&gt;Edit Custom VM Options…  </p>
<p>打开此配置 也在最后一行添加:-Dfile.encoding=UTF-8  </p>
<h3 id="4-修改tomcat的运行编码格式"><a href="#4-修改tomcat的运行编码格式" class="headerlink" title="4.修改tomcat的运行编码格式:"></a>4.修改tomcat的运行编码格式:</h3><p>进入到tomcat的根目录的bin目录下  </p>
<p>此时可以在文件地址栏输入cmd来启动dos窗口执行  </p>
<pre><code>catalina.bat run
</code></pre><p>(或者也可以直接cmd  然后cd到bin目录下 执行此命令)  </p>
<p>之后再用命令切换cmd的编码格式<br>“chcp 65001”切换cmd为utf8，”chcp 936”切换cmd为gbk  </p>
<p>这里我们使用chcp 65001来切换成utf8  </p>
<p>执行之后可以再运行一下</p>
<pre><code>catalina.bat run
</code></pre><p>看看命令是否都编程正常汉语,若都成正常汉语就是成功了!</p>
<p>然后重启idea即可.  </p>
<p><code>最后提一句:</code>  </p>
<p>自己改tomcat的logging.properties为GBk会导致调试时get/post参数乱码  </p>
<p>还是都改成UTF8稳妥。</p>
]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>idea控制台乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>11.16JAVA学习进度</title>
    <url>/2019/11/16/2019-11-16-16ribao/</url>
    <content><![CDATA[<h1 id="11-16Java学习进度"><a href="#11-16Java学习进度" class="headerlink" title="11.16Java学习进度"></a>11.16Java学习进度</h1><h2 id="数据库优化-XML"><a href="#数据库优化-XML" class="headerlink" title="数据库优化,XML:"></a>数据库优化,XML:</h2><h4 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化:"></a>数据库优化:</h4><ol>
<li><code>在进行表格查询时</code>,where子句中的条件执行顺序是从左至右,清除数据量较大的条件应该放在左边.(<code>特别注意:笛卡尔积消除条件必须放在左边</code>)<pre><code>10000 --&gt;9999 ---&gt;9998 ---&gt;999
10000 ---&gt;999 ---&gt;998
</code></pre></li>
<li><p><code>在进行表格查询时</code>,列名列表应避免<em>号! 数据库在执行查询操作时,会先将</em>号展开,转换为所有的列名,再进行查询.  </p>
</li>
<li><p><code>再进行表格查询时</code>,能使用where条件筛选的数据,应尽量避免使用having子句来筛选,因为where条件执行在having之前,再早起筛选掉大量数据,可以让程序执行的更顺畅.  </p>
</li>
<li><p><code>在进行多表查询时</code>,查询的表顺序是从左至右的,应把表中数据量最少的表放在查询的最右边.  </p>
</li>
<li><p><code>进行多表查询时</code>,应尽可能的给所有表添加别名,能明确的区分有冲突的列.  </p>
</li>
<li><p><code>在使用事务时</code>,应尽量多地commit,尽量早地commit.<br>原因:事务在未提交是,数据库会耗费大量内存,来缓存未提交的SQL结果.  </p>
</li>
<li><p><code>尽可能多的使用函数 来提高SQL执行的效率.</code>  </p>
</li>
<li><p><code>SQL语句编写时</code>,除字符串以外,应使用大写字母.<br>因为SQL语句执行时,会先将小写字母转化为大写字母再执行.  </p>
</li>
<li><p><code>应尽可能少的访问数据库(多次数据访问的结果可能相同,如果缓存起来,可以提高程序的执行效率)</code>  </p>
</li>
<li><p><code>在索引列上</code>,尽可能避免使用not来判断,not关键字入股判断了索引列,会导致此次查询索引失效,转而使用全表扫描的方式查询.  </p>
</li>
<li><p><code>在索引列上</code>,不能使用算数运算符,算数运算也会导致索引列使用,使用全表扫描的方式进行查询.  </p>
</li>
<li><p><code>在查询数据时</code>,如果需要使用&gt;或&lt;的条件,应替换为&gt;=或&lt;=<br><code>原因是&gt;和&lt;符号,查询时是按照&gt;=和&lt;=进行查询,然后再撤去=的结果.</code>  </p>
</li>
</ol>
<h4 id="XML"><a href="#XML" class="headerlink" title="XML:"></a>XML:</h4><p>X(extensible:可扩展的)M(markup标记/标签)L(language语言)<br>可扩展标记语言  </p>
<p><strong>XML语言的作用:</strong>  </p>
<ol>
<li>普通文件太慢,所以采用xml文件保存软件中的数据.  </li>
<li>网络上传递数据.  </li>
<li>配置文件 <em>.properties,  </em>.xml  </li>
</ol>
<p><strong>XML的特点:</strong>  </p>
<ol>
<li>平台无关性, 独立的语言  </li>
<li>90%的语言都支持xml,不支持的10%语言发布的时候,xml还没出世.  </li>
<li>xml具有自我描述性(内容自定义)<br>(1)html文件中,所有标签(元素)都是官方定义好的,我们直接引用<br>(2)xml文件中,所有元素自定义</li>
</ol>
<p><strong>xml语法规则:</strong>  </p>
<ol>
<li>xml文件中必须有根元素  </li>
<li>xml标签(元素)必须有开闭  </li>
<li>xml标签(元素)对大小写敏感  </li>
<li>xml标签(元素)必须正确的嵌套  </li>
<li>xml标签(元素)的属性必须加引号(单双引都可以)  </li>
</ol>
<p><strong>xml注释方式:</strong>  </p>
<pre><code>&lt;!--xml注释--&gt;
</code></pre><p><strong>CDATA区:</strong><br>在xml中书写特殊符号时,报错,忽略其本意,编程普通字符串  </p>
<pre><code>&lt;![CDATA[xxxx]]&gt;
&lt;xx&gt;&lt;![CDATA[ 10&lt;5 ]]&gt;&lt;/xx&gt;
</code></pre><p><strong>DTD文件:</strong><br>Document Type Definition(文档类型定义)<br>DTD的目的: 帮助你编写合法的代码  (可以规范编写的代码)<br>DTD和XML之间的关系:<br>类(人类)和对象(我)的关系<br>数据库表和行(一条记录)的关系  </p>
<p><strong>XSD文件:</strong><br>xsd是xml结构定义<br>xsd是dtd的替代品,比dtd高端<br>xsd的优点:<br>xsd的代码基于xml,没有专门的语法,和xml一样的解析和处理<br>xsd支持一系列的数据类型  </p>
<p><strong>解析XML:</strong>  </p>
<p>解析xml共有四种方式:  </p>
<ol>
<li>DOM解析  </li>
<li>SAX解析  </li>
<li>JDOM解析  </li>
<li>DOM4J解析  </li>
</ol>
<p>前两种属于基础方法,是官方提供的与平台无关的解析方式;<br>后两种属于扩展方法,他们是在基础的方法之上扩展出来的,只适用于java平台.  </p>
<p><strong>DOM解析:</strong>  </p>
<ol>
<li>dom解析的原理解析xml时候,把文档中的所有元素按照期出现的层次关系,在内存中构造出树形结构.  </li>
<li>dom的有点就是可以遍历和修改节点的内容  </li>
<li>缺点是内存压力较大,解析较慢  </li>
</ol>
<p><strong>SAX解析:</strong>  </p>
<ol>
<li>是一种xml解析的替代方法  </li>
<li>相对比dom方式,sax是一种速度更快,更有效的方法  </li>
<li>不能修改节点内容  </li>
</ol>
<p><strong>JDOM解析:</strong>  </p>
<ol>
<li>仅适用具体的类,而不用接口,不灵活  </li>
</ol>
<p><strong>DOM4J:</strong>  </p>
<ol>
<li>JDOM的一种智能分支,合并了许多超出基本xml文档功能  </li>
<li>著名的底层框架hibernate就是用dom4j来解析  </li>
</ol>
<p>dom4j性能最高,其次是SAX,dom和jdom表现不好(解析10M大小的xml文件,就内存溢出了。)  </p>
<p>DOM4J解析:需要引包:  </p>
<pre><code>// 1. 加载xml文件到jvm中,形成数据流
InputStream is TestXML_1.class.getClassLoader().getResourceAsStream(&quot;test4.xml&quot;);

// 2. 创建解析对象  
SAXReader sax = new SAXReader();  

// 3. 获得文档对象(整个xml文件)[将数据流转换成一个文档对象]  
Document doc = sax.read(is);  

// 4. 获得根元素  
Element root = doc.getRootElement();  

// 5. 获得根元素下的所有子元素
List&lt;Element&gt; list = root.elements();

//System.out.println(list.size());  
//list.forEach( s -&gt; System.out.println(s));  

for(Element e1: list){
    List&lt;Element&gt; list2 = e1.elements();
    for(Element e2 : list2){
        System.out.println(e2.getName()+&quot;:&quot;+e2.getData());
    }
}
</code></pre><p><strong>常见错误:</strong>  </p>
<ol>
<li>文件位置错误: xml文件要放在src下  </li>
<li>类型引用错误</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库优化</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>11.15JAVA学习进度</title>
    <url>/2019/11/15/2019-11-15-15ribao/</url>
    <content><![CDATA[<h1 id="11-15Java学习进度"><a href="#11-15Java学习进度" class="headerlink" title="11.15Java学习进度"></a>11.15Java学习进度</h1><h4 id="JDBC事务-批处理-连接池"><a href="#JDBC事务-批处理-连接池" class="headerlink" title="JDBC事务,批处理,连接池:"></a>JDBC事务,批处理,连接池:</h4><p><strong>JDBC事务:</strong><br>在dos命令行操作oracle时,执行DML,需要结束事务(commit提交 或 rollback回退)<br>在JDBC中,事务是自动提交的,每执行一条DML语句,事务就自动提交一次<br>我们可以通过JDBC的事务API,开始事务的手动提交,将多条DML语句看作一个整体要么一起成功,要么一起失败.    </p>
<p><strong>事务特性:</strong><br>特性:  </p>
<p>事务是恢复和并发控制的基本单位。<br>事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。<br><code>原子性</code>（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。<br><code>一致性</code>（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。<br><code>隔离性</code>（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。<br><code>持久性</code>（durability）。持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。  </p>
<p><strong>JDBC事务操作格式:</strong><br>注意: 开启事务的手动提交,是通过连接对象完成的.<br>    某个数据连接对象的事务开启手动提交后,这个连接对象的事务需要手动控制,其他连接对象不受影响.<br>操作方法:  </p>
<ol>
<li><p>开始事务的手动提交:  </p>
<pre><code>conn.setAutoCommit(boolean flag);
参数含义: true表示自动提交 , false表示手动提交.
</code></pre></li>
<li><p>提交事务:  </p>
<pre><code> conn.commit();
</code></pre></li>
<li>回退事务到上次提交:  <pre><code> rollback();
</code></pre></li>
</ol>
<p><strong>预编译sql:</strong>  </p>
<pre><code>PreparedStatement prepareStatement = conn.prepareStatement(&quot;sql语句&quot;);  
</code></pre><p>注意: 方法名是<code>prepareStatement</code>,而返回类型是<code>PreparedStatement</code>  </p>
<p><strong>execute、executeUpdate区别:</strong>  </p>
<p> 不同1：  </p>
<p>execute可以执行查询语句，然后通过getResultSet，把结果集取出来。</p>
<p>executeUpdate不能执行查询语句。</p>
<p>不同2:</p>
<p>execute返回boolean类型，true表示执行的是查询语句，false表示执行的是insert,delete,update等等。</p>
<p>executeUpdate返回的是int，表示有多少条数据受到了影响。  </p>
<p><strong>批处理:</strong><br>将多条SQL语句放到一起批量处理,<br>批处理将多次对于数据库的操作次数,减少到了一次,提高了大量SQL语句一起执行时的性能.  </p>
<p>使用步骤:  </p>
<p>批处理使用Statement类操作<br>    步骤1. 将一条SQL语句加入到批处理中</p>
<pre><code>    ```
    statement.addBatch(String sql);
    ```  

步骤2. 执行批处理中的所有语句  
    ```
    Statement.executeBatch();
    ```  
</code></pre><p><strong>properties文件与类:</strong><br>常用于java的配置文件,<br>因为Properties文件 可以快速的与Properties类 进行转换.<br>里面不能中文,会被转换为Unicode编码。  </p>
<p>文件:<br>注释:  #开头表示注释行<br>键值对: 键与值之间使用等号连接,多个键值对之间使用换行分割  </p>
<p>如何将一个Properties文件,转换为java中的Map集合对象:<br>步骤:  </p>
<ol>
<li><p>创建Properties对象  </p>
<pre><code>Properties ppt = new Properties();
</code></pre></li>
<li><p>创建Properties文件的字节输入流  </p>
<pre><code>InputStream is = // 可以通过 new FileInputStream, 也可以通过ClassLoader等等  
</code></pre></li>
<li><p>将流加载到Properties对象  </p>
<pre><code>ppt.load(is);
</code></pre></li>
</ol>
<p><strong>连接池:</strong><br>有连接池创建连接,维护连接<br>我们需要使用连接是,从连接池中获取连接,<br>如果池中存在空闲连接,则拿去使用.<br>如果不存在空闲连接,且池未满,则再连接池中创建新的连接使用.<br>如果不存在空闲连接,且池已满,则排队等待空闲连接.</p>
<p>使用步骤:  </p>
<ol>
<li>引入相关的jar文件 </li>
</ol>
<ul>
<li>dbcp  : 连接池的代码  </li>
<li>poll  : 连接池的依赖库  </li>
</ul>
<ol start="2">
<li>创建一个properties文件,描述连接池的配置,内容如下:  </li>
</ol>
<ul>
<li>数据库连接地址<br>url=jdbc:oracle:thin:@localhost:1521:xe  </li>
<li>数据库驱动地址<br>driverClassName=oracle.jdbc.OracleDriver  </li>
<li>数据库账号<br>username=system  </li>
<li>数据库密码<br>password=123456  </li>
</ul>
<p><strong>扩展配置:</strong>  </p>
<ul>
<li>初始化连接池时,创建的连接数量:<br>initialSize=5  </li>
<li>最大允许存在的连接数量<br>maxActive=200  </li>
<li>空闲时允许保留的最大连接数量<br>maxIdle=10  </li>
<li>空闲时间允许保留的最小连接数量<br>minIdle=5  </li>
<li>排队等候的超时时间<br>maxWait=20000  </li>
</ul>
<ol start="3">
<li><p>将properties文件,转化为Properties对象.<br>Properties ppt = new Properties();<br>ppt.load(文件输入流);  </p>
</li>
<li><p>通过连接池工厂类(BasicDataSourceFactory),创建连接池对象(一次程序启动,创建一个连接池就够了.)<br>DataSource ds =BasicDataSourceFactory.createDataSource(ppt);  </p>
</li>
<li><p>通过连接池对象,获取池中的连接<br>Connection conn = ds.getConnection();</p>
</li>
<li><p>正常JDBC操作<br><strong>实例:</strong>  </p>
<pre><code>public class Demo {
 public static void main(String[] args) throws Exception {

     // 3. properties文件转换为Properties对象
     Properties ppt = new Properties();
     // 4. 加载文件的输入项
     InputStream is = Demo.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;);
     ppt.load(is);
     // 5. 通过工厂类床创建连接池
     DataSource ds = BasicDataSourceFactory.createDataSource(ppt);
     // 6. 通过连接池,获取其中的连接,并使用
     Connection conn = ds.getConnection();

     //正常的JDBC操作
     PreparedStatement state = conn.prepareStatement(&quot;insert into STUDENTS values (STUDENTS_STUID_SEQ.nextval,&#39;小刚&#39;,25)&quot;);
     int count = state.executeUpdate();
     System.out.println(count&gt;0?&quot;数据插入成功&quot;:&quot;数据插入失败&quot;);
 }
}
</code></pre></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JDBC事务</tag>
        <tag>SQL批处理</tag>
        <tag>连接池</tag>
      </tags>
  </entry>
  <entry>
    <title>11.14JAVA学习进度</title>
    <url>/2019/11/14/2019-11-14-14ribao/</url>
    <content><![CDATA[<h1 id="11-14Java学习进度"><a href="#11-14Java学习进度" class="headerlink" title="11.14Java学习进度"></a>11.14Java学习进度</h1><h4 id="防止sql注入-创建序列-工具类思想-配置文件思想-DAO"><a href="#防止sql注入-创建序列-工具类思想-配置文件思想-DAO" class="headerlink" title="防止sql注入,创建序列,工具类思想,配置文件思想,DAO:"></a>防止sql注入,创建序列,工具类思想,配置文件思想,DAO:</h4><p><strong>防止sql注入:</strong><br>使用PreparedStatement 替换 Statement:  </p>
<ol>
<li>可以防止拼接的sql注入, 原理就是你输入的数据不拼接,直接作为真实数据。  </li>
<li>采用预编译,会提前生成sql的执行计划,提高执行效率。  </li>
<li>拼接sql 每次sql是不同的 这回给数据库服务器的sql造成冲击,无法实现批处理。  </li>
<li>由于不拼接sql, 程序员出错的概率会降低, 提高编程质量和速度。   </li>
</ol>
<pre><code>String newSql = &quot;select from students where stuid = ?&quot;;
</code></pre><p>可以更安全的防止sql注入  </p>
<p><strong>创建序列:</strong>  </p>
<pre><code>create sequence students_stuid_seq;
</code></pre><p>一张表对应一个序列  </p>
<pre><code>String newSql = &quot;insert into students values(
    &quot;+&quot;students_stuid_seq.nextval,?,?)&quot;;
</code></pre><p><strong>工具类的思想:</strong><br>将多个文件会重复使用的类封装到一起,使用时直接调用,减少代码的复用度。  </p>
<p><strong>src路径又叫源码路径,或者类路径</strong></p>
<p><strong>一个类要得到类的加载器方法:</strong><br>类名.class.getClassLoader();</p>
<p><strong>配置文件的思想:</strong><br>将工具类中的数据提取出来额外放置,易于用户改变而不触碰源码  </p>
<p><strong>DAO思想:</strong><br>Data Access Object 数据访问对象<br>它是对数据访问过程封装的对象  </p>
<p><strong>编写DAO:</strong>  </p>
<ol>
<li>根据需求编写DAO 对应的接口  </li>
<li>使用DBUtil 工具类 结合JDBC编程得五步 实现接口中对应的方法  </li>
</ol>
<pre><code>Connection conn     连接对象
Statement state     执行环境
ResultSet result     结果集对象
</code></pre>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>工具类思想</tag>
        <tag>DAO</tag>
      </tags>
  </entry>
  <entry>
    <title>11.13JAVA学习进度</title>
    <url>/2019/11/13/2019-11-13-13ribao/</url>
    <content><![CDATA[<h1 id="11-13Java学习进度"><a href="#11-13Java学习进度" class="headerlink" title="11.13Java学习进度"></a>11.13Java学习进度</h1><h4 id="JDBC-oracle常用表结构操作-防止sql注入"><a href="#JDBC-oracle常用表结构操作-防止sql注入" class="headerlink" title="JDBC,oracle常用表结构操作,防止sql注入:"></a>JDBC,oracle常用表结构操作,防止sql注入:</h4><p><strong>JDBC访问数据库的步骤:</strong>  </p>
<ol>
<li>加载驱动  </li>
<li>获取连接 Connection  </li>
<li>定义sql 并获取sql的执行环境 Statement  </li>
<li>执行sql 处理sql 返回值<br> select 返回ResultSet 遍历<br> dml 返回int 代表影响数据行数  </li>
<li>释放资源<br> Connection Statement ResultSet  </li>
</ol>
<p><strong>oracle常用表结构操作:</strong><br>常用表结构操作</p>
<p>–添加表字段<br>   alter  table  tablename  add(columnName  columnType); </p>
<p>–删除字段的语法：<br>   alter  table  tablename  drop(columnName);</p>
<p>–修改字段名<br>   alter  table tableName rename column oldCName to newCName;</p>
<p>–修改数据类型<br>   alter  table  tableName  modify(columnName 数据类型);</p>
<p>–删除触发器<br>   drop  trigger  triggerName;</p>
<p>–删除序列<br>   drop  sequence  sequenceName;</p>
<p>–修改表名字</p>
<p>   alter  table  old_table_name  rename  to  new_table_name;</p>
<p>–修改字段为非空</p>
<p>   alter  table  tableName  modify  columnName  not  null  enable  novalidate;</p>
<p>–修改表字段为空</p>
<p>   alter  table  tableName  modify  columnName  default  null;</p>
<p><strong>防止sql注入:</strong><br>使用PreparedStatement 替换 Statement:  </p>
<ol>
<li>可以防止拼接的sql注入, 原理就是你输入的数据不拼接,直接作为真实数据。  </li>
<li>采用预编译,会提前生成sql的执行计划,提高执行效率。  </li>
<li>拼接sql 每次sql是不同的 这回给数据库服务器的sql造成冲击,无法实现批处理。  </li>
<li>由于不拼接sql, 程序员出错的概率会降低, 提高编程质量和速度。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>oracle常用表结构操作</tag>
      </tags>
  </entry>
  <entry>
    <title>11.12技术分享</title>
    <url>/2019/11/12/2019-11-12-12jishu/</url>
    <content><![CDATA[<h1 id="批处理-强制删除"><a href="#批处理-强制删除" class="headerlink" title="批处理:强制删除"></a>批处理:强制删除</h1><h4 id="批处理文件编辑"><a href="#批处理文件编辑" class="headerlink" title="批处理文件编辑:"></a>批处理文件编辑:</h4><pre><code>DEL /F /A /Q \\?\%1
RD /S /Q \\?\%1
</code></pre><p>将上边代码另存为.bat文件<br>将需要删除的文件拖到文件上就可以实现强制删除.<br>%1可以替换为特定路径,此时双击即可实现对特定路径的删除.<br>这个批处理常用于普通手段无法删除的文件  </p>
<p>另外在实际使用中可以在这两条指令后加&gt;nul，运行时将不显示命令。 </p>
<p>代码参数：</p>
<p>del 删除命令.  </p>
<p>/F 强制删除只读文件.  </p>
<p>/S 从所有子目录删除指定文件.  </p>
<p>/Q 安静模式。删除全局通配符时，不要求确认.  </p>
<p>%systemdrive% 系统文件夹，如C:\windows，有的朋友将系统装在D中，则表示D:\WINDOWS </p>
<p>%1默认为使用此批处理时输入的第一个值  </p>
<p>*.(特定文件后缀名) 指文件的通配符  </p>
<p>如<em>.tmp,</em>.log</p>
<p>全句意思是：强制删除系统文件夹下所有的格式为tmp的文件(哪怕文件是只读的)，并且在删除时不用向用户询问是否继续或终止! </p>
<p>RD [/S] [/Q] [驱动器:]路径 </p>
<p>/S 除目录本身外，还将删除指定目录下的所有子目录和<br>文件。用于删除目录树。 </p>
<p>/Q 安静模式，加 /S 时，删除目录树结构不再要求确认</p>
<hr>
<p>DEL /F /A /Q \?\%1<br>意思是以静默模式强制删除所有根目录及只读文件；<br>RD /S /Q \?\%1<br>意思是以静默模式强制删除所有子目录及文件。 </p>
<p>\?\看作一种统一路径。<br>?代表任何电脑，首先肯定搜索本地计算机，\.\把?换成.的话就表示本机了。   </p>
<p>批处理每次能处理的变量从%0—%9共10个，其中%0默认给批处理文件名使用，%1默认为使用此批处理时输入的的第一个值.  </p>
<p>同理：%2—%9指输入的第2-9个值。</p>
]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>强制删除</tag>
      </tags>
  </entry>
  <entry>
    <title>10.26JAVA学习进度</title>
    <url>/2019/10/26/2019-10-26-26ribao/</url>
    <content><![CDATA[<h1 id="10-26Java学习进度"><a href="#10-26Java学习进度" class="headerlink" title="10.26Java学习进度"></a>10.26Java学习进度</h1><h4 id="泛型机制-Queue集合-Set集合-Map集合"><a href="#泛型机制-Queue集合-Set集合-Map集合" class="headerlink" title="泛型机制,Queue集合,Set集合,Map集合:"></a>泛型机制,Queue集合,Set集合,Map集合:</h4><p><strong>泛型机制基本概念:</strong><br>通常情况下集合中可以存放不同类型的对象，本质上是将这些对象全部看做Object类型放入的，因此从集合中取出元素时也是Object类型，为了表达元素最真实的数据类型就需要强制类型转换，而强制类型转换可能发生类型转换异常。<br>为了避免上述错误的发生，从jdk1.5开始提出泛型机制，也就是在集合名称的右侧使用&lt;数据类型&gt;的方式明确要求该集合可以存放的元素类型，若放入其它类型则编译报错    </p>
<p>如：</p>
<pre><code>List lt1 = new LinkedList();   - 可以放入任意类型对象，取出麻烦
List&lt;String&gt; lt1 = new LinkedList&lt;String&gt;(); - 只能放入String类型，取出方便
</code></pre><p><strong>原理分析:</strong><br>泛型的本质就是参数化类型，也就是让数据类型作为参数传递，集合定义中的E相当于形式参数负责占位，而使用集合时&lt;&gt;中的数据类型相当于实际参数负责给形式参数初始化，当初始化完毕后所有E被替换为实际参数表示的类型进行使用。<br>由于E支持的数据类型非常广泛，因此得名为”泛型”.<br>如:</p>
<pre><code> // 其中i叫做形式参数，负责占位                
 // 其中E叫做形式参数，负责占位
   // int i = 5;    
    E = String;
   // int i = 10;
    E = Student;
   public void show(int i) {
       public interface List&lt;E&gt; {
       ...
       }
   }
   // 其中5叫做实际参数，用于给形式参数初始化
   其中String叫做实际参数
    show(5); 
    List&lt;String&gt; lt1 = ...;
    show(10);                                    
    List&lt;Student&gt; lt2 = ...;
</code></pre><p><strong>Queue集合:</strong><br><strong>基本概念:</strong>  </p>
<p>java.util.Queue集合是Collection集合的子集合，与List集合是平级关系。<br>该集合的主要实现类是：LinkedList类，因为该类在增删方面有一定的优势。<br>该集合用于描述具有先进先出特征的数据结构，叫做队列。 </p>
<p><strong>Queue接口中主要方法如下:</strong>  </p>
<table>
<thead>
<tr>
<th style="text-align:center">Queue接口的常用方法</th>
<th style="text-align:center">功能描述  </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean offer(E e)</td>
<td style="text-align:center">将一个对象添加至对位,若成功则返回true </td>
</tr>
<tr>
<td style="text-align:center"> E poll()</td>
<td style="text-align:center">从队首删除并返回一个元素  </td>
</tr>
<tr>
<td style="text-align:center"> E peek()</td>
<td style="text-align:center">返回队首的元素(但并不删除)   </td>
</tr>
</tbody>
</table>
<p><strong>Set集合:</strong><br><strong>基本概念:</strong><br>java.util.Set集合是Collection集合的子集合，与List集合以及Queue集合平级关系<br>该集合与List集合的主要区别在于：元素没有先后次序并且不允许重复的元素。<br>该集合的主要实现类有：HashSet类 和 TreeSet类。<br>其中HashSet类的底层采用哈希表进行数据管理的。<br>其中TreeSet类的底层采用二叉树进行数据管理的。  </p>
<p><strong>HashSet集合放入元素的过程:</strong><br>1.先调用元素的hashCode()方法得到哈希码,通过算法计算在哈希表中的位置。<br>2.如果该位置没有元素，直接放入即可。<br>3.如果该位置有元素，调用元素的equals()方法比较是不是相等。<br>4.如果相等，则保留旧元素丢弃新元素。<br>5.如果不相等，则放入该位置的链表中下一个元素  </p>
<p><strong>使用迭代器来访问集合中所有元素:</strong>  </p>
<pre><code>Iterator&lt;String&gt; it = s1.iterator();
while(it.hasNext()) {
    System.out.println(&quot;获取到的元素是：&quot; + it.next());
}
</code></pre><p><strong>使用StringBuilder类和迭代器实现toString方法的效果:</strong> </p>
<pre><code>// 构造StringBuilder类型的对象用于拼接
        StringBuilder sb1 = new StringBuilder();
        // 使用迭代器取出集合中的每个元素并拼接到StringBuilder对象中
        sb1.append(&quot;集合中的元素有：[&quot;);
        // 重新获取迭代器，或者叫重置迭代器[one, two, three]
        it = s1.iterator();
        while(it.hasNext()) {
            //sb1.append(it.next()).append(&quot;,&quot;).append(&quot; &quot;);
            String ts = it.next();
            // 当条件成立时证明该元素不是最后一个元素
            if(it.hasNext()) {
                sb1.append(ts).append(&quot;,&quot;).append(&quot; &quot;);
            } else {
                sb1.append(ts).append(&quot;]&quot;);
            }
        }
        // 最后多余的逗号和空格删除
        //sb1.delete(sb1.length()-2,sb1.length()).append(&quot;]&quot;);
        // 打印最终的拼接结果
        System.out.println(sb1); //[one, two, three]
</code></pre><p><strong>注意:</strong><br>当使用迭代器迭代集合中的所有元素时，若使用集合中的remove方法来删除元素，则会出现ConcurrentModificationException并发修改异常，以后的开发中应该使用迭代器的remove方法来删除元素。  </p>
<p><strong>增强版的for循环(for each结构):</strong>  </p>
<p>(1)语法格式</p>
<pre><code>   for(元素类型 变量名 : 数组名/集合名) {
      循环体;
   }
</code></pre><p>(2)执行流程<br>   不断地从数组或集合中取出一个元素并赋值给变量并执行循环体，直到处理完毕所有元素为止。  </p>
<p><strong>总结:</strong><br>遍历Set集合的方式有三种：toString()、for each结构、迭代器方式<br>遍历List集合的方式有四种：除了上述3种方式外，还有get方法。  </p>
<p><strong>Map集合基本概念:</strong>  </p>
<p>java.util.Map&lt;K,V&gt;集合中操作元素的基本单位是：单对元素，其中类型参数如下：<br>    K - 此映射所维护的键(key)的类型<br>    V - 映射值(value)的类型<br>该集合中不允许出现重复的键，每个键最多只能映射到一个值。<br>该集合的主要实现类有：HashMap类 和 TreeMap类。<br>其中HashMap类的底层是采用哈希表进行数据管理的。<br>其中TreeMap类的底层是采用二叉树进行数据管理的。  </p>
<p><strong>Map集合的遍历方式:</strong><br>迭代方式一: 迭代Key </p>
<pre><code>map = ...//初始化map
Set&lt;Character&gt; keySet = map.keySet();
for(Iterator&lt;Character&gt;i=
    keySet.iterator();i.hasNext();){
        Character key = i.next();
        Integer value = map.get(key);
        System.out.println(key+&quot;:&quot;+value);
    }
</code></pre><p>迭代方式二: 迭代Entry</p>
<pre><code>map = ...//初始化map
Set&lt;Entry&lt;Character,Integer&gt;&gt;
    entries=map.entrySet();
for(Entry&lt;Character,Integer&gt; e:entries){
    Character kry = e.getKey();
    Integer value = e.getValue();
    System.out.println(key+&quot;:&quot;+value);
}
</code></pre>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>泛型机制</tag>
        <tag>Queue集合</tag>
        <tag>Set集合</tag>
        <tag>Map集合</tag>
      </tags>
  </entry>
  <entry>
    <title>10.25JAVA学习进度</title>
    <url>/2019/10/25/2019-10-25-25ribao/</url>
    <content><![CDATA[<h1 id="10-25Java学习进度"><a href="#10-25Java学习进度" class="headerlink" title="10.25Java学习进度"></a>10.25Java学习进度</h1><h4 id="String类的常用方法-StringBuilder类和StringBuffer类-日期相关的类-Collection集合-List集合"><a href="#String类的常用方法-StringBuilder类和StringBuffer类-日期相关的类-Collection集合-List集合" class="headerlink" title="String类的常用方法,StringBuilder类和StringBuffer类,日期相关的类,Collection集合,List集合:"></a>String类的常用方法,StringBuilder类和StringBuffer类,日期相关的类,Collection集合,List集合:</h4><p><strong>String类的基本方法:</strong><br>检测字符串是否为”回文”:</p>
<pre><code>String str = &quot;上海自来水来自上海&quot;;
for(int i = 0; i&lt;str.length()/2; i++){
    if(str.charAt(i)!= str.charAt(str.length()-1-i)){
        System.out.println(&quot;不是回文&quot;);
        return;
    }
}
System.out.println(&quot;是回文&quot;);
</code></pre><p><strong>StringBuilder类和StringBuffer类:</strong>  </p>
<p>由于String类型描述的字符串内容是个常量不可更改，当程序中出现大量类似的字符串时需要单独存放从而浪费内存空间，若希望使用一块内存空间进行存储并且可以修改字符串内容，则应该使用StringBuilder类和StringBuffer类。</p>
<p>其中StringBuffer类，支持线程安全，访问的效率比较低 </p>
<p>其中StringBuilder类，不支持线程安全，访问的效率比较高    </p>
<p><strong>StringBuilder类的常用方法:</strong>  </p>
<table>
<thead>
<tr>
<th style="text-align:center">StringBuilder类的常用方法</th>
<th style="text-align:center">功能描述  </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"> StringBuilder append(String str)</td>
<td style="text-align:center">追加字符串 </td>
</tr>
<tr>
<td style="text-align:center"> StringBuilder insert(int offset,String str)</td>
<td style="text-align:center">插入字符串  </td>
</tr>
<tr>
<td style="text-align:center"> StringBuilder delete(int start, int end)</td>
<td style="text-align:center">删除字符串  </td>
</tr>
<tr>
<td style="text-align:center"> StringBuilder replace(int start, int end, String str)</td>
<td style="text-align:center">替换字符串 </td>
</tr>
<tr>
<td style="text-align:center"> StringBuilder reverse()</td>
<td style="text-align:center">字符串反转  </td>
</tr>
</tbody>
</table>
<p> <strong>日期相关的类:</strong>  </p>
<p> <strong>Date类基本概念:</strong><br> java.util.Date类用于描述特定的瞬间，可以精确到毫秒。  </p>
<p> <strong>SimpleDateFormat类基本概念:</strong><br> java.text.SimpleDateFormat类主要用于实现日期和文本之间的相关转换。  </p>
<p> <strong>Calendar类基本概念:</strong><br>java.util.Calendar类用于取代Date类来描述年月日时分秒的特定瞬间。   </p>
<p><strong>Collection集合:</strong><br><strong>集合框架:</strong><br><img src="http://zhengyupeng.top/images/Collection%E6%A1%86%E6%9E%B6.jpg" alt="Collection框架"><br><img src="http://zhengyupeng.top/images/Collection%E6%A1%86%E6%9E%B6%E8%AF%A6%E7%BB%86.jpg" alt="Collection框架详细">  </p>
<p><strong>集合的由来:</strong><br>当需要在程序中记录单个数据内容时，则声明一个变量即可；<br>当需要在程序中记录多个类型相同的数据内容时，则声明一个一维数组即可；<br>当需要在程序中记录多个类型不同的数据内容时，则构造一个对象即可；<br>当需要在程序中记录多个类型相同的对象时，则声明一个对象数组即可；<br>当需要在程序中记录多个类型不同的对象时，则声明一个集合即可；  </p>
<p><strong>集合框架结构:</strong><br>在Java语言中集合框架的顶层是：java.util.Collection集合 和 java.util.Map集合<br>其中Collection集合中操作元素的基本单位是：单个元素。<br>其中Map集合中操作元素的基本单位是：单对元素。<br>在以后的开发中很少直接使用Collection集合，而是使用该集合的子集合：List集合、Queue集合、Set集合等。  </p>
<p><strong>Collection集合基本概念:</strong><br>java.util.Collection集合是集合框架的根接口，其它接口是该接口的子接口。  </p>
<p><strong>Collection集合的常用方法:</strong>  </p>
<table>
<thead>
<tr>
<th style="text-align:center">Collection集合的常用方法</th>
<th style="text-align:center">功能描述  </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean add(E e)</td>
<td style="text-align:center">向集合中添加对象 </td>
</tr>
<tr>
<td style="text-align:center"> boolean contains(Object o)</td>
<td style="text-align:center">判断是否包含指定对象  </td>
</tr>
<tr>
<td style="text-align:center"> boolean remove(Object o)</td>
<td style="text-align:center">从集合中删除对象  </td>
</tr>
<tr>
<td style="text-align:center"> void clear()</td>
<td style="text-align:center">清空集合 </td>
</tr>
<tr>
<td style="text-align:center"> int size()</td>
<td style="text-align:center">返回包含对象的个数  </td>
</tr>
<tr>
<td style="text-align:center"> boolean isEmpty()</td>
<td style="text-align:center">判断是否为空   </td>
</tr>
</tbody>
</table>
<h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合:"></a>List集合:</h2><p><strong>基本概念:</strong><br>java.util.List集合是Collection集合的子集合，该集合中元素有先后次序且允许重复<br>该集合的主要实现类有：ArrayList类、 LinkedList类、Stack类、Vector类等。</p>
<p>其中ArrayList类的底层是采用动态数组进行数据管理，访问方便，增删不方便。  </p>
<p>其中LinkedList类的底层是采用链表进行数据管理，增删方便，访问不方便。  </p>
<p>其中Stack类主要用于描述具有后进先出特征的数据结构，叫做栈，last in first out<br>该类的底层是采用数组进行数据的管理。  </p>
<p>其中Vector类的底层采用数组进行数据的管理，与ArrayList类相比属于线程安全的类，因此效率比较低，在以后的开发中推荐使用ArrayList类取代之。</p>
<p><strong>常用的方法:</strong><br>List集合的常用方法 | 功能描述<br> :-: | :-:<br>void add(int index,E element) | 向集合中指定位置添加元素<br> boolean addAll(int index,Coolection&lt;?extends E&gt; c) | 向集合中添加所有元素<br> E get(int index) | 从集合中获取指定位置元素<br> E set(int index,E element) | 修改指定位置的元素<br> E remove(int index) | 删除指定位置的元素     </p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>String类</tag>
        <tag>Collection集合</tag>
        <tag>List集合</tag>
      </tags>
  </entry>
  <entry>
    <title>10.24JAVA学习进度</title>
    <url>/2019/10/24/2019-10-24-24ribao/</url>
    <content><![CDATA[<h1 id="10-24Java学习进度"><a href="#10-24Java学习进度" class="headerlink" title="10.24Java学习进度"></a>10.24Java学习进度</h1><h4 id="Object类-包装类和数学处理类-String类"><a href="#Object类-包装类和数学处理类-String类" class="headerlink" title="Object类,包装类和数学处理类,String类:"></a>Object类,包装类和数学处理类,String类:</h4><p><strong>Object类:</strong><br>常用的包<br>java.lang包 - 该包是Java语言中的核心包，该包中的内容由Java虚拟机自动导入<br>如：  String类、System类等<br>java.util包 - 该包是Java语言中的工具包，里面包含了大量的工具类和集合类等<br>如：Scanner类、Random类等<br>java.io包   - 该包是Java语言中的输入输出包，里面包含了大量读写文件的类等<br>如：FileOutputStream类、FileInputStream类等<br>java.net包  - 该包是Java语言中的网络包，里面包含了大量网络编程的类等<br>如：ServerSocket类、Socket类等  </p>
<p><strong>Object类基本概念:</strong><br>java.lang.Object类是所有类层次结构的根类，任何类都是该类的直接或间接子类。  </p>
<p><strong><em>Object常用的方法:</em></strong><br>Object() - 使用无参方式构造对象。<br>boolean equals(Object obj) - 用于判断调用对象是否与参数对象相等。  </p>
<ul>
<li>该方法默认比较两个对象的地址，与 == 运算符结果相同。</li>
<li>为了使得该方法比较两个对象的内容，则需要重写该方法。</li>
<li>若该方法重写后，则应该重写hashCode方法来维护  hashCode方法的常规协定  </li>
</ul>
<p>int hashCode() - 用于获取调用对象的哈希码值(内存地址的编号)。  </p>
<ul>
<li>若调用equals方法的结果相等，则各自调用hashCode方法的结果相同。 </li>
<li>若调用equals方法的结果不相等，则各自调用hashCode方法的结果不相同。</li>
<li>为了维护上述的常规协定与equals方法结果保持一致，就需要重写该方法  </li>
</ul>
<p>String toString() - 用于获取对象的字符串形式。  </p>
<ul>
<li>该方法默认返回的字符串为：包名.类名@哈希码值的十六进制形式</li>
<li>为了返回更有意义的数据内容则需要重写该方法</li>
<li>当字符串内容与引用进行连接时，自动调用toString方法</li>
<li>当使用print或println方法打印引用时，会自动调用toString方法</li>
</ul>
<p><strong>包装类和数学处理类:</strong><br>如:</p>
<pre><code>Person p = new Person();  - 声明Person类型的引用指向Person类型的对象
   int num = 10;             - 声明一个int类型的变量num初始值为10
   public class MyInteger {
      private int num = 10;
   }
   MyInteger it = new MyInteger();
</code></pre><p><strong>包装类的概念:</strong><br>由于Java语言是一门纯面向对象编程语言，而8种基本数据类型声明的变量并不是对象，为了满足Java语言的特性就需要对这些变量进行对象化处理，而实现该功能的相关类就叫做包装类。  </p>
<p><strong>包装类的分类:</strong><br>int  =&gt; java.lang.Integer类<br>char =&gt; java.lang.Character类<br>其它类型对应的包装类就是将首字母变成大写  </p>
<p><strong>Integer类基本概念:</strong><br>(1)基本概念<br>   java.lang.Integer类是int类型的包装类，里面包含了一个int类型的成员变量。<br>   该类由final关键字修饰表示不能被继承。</p>
<p>(2)常用的方法<br>   Integer(int value) - 根据参数指定的整数构造对象<br>   Integer(String s) - 根据参数指定的字符串构造对象<br>   该类重写了equals()、hashCode()、toString()方法<br>   int intValue() - 用于获取调用对象中的整数数据并返回。<br>   static Integer valueOf(int i) - 根据参数指定的整数返回对应的Integer对象。<br>   static int parseInt(String s) - 用于将String类型转换为int类型并返回。  </p>
<p><strong>BigDecimal类:</strong><br><strong>BigDecimal类基本概念:</strong><br>由于float类型和double类型的运算可能会有误差，为了实现精确运算则需要借助java.math.BigDecimal类型加以描述。   </p>
<p><strong>BigDecimal类常用方法:</strong><br>BigDecimal(String val) - 根据参数指定的字符串构造对象。<br>BigDecimal add(BigDecimal augend) - 用于计算调用对象和参数对象的和并返回<br>BigDecimal subtract(BigDecimal subtrahend) - 用于计算调用对象和参数对象的差并返回。<br>BigDecimal multiply(BigDecimal multiplicand) - 用于计算调用对象和参数对象的积并返回。<br>BigDecimal divide(BigDecimal divisor) - 用于计算调用对象和参数对象的商并返回。  </p>
<p><strong>String类:</strong><br><strong>String类基本概念:</strong>  </p>
<p>java.lang.String类用于描述字符串，Java应用程序中所有字符串字面值都可以作为String类型的对象加以描述，如：”abc”等。<br>   该类描述的字符串内容是个常量，一旦创建完毕后则不能更改，因此可以被共享。</p>
<p><strong>常量池:</strong><br>由于String类型描述的字符串内容是个常量不可改变，因此Java虚拟机提供了一个常量池，当Java程序中出现字符串内容时就放入常量池中，若后续出现重复的字符串内容则直接使用池中已有的对象而不需再次创建，从而提高了性能。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Object类,</tag>
        <tag>包装类和数学处理类,</tag>
        <tag>String类</tag>
      </tags>
  </entry>
  <entry>
    <title>10.23JAVA学习进度</title>
    <url>/2019/10/23/2019-10-23-23ribao/</url>
    <content><![CDATA[<h1 id="10-23Java学习进度"><a href="#10-23Java学习进度" class="headerlink" title="10.23Java学习进度"></a>10.23Java学习进度</h1><h4 id="访问控制-final关键字-多态-抽象类-接口-匿名内部类"><a href="#访问控制-final关键字-多态-抽象类-接口-匿名内部类" class="headerlink" title="访问控制,final关键字,多态,抽象类,接口,匿名内部类:"></a>访问控制,final关键字,多态,抽象类,接口,匿名内部类:</h4><p><strong>访问控制:</strong><br>常用的访问控制符 访问控制符 访问权限 本类 本包中的类 子类 其它包中的其它类</p>
<hr>
<pre><code> public       公有的      ok        ok        ok          ok  
 protected    保护的      ok        ok        ok          no
 啥也不写      默认的      ok        ok        no          no
 private      私有的      ok        no        no          no
</code></pre><p>a.public修饰的内容可以在任意位置使用；<br>b.private修饰的内容只能在本类中使用；<br>c.通常情况下，成员变量都使用private修饰，成员方法都使用public修饰；</p>
<p><strong>final关键字:</strong><br>基本概念:<br>final本意为”最终的，不可更改的”，该关键字可以修饰类、成员方法、成员变量等。<br>使用方式:<br>final关键字修饰类表示该类不能被继承。 </p>
<ul>
<li>为了防止滥用继承带来的危害</li>
<li>如：java.lang.String类等  </li>
</ul>
<p>final关键字修饰成员方法表示该方法不能被重写但可以被继承。</p>
<ul>
<li>为了防止不经意间造成的方法重写</li>
<li>如：java.text.DateFormat类中的format方法等  </li>
</ul>
<p>final关键字修饰成员变量表示该成员变量必须初始化而且不能更改。  </p>
<ul>
<li>为了防止不经意间造成数值的更改。</li>
<li>如：java.lang.Thread类中的MAX_PRIORITY等  </li>
</ul>
<blockquote>
<p>扩展:<code>在以后的开发中很少单独使用static关键字或final关键字修饰成员变量，通常都是使用public static final共同修饰成员变量来表达常量的含义。  常量的命名规则是：要求所有字母大写，不同单词之间采用下划线连接，如：
   public static final double PI = 3.14;</code></p>
</blockquote>
<p><strong>多态:</strong><br>基本概念:<br>多态主要指同一种事物表现出来的多种形态。<br>语法格式:<br>父类类型 引用变量名 = new 子类类型();<br>如：</p>
<pre><code>   Person pw = new Worker();
   pw.show();
</code></pre><p>解析：  </p>
<p>编译阶段调用Person类中show方法，在运行阶段调用Worker类中重写以后的show方法  </p>
<p>多态的效果  </p>
<p>(1)当父类的引用指向子类的对象时，父类的引用可以直接调用父类独有的方法；<br>(2)当父类的引用指向子类的对象时，父类的引用不可以直接调用子类独有的方法；<br>(3)对于父子类都有的非静态成员方法来说，编译阶段调用父类版本，运行阶段调用子类重写以后的版本；<br>(4)对于父子类都有的静态方法来说，编译和运行阶段调用父类版本，隶属于类层级，因此与指向的对象无关；  </p>
<p><strong>引用数据类型之间的转换:</strong>  </p>
<p>(1)引用数据类型之间的转换分为：自动类型转换和强制类型转换。  </p>
<p>其中自动类型转换主要指从小范围到大范围之间的转换，也就是子类到父类的转换<br>其中强制类型转换主要指从大范围到小范围之间的转换，也就是父类到子类的转换  </p>
<p>(2)引用数据类型之间的转换必须发生在父子类之间，否则编译报错。<br>(3)若转换到的目标类型是子类类型但不是该引用真正指向的子类类型，则编译通过，运行阶段发生类型转换异常。<br>(4)为了避免上述错误的发生，可以使用instanceof进行判断，具体格式如下：<br>if(引用变量名 instanceof 数据类型) - 判断引用变量指向的对象是否为后面类型</p>
<p><strong>多态的意义:</strong>  </p>
<p>多态的实际意义在于可以屏蔽不同子类的差异性实现通用的编程，但可以调用不同的方法带来不同的结果。  </p>
<p><strong>抽象类的概念:</strong><br>抽象方法的概念<br>抽象方法就是指不能具体实现的方法，也就是没有方法体并使用abstract关键字修饰  </p>
<p>语法格式：<br>访问控制符 abstract 返回值类型 方法名称(形参列表);<br>如：  </p>
<pre><code>  public abstract void cry();  
</code></pre><p><strong>注意事项:</strong>  </p>
<p>(1)抽象类中可以有成员变量、构造方法以及成员方法；<br>(2)抽象类中可以有抽象方法也可以没有抽象方法；<br>(3)拥有抽象方法的类必须是抽象类，因此严格来说，具有抽象方法并且使用abstract关键字修饰的类才算真正意义上的抽象类。  </p>
<p><strong>实际意义:</strong><br>抽象类的意义不在于自身创建对象而在于被继承，当一个类继承抽象类后必须重写抽象类中的抽象方法，否则该类也变成抽象类。<br>也就是说抽象类对子类具有强制性和规范性，因此叫做模板设计模式。</p>
<p><strong>经验：</strong><br>在以后的开发中推荐使用多态的语法格式，当父类的引用指向子类的对象时，那么父类引用直接调用的所有方法一定是父类拥有的方法，若希望更换子类时，只需要将new关键字后面的类型修改而其它地方无需更改立即生效，从而提高了代码的可维护性。<br>该方式的缺点就是：父类引用不能直接访问子类独有的方法，若访问则需要强转。   </p>
<p><strong>接口基本概念:</strong><br>接口就是一种比抽象类还抽象的类，体现为所有成员方法都是抽象方法。<br>定义类的关键字是class，而定义接口的关键字是interface。<br>继承类的关键字是extends，而实现接口的关键字是implements。<br><strong>类和接口之间的关系:</strong><br>类和类之间的关系:      使用extends关键字表达继承的关系     支持单继承<br>类和接口之间的关系:    使用implemets关键字表达实现的关系   支持多实现<br>接口和接口之间的关系:  使用extends关键字表达继承的关系     支持多继承    </p>
<p><strong><em>抽象类和接口之间的区别(笔试题):</em></strong><br>(1)定义抽象类的关键字是abstract class，而定义接口的关键字是interface。<br>(2)继承抽象类的关键字是extends，而实现接口的关键字是implements。<br>(3)继承抽象类支持单继承，而实现接口可以多实现。<br>(4)抽象类中可以有构造方法，而接口中不可以有构造方法。<br>(5)抽象类中可以有成员变量，而接口中只可以有常量。<br>(6)抽象类中可以有成员方法，而接口中只可以有抽象方法。<br>(7)抽象类中增加方法可以不影响子类，而接口中增加方法通常都影响子类。<br>(8)从jdk1.8开始允许接口中出现非抽象方法，但需要使用default关键字修饰。  </p>
<p><strong>匿名内部类:</strong><br>语法格式:</p>
<pre><code>接口/父类类型 引用变量名 = new 接口/父类类型(){ 方法的重写 };
</code></pre><p><strong>经验的分享:</strong><br>当接口类型的引用作为方法的形参时，实参的传递方式有两种：<br>a.自定义类实现接口，然后创建该类的对象作为实参传递；<br>b.使用匿名内部类的语法格式来得到接口类型的引用作为实参传递；   </p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>访问控制</tag>
        <tag>关键字</tag>
        <tag>接口</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>10.22JAVA学习进度</title>
    <url>/2019/10/22/2019-10-22-22ribao/</url>
    <content><![CDATA[<h1 id="10-22Java学习进度"><a href="#10-22Java学习进度" class="headerlink" title="10.22Java学习进度"></a>10.22Java学习进度</h1><h4 id="封装-static关键字-单例设计模式-继承与方法的重写"><a href="#封装-static关键字-单例设计模式-继承与方法的重写" class="headerlink" title="封装,static关键字,单例设计模式,继承与方法的重写:"></a>封装,static关键字,单例设计模式,继承与方法的重写:</h4><p><strong>封装基本概念:</strong><br>为了避免对成员变量的赋值合法但是不合理,与现实生活不符,为了避免这种现象采用封装.<br>封装可以保证成员变量的合理性.</p>
<p><strong>封装的实现流程:</strong><br>(1)私有化成员变量，使用private关键字修饰；<br>(2)提供公有的get和set方法，在方法体中进行合理值的判断；<br>(3)在构造方法中调用set方法进行合理值的判断；<br><strong><em>对于封装的实现,大框架可以在编译器里实现:</em></strong><br><em>(1)eclipse中用右键-Source(alt+shift+s)中的带Generate的一些选项实现</em><br><em>(2)idea中用右键-Generate…(alt+insert)选项中选项实现</em></p>
<p><strong>static关键字:</strong><br>使用static关键字修饰成员变量表达静态的含义，该成员变量由对象层级提升为类层级被所有对象共享，该成员变量随着类的加载准备就绪，与是否创建对象无关。<br>static关键字就是把对象级提高到类级,在<code>类加载</code>时就准备完成了,而不需要创建对象(new)。<br>静态的成员(属性和方法)可以用 对象. 调用,但是一般推荐用 类名. 调用  </p>
<p><strong>类加载只做一次,包括:</strong><br>(1)类名. 时会类加载.<br>(2)new对象 时会类加载.<br>(3)程序员可以用程序加载,比如Class.forName()</p>
<p><strong>使用方式:</strong><br>(1)在非静态的成员方法中既能访问非静态的成员也能访问静态的成员；<br>(成员：成员变量 + 成员方法， 静态成员被所有对象共享)<br>(2)在静态的成员方法中只能访问静态的成员不能访问非静态的成员；<br>(成员：成员变量 + 成员方法， 调用静态方法时可能还没有创建对象)<br>(3)只有隶属于类层级被所有对象共享的内容才可以使用static修饰；<br>(不能滥用static关键字)</p>
<p><strong>单例设计模式:</strong><br>(1)基本概念<br>   在某些特殊场合中一个类对外提供且只提供一个对象，这样的类叫做单例类。<br>   而设计单例类的思想和模式叫做单例设计模式，主要用于固定的场合。</p>
<p>(2)实现流程<br>   a.私有化构造方法，使用private关键字修饰；<br>   b.声明本类类型的引用指向本类类型的对象，使用private static共同修饰；<br>   c.提供公有的get方法负责将成员变量的数值返回出去，使用static关键字修饰；  </p>
<p>(3)实现方式<br>   单例设计模式的实现方式有两种：饿汉式 和 懒汉式，在以后的开发中推荐饿汉式。</p>
<pre><code>public class Singleton {

    // 2.提供本类类型的引用指向本类类型的对象
    // Person p = new Person();
    private static Singleton sin = new Singleton(); //饿汉式
    private static Singleton sin = null;            //懒汉式

    // 1.私有化构造方法，使用private关键字修饰
    // private修饰构造方法表示该方法只能在本类的内部使用
    private Singleton(){}

    // 3.提供公有的get方法负责将成员变量返回出去
    public static Singleton getInstance() {
        //return sin;
        if(null == sin) {
            sin = new Singleton();
        }
        return sin;
    }
}
</code></pre><p><strong>继承的基本概念:</strong><br>当多个类之间有相同的特征和行为时，可以将相同的内容提取出来组成一个公共类，让多个类吸收公共类中已有特征和行为而在多个类的内部编写自己独有特征和行为的方式，叫做继承。<br>使用继承可以提高代码的复用性和扩展性以及可维护性。<br>在Java语言中使用extends(扩展)关键字来表达继承关系。  </p>
<p>如：<br>   public class Student extends Person {}  - 表示Student类继承自Person类<br>   其中Person类叫做基类、父类、超类<br>   其中Student类叫做派生类、子类、孩子类    </p>
<p><strong><em>注意事项:</em></strong>  </p>
<p>(1)子类可以继承父类的成员变量和成员方法，其中私有成员变量可以继承但不可以直接使用，子类不可以继承父类的构造方法和私有方法。<br>(2)无论使用何种方式构造子类对象时，都会自动调用父类中的无参构造方法来初始化从父类中继承下来的成员变量，相当于在子类构造方法第一行增加代码:super()的效果。<br>(3)Java语言中只支持单继承不支持多继承，也就是一个子类只能有一个父类，但一个父类可以有多个子类。</p>
<p><strong>方法的重写(override):</strong><br>(1)基本概念<br>   若从父类中继承下来的方法不满足子类的需求时，就需要在子类中重新写一个与父类中一样的方法来覆盖从父类中继承的版本，这种方式就叫做重写。</p>
<p>(2)重写的原则(笔试题)<br>  a.要求方法名相同、参数列表相同、返回值类型相同，从jdk1.5开始允许返回子类类型<br>  b.要求方法的访问权限不能变小，可以相同或者变大。<br>  c.要求不能抛出更大的异常(异常机制)。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>封装</tag>
        <tag>static关键字</tag>
        <tag>继承与方法的重写</tag>
        <tag>单例设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>10.21JAVA学习进度</title>
    <url>/2019/10/21/2019-10-21-21ribao/</url>
    <content><![CDATA[<h1 id="10-21Java学习进度"><a href="#10-21Java学习进度" class="headerlink" title="10.21Java学习进度"></a>10.21Java学习进度</h1><h4 id="封装-static关键字-单例设计模式"><a href="#封装-static关键字-单例设计模式" class="headerlink" title="封装,static关键字,单例设计模式:"></a>封装,static关键字,单例设计模式:</h4><p><strong>封装基本概念:</strong><br>为了避免对成员变量的赋值合法但是不合理,与现实生活不符,为了避免这种现象采用封装.<br>封装可以保证成员变量的合理性.</p>
<p><strong>封装的实现流程:</strong><br>(1)私有化成员变量，使用private关键字修饰；<br>(2)提供公有的get和set方法，在方法体中进行合理值的判断；<br>(3)在构造方法中调用set方法进行合理值的判断；<br><strong><em>对于封装的实现,大框架可以在编译器里实现:</em></strong><br><em>(1)eclipse中用右键-Source(alt+shift+s)中的带Generate的一些选项实现</em><br><em>(2)idea中用右键-Generate…(alt+insert)选项中选项实现</em></p>
<p><strong>static关键字:</strong><br>使用static关键字修饰成员变量表达静态的含义，该成员变量由对象层级提升为类层级被所有对象共享，该成员变量随着类的加载准备就绪，与是否创建对象无关。<br>static关键字就是把对象级提高到类级,在<code>类加载</code>时就准备完成了,而不需要创建对象(new)。<br>静态的成员(属性和方法)可以用 对象. 调用,但是一般推荐用 类名. 调用  </p>
<p><strong>类加载只做一次,包括:</strong><br>(1)类名. 时会类加载.<br>(2)new对象 时会类加载.<br>(3)程序员可以用程序加载,比如Class.forName()</p>
<p><strong>使用方式:</strong><br>(1)在非静态的成员方法中既能访问非静态的成员也能访问静态的成员；<br>(成员：成员变量 + 成员方法， 静态成员被所有对象共享)<br>(2)在静态的成员方法中只能访问静态的成员不能访问非静态的成员；<br>(成员：成员变量 + 成员方法， 调用静态方法时可能还没有创建对象)<br>(3)只有隶属于类层级被所有对象共享的内容才可以使用static修饰；<br>(不能滥用static关键字)</p>
<p><strong>单例设计模式:</strong><br>(1)基本概念<br>   在某些特殊场合中一个类对外提供且只提供一个对象，这样的类叫做单例类。<br>   而设计单例类的思想和模式叫做单例设计模式，主要用于固定的场合。</p>
<p>(2)实现流程<br>   a.私有化构造方法，使用private关键字修饰；<br>   b.声明本类类型的引用指向本类类型的对象，使用private static共同修饰；<br>   c.提供公有的get方法负责将成员变量的数值返回出去，使用static关键字修饰；  </p>
<p>(3)实现方式<br>   单例设计模式的实现方式有两种：饿汉式 和 懒汉式，在以后的开发中推荐饿汉式。</p>
<pre><code>public class Singleton {

    // 2.提供本类类型的引用指向本类类型的对象
    // Person p = new Person();
    private static Singleton sin = new Singleton(); //饿汉式
    private static Singleton sin = null;            //懒汉式

    // 1.私有化构造方法，使用private关键字修饰
    // private修饰构造方法表示该方法只能在本类的内部使用
    private Singleton(){}

    // 3.提供公有的get方法负责将成员变量返回出去
    public static Singleton getInstance() {
        //return sin;
        if(null == sin) {
            sin = new Singleton();
        }
        return sin;
    }
}
</code></pre><p><strong>继承的基本概念:</strong><br>当多个类之间有相同的特征和行为时，可以将相同的内容提取出来组成一个公共类，让多个类吸收公共类中已有特征和行为而在多个类的内部编写自己独有特征和行为的方式，叫做继承。<br>   使用继承可以提高代码的复用性和扩展性以及可维护性。<br>   在Java语言中使用extends(扩展)关键字来表达继承关系。  </p>
<p>如：<br>   public class Student extends Person {}  - 表示Student类继承自Person类<br>   其中Person类叫做基类、父类、超类<br>   其中Student类叫做派生类、子类、孩子类  </p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>封装</tag>
        <tag>static关键字</tag>
        <tag>单例设计</tag>
      </tags>
  </entry>
  <entry>
    <title>10.19JAVA学习进度</title>
    <url>/2019/10/19/2019-10-19-19ribao/</url>
    <content><![CDATA[<h1 id="10-19Java学习进度"><a href="#10-19Java学习进度" class="headerlink" title="10.19Java学习进度"></a>10.19Java学习进度</h1><h4 id="构造方法-方法重载-this关键字-方法的传参和调用"><a href="#构造方法-方法重载-this关键字-方法的传参和调用" class="headerlink" title="构造方法,方法重载,this关键字,方法的传参和调用:"></a>构造方法,方法重载,this关键字,方法的传参和调用:</h4><p><strong>学习了构造方法的概念和使用</strong><br>无参和有参构造方法的使用</p>
<p><strong>方法的重载概念和体现形式</strong><br>几个类的方法名相同,参数列表不同,就是重载<br>在创建对象时候会根据不同参数调用不同构造方法  </p>
<p><strong>this关键字的使用方式,原理:</strong><br>在构造方法中代表当前正在构造的对象<br>在成员方法中代表当前正在调用的对象   </p>
<p><em>使用方式:</em><br>(1)当形参变量和成员变量同名是,在构造方法或成员方法中通常优先使用形参变量,若希望使用成员变量就需要在变量名的前面加上<code>this.</code>进行说明<br>(2)在构造方法的第一行使用<code>this</code>(实参)的方式可以调用本类中的其他构造方法</p>
<p><strong>this关键字的作用:</strong><br>所有成员变量不能重名,再同一区域的局部变量不能重名,但是成员变量可以重命名.<br>在局部变量的作用区域外,变量名代表成员变量,在局部变量的作用域之间,代表局部变量,如果想使用成员变量,需要<code>this.</code>的方式访问  </p>
<p>在方法中可以通过调用关键字表示”调用该方法的那个对象”.  </p>
<p><strong>this关键字和空值:</strong><br>引用类型变量用于存放对象的地址,可以给引用类型赋值为null,表示不指向任何对象.<br>当某个引用类型变量为null时无法对对象实施访问,<br>此时通过引用访问成员变量或调用方法会产生<code>NullPointerException</code>异常(空指针异常)</p>
<p><strong>方法的传参和递归调用:</strong><br><em>方法的传参过程:</em><br>(1)main方法是程序的入口，为main方法中的局部变量开辟内存空间并初始化；<br>(2)调用max方法时为max方法的形参变量开辟内存空间；<br>(3)使用实参变量给形参变量进行赋值操作，执行max方法的方法体；<br>(4)当max方法结束后释放形参变量的内存空间；<br>(5)main方法中的res得到max方法的返回值然后继续向下执行；<br>(6)当main方法结束后释放局部变量的内存空间；</p>
<p><code>a.当基本数据类型的变量作为方法的参数传递时，形参变量的改变不会影响到实参;</code><br><code>b.当引用数据类型的变量作为方法的参数传递时，形参变量指向的内容发生改变后会影响到实参变量指向的内容；</code><br><code>c.当引用数据类型的变量作为方法的参数传递时，形参变量改变指向后再改变指向的内容时不会影响到实参变量指向的内容；</code></p>
<p><em>递归调用:</em>  </p>
<h3 id="调用方法的本质就是根据方法名跳过去"><a href="#调用方法的本质就是根据方法名跳过去" class="headerlink" title="调用方法的本质就是根据方法名跳过去"></a>调用方法的本质就是根据方法名跳过去</h3><p>(1)基本概念:<br>方法叫做递归。<br>如：</p>
<pre><code>   void show(){
      show();
   }
</code></pre><p>案例：<br>   自定义成员方法实现参数n阶乘的计算并返回。  </p>
<p>解析：</p>
<pre><code>   5! = 5 * 4 * 3 * 2 * 1;
   4! = 4 * 3 * 2 * 1;
   3! = 3 * 2 * 1;
   2! = 2 * 1;
   1! = 1;

   n! = n * (n-1) * (n-2) * ... * 1;

   5! = 5 * 4!;
   4! = 4 * 3!;
   3! = 3 * 2!;
   2! = 2 * 1!;
   1! = 1;

   n! = n * (n-1)!;
</code></pre><p><strong>递推:</strong></p>
<pre><code>int show(int n){
    int res = 1;
    for(int i = n; i &gt; 1; i--){
        res *=i;
    }
    return res;
}
</code></pre><p><strong>递归:</strong>  </p>
<pre><code>if(1 == n){
    return 1;
}
return n * show(n-1); 
</code></pre><p><strong>(2)注意事项:</strong>  </p>
<p>a.必须找到递归的规律和退出条件；<br>b.使用递归使得问题简单化而不是复杂化；<br>c.若递归影响到程序的执行性能则使用递推取代之；</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>构造方法,方法重载</tag>
        <tag>this关键字</tag>
        <tag>方法的传参和调用</tag>
      </tags>
  </entry>
  <entry>
    <title>10.18JAVA学习进度</title>
    <url>/2019/10/18/2019-10-18-18ribao/</url>
    <content><![CDATA[<h1 id="10-18Java学习进度"><a href="#10-18Java学习进度" class="headerlink" title="10.18Java学习进度"></a>10.18Java学习进度</h1><h4 id="数组元素之间的操作-号码的生成和去重-面向对象的基本概念和三大特征-了解了类和对象的概念"><a href="#数组元素之间的操作-号码的生成和去重-面向对象的基本概念和三大特征-了解了类和对象的概念" class="headerlink" title="数组元素之间的操作,号码的生成和去重,面向对象的基本概念和三大特征,了解了类和对象的概念:"></a>数组元素之间的操作,号码的生成和去重,面向对象的基本概念和三大特征,了解了类和对象的概念:</h4><p>学习了数组元素之间的拷贝  </p>
<p>统计拆分的原理和实现:求出一串数字各数字出现的次数  </p>
<p>双色球号码的生成和去重<br>去重方法:<br>当前元素与之前元素对比如果有相同的就使用i– 再重新生成一遍当前数组下标的元素  </p>
<p>面向对象的基本概念:<br>万物皆对象!!<br>面向对象就是指以特征和行为的观点去分析现实事物的方式  </p>
<p>c语言是面向过程<br>c++是既面向过又面向对象<br>java是面向对象</p>
<p>面向对象编程的三大特征:<br>封装、继承、多态</p>
<p>了解了对象和类的概念</p>
<p>类的定义:</p>
<pre><code>class 类名{

}
</code></pre><p>成员变量定义的语法格式:</p>
<pre><code>class 类名{
    数据类型 成员变量名 = 初始值;(初始值通常省略)
}
</code></pre><p>对象的创建:</p>
<pre><code>new 类名();
</code></pre><p>对象的引用:(例)</p>
<pre><code>new Person();

Person p = new Person();
</code></pre><p>成员方法:</p>
<pre><code>class 类名{
    返回值类型 成员方法名(形参列表){
        成员方法体
    }
}
</code></pre><p>(例):</p>
<pre><code>class Person{
    viod show(){
        System.out.println(&quot;测试&quot;);
    }
}
</code></pre><p>(返回数据类型要与形参列表相同)  </p>
<p>成员方法的调用:<br>p.show();</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数组元素之间的操作</tag>
        <tag>号码的生成和去重</tag>
        <tag>面向对象的基本概念和三大特征</tag>
        <tag>了解了类和对象的概念</tag>
      </tags>
  </entry>
  <entry>
    <title>10.17JAVA学习进度</title>
    <url>/2019/10/17/2019-10-17-17ribao/</url>
    <content><![CDATA[<h1 id="10-17Java学习进度"><a href="#10-17Java学习进度" class="headerlink" title="10.17Java学习进度"></a>10.17Java学习进度</h1><h3 id="对java的简单了解和入门-简单的逻辑结构和循环结构-简单的数组操作"><a href="#对java的简单了解和入门-简单的逻辑结构和循环结构-简单的数组操作" class="headerlink" title="对java的简单了解和入门,简单的逻辑结构和循环结构,简单的数组操作"></a>对java的简单了解和入门,简单的逻辑结构和循环结构,简单的数组操作</h3><p>第一课:</p>
<p>了解了java的历史<br>看了基础的helloworld打印</p>
<p>第二课:</p>
<p>学习了变量<br>进制转换<br>还有各种数据类型</p>
<p>第三课:<br>学习了各种关系运算符,算数运算符<br>三目运算符<br>If else结构</p>
<p>第四课:<br>学习了循环结构,for循环嵌套<br>While循环</p>
<p>第五课:</p>
<p>学习了数组的操作,增删改查,<br>二维数组的操作</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>对java的简单了解和入门</tag>
        <tag>简单的逻辑结构和循环结构</tag>
        <tag>简单的数组操作</tag>
      </tags>
  </entry>
  <entry>
    <title>10.14</title>
    <url>/2019/10/14/2019-10-14-14jishu/</url>
    <content><![CDATA[<h1 id="看板娘代码"><a href="#看板娘代码" class="headerlink" title="看板娘代码:"></a>看板娘代码:</h1><pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;/&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt;
</code></pre>]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>看板娘</tag>
      </tags>
  </entry>
  <entry>
    <title>10.13</title>
    <url>/2019/10/13/2019-10-13-13jishu/</url>
    <content><![CDATA[<h1 id="今天发现了一个时间小人的特效-很有意思"><a href="#今天发现了一个时间小人的特效-很有意思" class="headerlink" title="今天发现了一个时间小人的特效 很有意思:"></a>今天发现了一个时间小人的特效 很有意思:</h1><pre><code>&lt;div&gt;
&lt;embed wmode=&quot;transparent&quot; src=&quot;http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.swf&quot; quality=&quot;high&quot; bgcolor=&quot;#ffffff&quot; width=&quot;160&quot; height=&quot;70&quot; name=&quot;honehoneclock&quot; align=&quot;middle&quot; allowscriptaccess=&quot;always&quot; type=&quot;application/x-shockwave-flash&quot; pluginspage=&quot;http://www.macromedia.com/go/getflashplayer&quot;&gt;
&lt;/div&gt;
</code></pre><p>或者:  </p>
<pre><code>&lt;script charset=&quot;Shift_JIS&quot; src=&quot;http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.js&quot;&gt;&lt;/script&gt;
</code></pre>]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>小人特效</tag>
      </tags>
  </entry>
  <entry>
    <title>9.27技术分享</title>
    <url>/2019/09/27/2019-09-27-27jishu/</url>
    <content><![CDATA[<h1 id="今天发现了git克隆下来的远程库特别大"><a href="#今天发现了git克隆下来的远程库特别大" class="headerlink" title="今天发现了git克隆下来的远程库特别大:"></a>今天发现了git克隆下来的远程库特别大:</h1><p>经过查询之后发现是每次推送之后都会留下记录缓存，这样很多没用的记录就会占用多余的空间，别人克隆的时候也会多耗费时间，今天我查到了一个清除无用记录的方法。</p>
<blockquote>
<p>首先进入你的本地库</p>
</blockquote>
<p>cd zhengyupengzz.github.io</p>
<blockquote>
<p>新建并切换到一个分支</p>
</blockquote>
<p>git checkout –orphan latest_branch</p>
<blockquote>
<p>选中全部文件</p>
</blockquote>
<p>git add -A</p>
<blockquote>
<p>提交</p>
</blockquote>
<p>git commit -am “Reinitialize”</p>
<blockquote>
<p>删除原分支</p>
</blockquote>
<p>git branch -D master</p>
<blockquote>
<p>将本分支改为原分支名</p>
</blockquote>
<p>git branch -m master</p>
<blockquote>
<p>推送到远程分支</p>
</blockquote>
<p>git push -f origin master</p>
<blockquote>
<p>现在你再去GitHub上去看提交分支的记录，会发现只有一次提交了</p>
</blockquote>
<blockquote>
<p>可以删除本地库重新将远程库克隆下来，这次就没有那些多余的提交记录了！</p>
</blockquote>
<p><a href="https://blog.csdn.net/yolohohohoho/article/details/90607229" target="_blank" rel="noopener">参考博客地址</a></p>
]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>git清理</tag>
      </tags>
  </entry>
  <entry>
    <title>9.27七十周年心得</title>
    <url>/2019/09/27/2019-09-27-27xinde/</url>
    <content><![CDATA[<h1 id="今天看了很多关于国家的视频-发现这七十年发展的是真不容易"><a href="#今天看了很多关于国家的视频-发现这七十年发展的是真不容易" class="headerlink" title="今天看了很多关于国家的视频,发现这七十年发展的是真不容易"></a>今天看了很多关于国家的视频,发现这七十年发展的是真不容易</h1><p>70年的风雨征程，带来了祖国繁荣强大，如同阳光照亮了我们的前程，指明了我们前进的方向，带领全国各族人民从贫穷走向富裕，从胜利走向辉煌。</p>
<p>　　中华人民共和国国旗旗面为红色象征革命。旗上的五颗五角星及其相互关系象征共产党领导下的革命人民大团结。星用黄色是为着在红地上显出光明，四颗小五角星各有一角正对着大星的中心点，表示围绕着一个中心而团结。每逢国庆，去天安门广场看升国旗是无数人心中的梦想。因此，利用国庆长假去北京游玩的人们，通常会赶早来到天安门广场看国旗班的军人升旗，以表达对祖国的无比热爱，看着五星红旗徐徐升起，心中的激动无以言表。每年10月1日是我国的国庆节，我国于1999年修订发布《全国年节及纪念日放假办法》，将国庆节与相邻的周六、日组合为7天的国庆长假，被称之为“国庆黄金周”，用放假的形式，让老百姓共同感受国庆的欢乐。</p>
<p>　　回首这70年，中华人民走得每一步都是步履蹒跚，每一步都付出了巨大牺牲。但是如今中国经过几十年来的艰苦建设，已取得了“乘长风，破万里浪”的迅猛发展:《辉煌中国》之《圆梦工程》透过港珠澳大桥、胡麻岭隧道、郑万铁路、复兴号、上海洋山港自动化码头、中国移动互联网等一个个超级工程，领略五年来一张张中国基础建设的大网，如何编织起人民走向幸福、美好的希望版图，托举起中华民族伟大复兴的中国梦。</p>
<p>面对飘扬的国旗亿万双眼睛注视五星红旗冉冉升起,亿万颗心灵伴随祖国母亲一起搏动。抬头仰望,发现鲜艳的国旗已在共和国的上空飘扬了半个世纪。在世纪之交的今天,共和国已走过了七十个春秋。七十年前，”洋油” ”洋面” 还充斥着中国的大江南北;七十年后，许多国产已遍及世界各地。</p>
<p>七十年前,我们的祖先还把汉代的耕梨插进二十世纪的农田;七十年后,现代化机械已开进中国的农家。<br>七十年前,港澳游子还站在金门望厦门;五十年后,归国侨胞已站在厦门望金门。-样的遥望,却是两样的情形。<br>七十年里，萧瑟秋风今又是，换了人间。</p>
<p>依旧淳朴中隐着聪慧,荒中透着俊季，可再也听不见那血泪凝结的叹息,更也找不到贫贱不堪的足印，再也寻不见你昔日枯瘦蹒跚的身影,麦穗和齿轮构筑的太阳,伸出金色的臂膀擎着一片晴空,逶道而来,斩断阴霾的剑光在普照众生的沧桑。</p>
<p>你傲然屹立于世界的东方,不管身边的风云如何的变幻,始终坚定地沿真理的方向勇往直前。你般迎着八面春风,在辐射的节奏里,眺望着更加灿烂的前程。</p>
<p>我灵魂的纤绳永系向你风帆的桅杆;我手中的彩笔,永远写你壮重的风姿;</p>
<p>面对飘扬国旗，血液在奔涌，思绪在沸腾,理想的根须在土里扎得更深。面对飘扬的国旗,我们已把自己溶入母亲炙热的胸襟。</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>9.26日报</title>
    <url>/2019/09/26/2019-09-26-26ribao/</url>
    <content><![CDATA[<h1 id="今天也是收获颇丰的一天"><a href="#今天也是收获颇丰的一天" class="headerlink" title="今天也是收获颇丰的一天:"></a>今天也是收获颇丰的一天:</h1><p>因为要学四个数据库,再ubuntu安装比较麻烦,所以我刷回了Windows系统.</p>
<p>但是安装了虚拟机的deep系统也是基于linux的.</p>
<p>今天已经将四个数据库安装完成,环境也配置好了.</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>9.19阶段感悟</title>
    <url>/2019/09/19/2019-09-19-19ganwu/</url>
    <content><![CDATA[<h1 id="从加入兄弟会到现在的感悟与总结"><a href="#从加入兄弟会到现在的感悟与总结" class="headerlink" title="从加入兄弟会到现在的感悟与总结"></a>从加入兄弟会到现在的感悟与总结</h1><p>从听说兄弟会的学习模式开始,我就一直盼望着加入兄弟会,然而我也确实很幸运地通过面试加入进了兄弟会.</p>
<p>刚加入时候是迷茫的,不知道该做些什么,遇见问题无从下手,仅仅是安装ubuntu系统就花费了一整天的时间.</p>
<p>当然兄弟会的教官也教了我们自学效率比较高的方式,查阅资料和向已经学会的同学交流请教,我觉得这很符合现在公司里面的学习方式,进到公司里面不会被特意地教学只能自己根据资料和向前辈请教来快速提升自己.</p>
<p>在掌握了这种自学方式之后,我觉得比平时上课老师教课的学习效率还要高,不只是学习进度可以随自己调,更重要的是<code>不困!!!</code>,说实话到兄弟会一来我还没有过上课时候困得神志模糊那种感觉,有的也仅仅是眼睛的疲劳.</p>
<p>这种精神的清醒我觉得得益于明确的学习目标,和自己自由的时间分配,在每一天都没有打盹的情况下,我觉得学习效率高多了.</p>
<p>再就是兄弟会的成员构成,有php的,java的,python的,有原来学习各种学科的同学,所以在我们的目标是最少学习两门语言的情况下,这种成员构成就有很好的学习氛围.</p>
<p>当在一门学科遇到了问题的时候,可以很容易地请教到其他学过这门科目的同学,在那些官方的知识被人性化的整理之后,比原来官方文档更容易理解了.</p>
<p>还有听书环节,我觉得不光是要听那些名人名书的理念,更要注重的是看看这些名人是怎么想到从更高的角度去看待某一件事,用我们一位教官说的话就是,”格局”,当一个人格局大了,他的人生观价值观自然就不同与普通人,目标不同前进的动力也会不同.</p>
<blockquote>
<p>最后总结一下:</p>
</blockquote>
<p>加入了兄弟会,我的学习方式彻底改变了,效率变得更高了,人生格局也发现了改变,目标也更加远大.在兄弟会了不单单学习了知识,更让精神又成长了一步.</p>
<p>最后希望兄弟会的兄弟们都能顺利地完成兄弟会的任务,顺利地走上自己预想的那条人生轨迹.</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>9.18连接远程服务器</title>
    <url>/2019/09/18/2019-09-18-18jishu/</url>
    <content><![CDATA[<h1 id="连接远程服务器-上传文件方法"><a href="#连接远程服务器-上传文件方法" class="headerlink" title="连接远程服务器,上传文件方法"></a>连接远程服务器,上传文件方法</h1><blockquote>
<p>安装rdesktop</p>
</blockquote>
<p>  sudo apt-get install rdesktop</p>
<blockquote>
<p>连接服务器</p>
</blockquote>
<p>  rdesktop IP -u Administrator -r disk:app=/home/USER/桌面/node</p>
<p>  连接远程服务器，并把位于/home/USER/桌面/node里的内容虚拟出一个映射盘在服务器上。</p>
<p>  -f 全屏</p>
<p>  -u xxxxxx 登录用户，可选</p>
<p>  -p xxxxxx 登录密码，可选</p>
<p>  -r clipboard:PRIMARYCLIPBOARD 重要，剪贴板可以与远程桌面交互</p>
<p>  -a 16 颜色，可选，不过最高就是16位</p>
<p>  -r disk:wj=/home/magicgod映射虚拟盘，可选，会在远程机器的网上邻居里虚拟出一个映射盘，功能很强，甚至可以是软盘或光盘</p>
<blockquote>
<p>安装nodejs</p>
</blockquote>
<p>1.下载地址：<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/download/</a> 选择相应的版本下载,这里下载的是windows的zip文件。</p>
<p>2.解压缩</p>
<p>  将下载的文件解压到要安装的位置，并新建两个目录：</p>
<p>  node-global :npm全局安装位置</p>
<p>  node-cache：npm 缓存路径</p>
<p>3.配置</p>
<p>  将node.exe 所在的目录添加到path环境变量，这样我们在使用命令行时就可以在任意路径使用node命令</p>
<p>那么node-global:npm全局安装位置，node-cache：npm缓存路径 又是怎么与npm发生关系呢？</p>
<p> 通过如下命令进行配置：</p>
<p>npm config set prefix “C:\Program Files\node\node-global”</p>
<p>npm config set cache “C:\Program Files\node\node-cache”</p>
<p>4.在命令行中输入如下命令测试</p>
<p>  node -v</p>
<p>  npm -v</p>
<blockquote>
<p>访问域名访问到项目</p>
</blockquote>
<p>我使用的是 phpstudy 使用很方便</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>远程连接服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>9.16技术分享文档</title>
    <url>/2019/09/16/2019-09-16-16jishu/</url>
    <content><![CDATA[<h1 id="jquery-常用事件整理"><a href="#jquery-常用事件整理" class="headerlink" title="jquery 常用事件整理"></a>jquery 常用事件整理</h1><blockquote>
<p>鼠标点击事件</p>
</blockquote>
<p>click</p>
<blockquote>
<p>鼠标双击事件</p>
</blockquote>
<p>dblclick</p>
<blockquote>
<p>鼠标指针进入事件</p>
</blockquote>
<p>mouseenter</p>
<blockquote>
<p>鼠标指针离开事件</p>
</blockquote>
<p>mouseleave</p>
<blockquote>
<p>鼠标指针悬停</p>
</blockquote>
<p>hover</p>
<blockquote>
<p>字段内按键次数</p>
</blockquote>
<pre><code>$(&quot;input&quot;).keypress(function(){
    $(&quot;span&quot;).text(i+=1);   
});
</code></pre><blockquote>
<p>键盘被按下时改变颜色</p>
</blockquote>
<pre><code>$(&quot;input&quot;).keydown(function(){
    $(&quot;input&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;);
});
</code></pre><blockquote>
<p>键盘松开时改变颜色</p>
</blockquote>
<pre><code>    $(&quot;input&quot;).keyup(function(){
        $(&quot;input&quot;).css(&quot;background-color&quot;,&quot;pink&quot;);
    });
</code></pre><blockquote>
<p>提交表单时</p>
</blockquote>
<p>submit</p>
<blockquote>
<p>改变时</p>
</blockquote>
<p>change</p>
<blockquote>
<p>获得焦点时</p>
</blockquote>
<p>focus</p>
<blockquote>
<p>失去焦点时</p>
</blockquote>
<p>blur</p>
<blockquote>
<p>全部加载时</p>
</blockquote>
<p>load</p>
<blockquote>
<p>调整大小</p>
</blockquote>
<p>resize</p>
<blockquote>
<p>元素滚动</p>
</blockquote>
<p>scroll</p>
<blockquote>
<p>离开时</p>
</blockquote>
<p>unload</p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>9.10日报</title>
    <url>/2019/09/10/2019-09-10-10ribao/</url>
    <content><![CDATA[<h1 id="今天也是收获颇丰的一天-在同学那学到了很多"><a href="#今天也是收获颇丰的一天-在同学那学到了很多" class="headerlink" title="今天也是收获颇丰的一天,在同学那学到了很多:"></a>今天也是收获颇丰的一天,在同学那学到了很多:</h1><p>今天上午开始去背的倒计时,但是背了挺长时间背得效率也不是那么高.</p>
<p>然后看了同学自己按照自己的思路写的代码,感觉思路清晰多了.</p>
<p>今天学到了,看代码不要按照固有思路去看  别人的代码也未必是最好的代码,自己捋请思路写一遍也许效果更好.</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>9.09日报</title>
    <url>/2019/09/09/2019-09-09-09ribao/</url>
    <content><![CDATA[<h1 id="今天考考了两个js特效的实现页面-总结一下"><a href="#今天考考了两个js特效的实现页面-总结一下" class="headerlink" title="今天考考了两个js特效的实现页面,总结一下:"></a>今天考考了两个js特效的实现页面,总结一下:</h1><p>在做选项卡页面的时候,忘记了引用jqery文件,导致一直运行失败 还好在最后的时候想了起来.</p>
<p>还有样式要记得加上浮动效果比较好,</p>
<p>这两个页面我样式做的都不是很好看,css要复习复习了.</p>
<p>下午和晚自习又看了几个页面,明天争取顺利考过.</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>9.07技术分享文档</title>
    <url>/2019/09/07/2019-09-07-07jishu/</url>
    <content><![CDATA[<h1 id="今天分享几个经过细心挑选了的较高质量的壁纸网站"><a href="#今天分享几个经过细心挑选了的较高质量的壁纸网站" class="headerlink" title="今天分享几个经过细心挑选了的较高质量的壁纸网站:"></a>今天分享几个经过细心挑选了的较高质量的壁纸网站:</h1><p><a href="http://www.jj20.com/" target="_blank">娟娟壁纸</a></p>
<p><a href="http://pic.netbian.com/" target="_blank">彼岸图网</a></p>
<p><a href="https://bz.zzzmh.cn/" target="_blank">极简壁纸</a></p>
<p><a href="https://alpha.wallhaven.cc/" target="_blank">wallhaven</a></p>
<p><a href="https://pixabay.com/" target="_blank">pixabay</a></p>
<p><a href="https://wallpaperscraft.com/" target="_blank">wallpaperscraft</a></p>
<p><a href="http://simpledesktops.com/" target="_blank">Simple Desktops(极简风)</a></p>
<p><a href="https://www.gamewallpapers.com/" target="_blank">GameWallpapers(游戏专题壁纸)</a></p>
<p><a href="https://wallpapercave.com/" target="_blank">Wallpaper Cave</a></p>
<p><a href="https://www.moviemania.io/" target="_blank">Moviemania(电影壁纸)</a></p>
<p><a href="https://unsplash.com/" target="_blank">unsplash(摄影壁纸)</a></p>
<p><a href="https://www.pexels.com/" target="_blank">pexels(高质量图片社区)</a><br><a href="https://www.pexels.com/videos/" target="_blank">视频专区</a></p>
<p><a href="https://gratisography.com/" target="_blank">gratisography(艺术,脑洞图片)</a></p>
]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>壁纸</tag>
      </tags>
  </entry>
  <entry>
    <title>9.06git命令详细整理之二</title>
    <url>/2019/09/06/2019-09-06-06jishu/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/afei__/article/details/51476529" target="_blank" rel="noopener">git命令整理博客1</a></p>
<p><strong>还有大家一起整理了挺全的命令整理：</strong></p>
<blockquote>
<p>查看远程库配置信息</p>
</blockquote>
<p>git remote show 远程库名</p>
<blockquote>
<p>给远程地址添加别名</p>
</blockquote>
<p>git remote add 别名 远程库地址</p>
<blockquote>
<p>修改远程库名字</p>
</blockquote>
<p>git remote rename 老名字 新名字</p>
<blockquote>
<p>删除远程库</p>
</blockquote>
<p>git remote rm 库名</p>
<blockquote>
<p>分支取下来自动合并</p>
</blockquote>
<p>git pull</p>
<blockquote>
<p>加注标签  -m后跟说明</p>
</blockquote>
<p>git tag -a 标签名 -m”说明”</p>
<blockquote>
<p>给原来的标签加说明</p>
</blockquote>
<p>git tag -s v1.5 -m”说明”</p>
<blockquote>
<p>轻量级标签</p>
</blockquote>
<p>git tag 标签名 -lw</p>
<blockquote>
<p>发送标签到远程服务器</p>
</blockquote>
<p>git push origin 标签名</p>
<blockquote>
<p>创建分支</p>
</blockquote>
<p>git branch 分支名</p>
<blockquote>
<p>切换分支</p>
</blockquote>
<p>git chechout 分知名</p>
<blockquote>
<p>改变head指针指向位置</p>
</blockquote>
<p>git reset –hard 回退历史的索引值</p>
<blockquote>
<p>显示当前HEAD指针在哪</p>
</blockquote>
<p>git reset –hard</p>
<blockquote>
<p>取消缓存</p>
</blockquote>
<p>git reset HEAD 文件名</p>
<blockquote>
<p>合并分支</p>
</blockquote>
<p>git merge 分支</p>
<blockquote>
<p>删除分支</p>
</blockquote>
<p>git branch -d 分支名</p>
<blockquote>
<p>查看所有分支信息,列出所有本地分支</p>
</blockquote>
<p>git branch</p>
<blockquote>
<p>查看各个分支最后一次提交的对象</p>
</blockquote>
<p>git branch -v</p>
<blockquote>
<p>查看哪些分支已被并入当期分支</p>
</blockquote>
<p>git branch –merge</p>
<blockquote>
<p>查看尚未合并的工作</p>
</blockquote>
<p>git branch –no-merged</p>
<blockquote>
<p>推送分支到远程仓库</p>
</blockquote>
<p>git push 远程库名 分支名</p>
<blockquote>
<p>跟踪远程分支</p>
</blockquote>
<p>git checkout –track orgin/master</p>
<blockquote>
<p>分享标签</p>
</blockquote>
<p>git push origin 标签名</p>
<blockquote>
<p>分享所有标签</p>
</blockquote>
<p>git push origin -tag</p>
<blockquote>
<p>推送本地分支</p>
</blockquote>
<p>git push origin 分支名</p>
<blockquote>
<p>删除远程分支</p>
</blockquote>
<p>git rm origin:分支名</p>
<blockquote>
<p>新建一个目录,将其初始化为git代码库</p>
</blockquote>
<p>git init</p>
<blockquote>
<p>编辑git配置文件</p>
</blockquote>
<p>git config -e [–global]</p>
<blockquote>
<p>查看git的配置信息</p>
</blockquote>
<p>git config –list</p>
<blockquote>
<p>设置提交代码时的用户信息</p>
</blockquote>
<p>git config [–global] user.name “[name]”</p>
<blockquote>
<p>设置提交代码时的邮箱信息</p>
</blockquote>
<p>git config [–global] user.email “[email address]”</p>
<blockquote>
<p>添加指定文件到暂存区</p>
</blockquote>
<p>git add [file1] [file2]</p>
<blockquote>
<p>添加当前目录的所有文件到暂存区</p>
</blockquote>
<p>git add .</p>
<blockquote>
<p>对于同一个文件的多处变化,可以实现分次提交</p>
</blockquote>
<p>git add -p</p>
<blockquote>
<p>提交暂存区到仓库区</p>
</blockquote>
<p>git commit -m””</p>
<blockquote>
<p>提交暂存区的制定文件到仓库区</p>
</blockquote>
<p>git commit [file1][file2]  -m””</p>
<blockquote>
<p>提交工作区自上次commit之后的变化,直接到仓库区</p>
</blockquote>
<p>git commit -a </p>
<blockquote>
<p>提交时显示所有diff信息</p>
</blockquote>
<p>git commit -v</p>
<blockquote>
<p>使用一次新的commit,替代上次提交,</p>
</blockquote>
<p>git commit –amend -m””</p>
<blockquote>
<p>重做上一次comit,并包括指定文件的新变化</p>
</blockquote>
<p>git commit –aend [file1][file2]</p>
<blockquote>
<p>列出所有远程分支</p>
</blockquote>
<p>git branch -r</p>
<blockquote>
<p>列出所有本地分支和远程分支</p>
</blockquote>
<p>git branch -a</p>
<blockquote>
<p>新建一个分支</p>
</blockquote>
<p>git branch 分支名</p>
<blockquote>
<p>新建一个分支并切到该分支</p>
</blockquote>
<p>git checkout -b 分支名</p>
<blockquote>
<p>新建一个分支,指向指定commit的哈希值</p>
</blockquote>
<p>git branch [branch][commit]</p>
<blockquote>
<p>新建一个分支,与指定的远程分子建立追踪关系</p>
</blockquote>
<p>git branch –track [branch] [remote-branch]</p>
<blockquote>
<p>切换到指定分支</p>
</blockquote>
<p>git checkout [branch-name]</p>
<blockquote>
<p>切换到上一个分支</p>
</blockquote>
<p>git checkout -</p>
<blockquote>
<p>新建一个分支,指向某个tag</p>
</blockquote>
<p>git checkout -b [branch][tag]</p>
<blockquote>
<p>建立追踪关系,在现有分支与指定的远程分支之间</p>
</blockquote>
<p>git branch –set-upstream [branch] [remote-branch]</p>
<blockquote>
<p>选择一个commit,合并进当前分支</p>
</blockquote>
<p>git cherry-pick[commit]</p>
<blockquote>
<p>删除分支</p>
</blockquote>
<p>git branch -d [branch-name]</p>
<blockquote>
<p>删除远程分支</p>
</blockquote>
<p>git push origin –delete [branch-name]</p>
<blockquote>
<p>删除远程分支</p>
</blockquote>
<p>git branch -dr [remote/branch]</p>
<blockquote>
<p>列出所有tag</p>
</blockquote>
<p>git tag</p>
<blockquote>
<p>新建一个tag在当前commit</p>
</blockquote>
<p>git tag [tag]</p>
<blockquote>
<p>新建一个tag在指定commit</p>
</blockquote>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>9.05git命令详细整理</title>
    <url>/2019/09/05/2019-09-05-05jishu/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/afei__/article/details/51476529" target="_blank" rel="noopener">git命令整理博客1</a></p>
<p><strong>还有大家一起整理了挺全的命令整理：</strong></p>
<blockquote>
<p>初始化git库，在当前目录新建一个git代码库</p>
</blockquote>
<p>git init</p>
<blockquote>
<p>git库，下载一个项目和它的整个代码历史</p>
</blockquote>
<p>git clone</p>
<blockquote>
<p>添加追踪文件，如果不写文件名就是该目录下的所有文件添加跟踪,添加指定目录到暂存区，包括子目录</p>
</blockquote>
<p>git add 文件名</p>
<blockquote>
<p>提交到暂存区</p>
</blockquote>
<p>git commit -m””</p>
<blockquote>
<p>检查当前文件状态</p>
</blockquote>
<p>git  status</p>
<blockquote>
<p>检查工作区和暂存区的差别</p>
</blockquote>
<p>git diff</p>
<blockquote>
<p>查看上次提交和未暂存的差别</p>
</blockquote>
<p>git diff –cached [file]</p>
<blockquote>
<p>分支之间的区别</p>
</blockquote>
<p>git diff    原分支  目标分支</p>
<blockquote>
<p>删除文件</p>
</blockquote>
<p>git rm  要删除的文件</p>
<blockquote>
<p>将文件在暂存区删除，也就是取消跟踪，停止追踪指定文件，但该文件会保留在工作区</p>
</blockquote>
<p>git rm –cached  文件</p>
<blockquote>
<p>移动文件/修改文件名并将这个改名放入暂存区</p>
</blockquote>
<p>git mv</p>
<blockquote>
<p>检查提交记录</p>
</blockquote>
<p>git log</p>
<blockquote>
<p>记录显示在一行</p>
</blockquote>
<p>git log –oneine</p>
<blockquote>
<p>显示之前的修改记录</p>
</blockquote>
<p>git reflog</p>
<blockquote>
<p>修改最后提交，也可以说是撤销最后一次提交</p>
</blockquote>
<p>git commit –amend</p>
<blockquote>
<p>抛弃修改命令，回到之前版本，回复暂存区的制定文件到工作区</p>
</blockquote>
<p>git checkout 文件名</p>
<blockquote>
<p>把暂存区的修改撤销掉</p>
</blockquote>
<p>git reset HEAD file</p>
<blockquote>
<p>查看当时配置的有那些远程库，加上-v显示对应的克隆地址</p>
</blockquote>
<p>git remote</p>
<blockquote>
<p>从远程仓库抓取数据</p>
</blockquote>
<p>git fetch origin</p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>9.4日报</title>
    <url>/2019/09/04/2019-09-04-04ribao/</url>
    <content><![CDATA[<blockquote>
<p><code>今天下午考了一个node聊天室，一个js的轮播图。</code>  </p>
</blockquote>
<h1 id="考试总结："><a href="#考试总结：" class="headerlink" title="考试总结："></a>考试总结：</h1><pre><code>今天的考试只有一个半小时就要做出一个聊天室和一个轮播图，正常来说一个半小时做两个基本是完不成的，所以大家都被罚了一下。

然后在进行考试总结的时候我们发现了老师是考验我们团队协作能力而不是自己写出来。
</code></pre><p><strong>心得：</strong></p>
<p>团队协作效率比个人高得多，平时要多与大家交流技术性问题，做项目时候更要多交流一下功能怎么实现的。</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>9.03lamp环境搭建</title>
    <url>/2019/09/03/2019-09-03-03jishu/</url>
    <content><![CDATA[<h1 id="lamp环境的搭建方法与我遇到的问题"><a href="#lamp环境的搭建方法与我遇到的问题" class="headerlink" title="lamp环境的搭建方法与我遇到的问题"></a>lamp环境的搭建方法与我遇到的问题</h1><p>首先我在网上找到了一个很全的安装教程：</p>
<p><a href="https://www.cnblogs.com/opsprobe/p/9126411.html" target="_blank" rel="noopener">lamp安装教程</a></p>
<p>还有一个mysql安装教程：</p>
<p><a href="https://www.cnblogs.com/opsprobe/p/9126864.html" target="_blank" rel="noopener">mysql安装教程</a></p>
<h3 id="在配置lamp的时候也遇到了几个问题，我整理了一下："><a href="#在配置lamp的时候也遇到了几个问题，我整理了一下：" class="headerlink" title="在配置lamp的时候也遇到了几个问题，我整理了一下："></a>在配置lamp的时候也遇到了几个问题，我整理了一下：</h3><p><em>在配置了phpMyAdmin结束的时候我遇到了这种问题:</em></p>
<p><strong>phpMyAdmin错误：缺少mbstring扩展名 请检查您的PHP配置</strong></p>
<blockquote>
<p>处理方法：运行以下两段代码即可</p>
</blockquote>
<p>sudo apt-get install phpmyadmin php-mbstring php-gettext</p>
<p>systemctl restart apache2</p>
<h4 id="我还遇到了mysql数据库的root密码忘记了，比较尴尬…："><a href="#我还遇到了mysql数据库的root密码忘记了，比较尴尬…：" class="headerlink" title="我还遇到了mysql数据库的root密码忘记了，比较尴尬…："></a>我还遇到了mysql数据库的root密码忘记了，比较尴尬…：</h4><blockquote>
<p>处理方法：在文件中修改一下root密码</p>
</blockquote>
<p>1.在终端输入</p>
<p>sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</p>
<p>2.在文件内搜索skip-external-locking,在下面添加一行:</p>
<p>skip-grant-tables</p>
<p>3.重启mysql</p>
<p>sudo service mysql restart</p>
<p>4.在终端输入命令mysql,进入mysql</p>
<p>5.使用命令use mysql;切换到mysql数据库</p>
<p>6.修改root密码</p>
<p>UPDATE mysql.user SET authentication_string=password(‘你想设置的密码’) WHERE User=’root’ AND Host =’localhost’;</p>
<p>7.修改字段plugin(Plugin字段标识可以用于验证用户身份的插件，如果字段为空，服务器使用内建授权验证机制验证用户身份)</p>
<p>UPDATE user SET plugin=”mysql_native_password”;</p>
<p>8.刷新权限,输入命令</p>
<p>flush privileges;</p>
<p>9.退出mysql</p>
<p>quit;</p>
<p>10.回到设置的文件内(/etc/mysql/mysql.conf.d/mysqld.cnf)内把添加的命令注释掉</p>
<p>sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</p>
<p>将skip-grant-tables删除。</p>
<p><a href="https://www.cnblogs.com/wuzdandz/p/10790458.html" target="_blank" rel="noopener">此方法参考博客</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>lamp安装</tag>
      </tags>
  </entry>
  <entry>
    <title>9.2日报</title>
    <url>/2019/09/02/2019-09-02-02ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p><code>今天开始回去翻看之前的git,vim,linux,js笔记，今天看完了git,vim。明天继续看linux命令与js语法。我整理了一下不太熟的命令在这里。</code>  </p>
</blockquote>
<h1 id="不太熟悉的命令："><a href="#不太熟悉的命令：" class="headerlink" title="不太熟悉的命令："></a>不太熟悉的命令：</h1><p>git mergr -m”合并”&lt;分支名&gt;          将指定分支合并到当前分支</p>
<p>git pull <remote> <remote branch>:<branch>          同步指定分支的合并，有追踪关系的</branch></remote></remote></p>
<p>git pull origin dev:master          将远程dev与本地master合并</p>
<p>git pull origin dev         将远程dev合并到当前分支</p>
<p>git stash           贮藏当前工作区的修改，没有commit的</p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>8.30技术文档</title>
    <url>/2019/08/30/2019-08-30-30jishu/</url>
    <content><![CDATA[<h1 id="js的常用语法（整理版）"><a href="#js的常用语法（整理版）" class="headerlink" title="js的常用语法（整理版）"></a>js的常用语法（整理版）</h1><blockquote>
<p>今天在看node的空闲时间又重新整理了之前的js语法：</p>
</blockquote>
<pre><code class="pre">        连接外部js文件：
        &lt;script src=&quot;js文件&quot;&gt;&lt;/script&gt;

        alert()     弹出警告框

        document.write()        将内容写到HTML文档中

        innerHTML=&quot;写入到HTML元素&quot;

        console.log()       写入到浏览器的控制台

        document.write(&quot;&lt;h1&gt;&lt;这是一个标题/h1&gt;&quot;)
        直接写入到html输出流

改变html内容：
&lt;p id=&quot;demo&quot;&gt;哈哈哈&lt;/p&gt;
&lt;script&gt;
        function myFunction(){  //定义一个类
            x=document.getElementById(&quot;demo&quot;);  //找到元素，获取
            //获取类元素：gitElementsByClassName
            //获取标签元素：gitElementsByTagName
            x.innerHTML=&quot;Hello&quot;;    //改变内容
            x.style.color=&quot;#ff0000&quot;;    //改变样式
        }
&lt;/script&gt;
&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点这里&lt;/button&gt;


&lt;button onclick=&quot;getElementById(&#39;demo&#39;).innerHTML=Date()&quot;&gt;时间&lt;/button&gt;
        //点击后修改demo处文字为Date

&lt;button onclick=&quot;this.innerHTML=Date()&quot;&gt;时间&lt;/button&gt;
        //点击后修改按钮上的内容为Date
</code></pre>
<p><strong>常见的HTML事件：</strong></p>
<pre><code>onchange        HTML元素改变

onclick         用户点击HTML元素

onmouseover         用户在HTML元素上移动鼠标

onmouseout          用户从一个HTML元素上移开鼠标

onkeydown           用户按下键盘按键

onload          浏览器已完成页面的加载

字符串.lenght           字符串长度
</code></pre><p><strong>setInterval()</strong>       间隔指定毫秒书不停地执行指定代码<br><strong>setTimeout()</strong>        在指定毫秒数后执行指定代码</p>
<p>myVar=setTimeout(function(){alert(“Hello”)},3000);<br>            //等待3秒后弹出Hello</p>
<p>clearTimeout(myVar);        停止执行</p>
<p>clearInterval(myVar);        停止执行</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>8.30日报</title>
    <url>/2019/08/30/2019-08-30-30ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p><code>今天开始学node的socket模块，在网上查了各种资源勉强做出来一个简易的多人聊天室，也遇到了一些问题。</code>  </p>
</blockquote>
<h1 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><p>在关闭端口时总会出现关闭不完全的情况，我在网上寻找了这种方法：</p>
<p>lsof -i :端口号            查询该端口占用情况</p>
<p>kill -9  查询出对应的PID                  关闭端口进程</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>端口占用</tag>
      </tags>
  </entry>
  <entry>
    <title>8.29技术文档</title>
    <url>/2019/08/29/2019-08-29-29jishu/</url>
    <content><![CDATA[<h1 id="简易的图片轮播"><a href="#简易的图片轮播" class="headerlink" title="简易的图片轮播"></a>简易的图片轮播</h1><p>今天主要学习了轮播图的原理和简易制作，以下是我轮播图的代码：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;轮播图&lt;/title&gt;
    &lt;style type=&quot;text/css&quot;&gt;

        p{
            text-align: center;
            font-size: 25px;
            color: rgb(95, 152, 160);
            font-family: fantasy;

        }

        .imgBox{
            position: absolute;
            left: 25%;
            border-top: 2px solid rgb(95, 152, 160);
            width: 50%;
            height: 500px;
        }

        .imgBox img{
           width: 50%;
            margin: 0 auto;
            padding-top: 30px;

        }

        .img1{
            display: block;
        }

        .img2{
            display: none;
        }

        .img3{
            display: none;
        }
        .btn-ctrl{
            position: relative;
            top: 20%;
            cursor: pointer;
            font-size: 36px;
            color: red;
            font-weight: 500;
        }
        #btn-prev{
            left: 0px;
            float: left;
        }
        #btn-next{
            right: 0px;
            float: right;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;图片轮播&lt;/p&gt;

&lt;div class=&quot;imgBox&quot;&gt;
        &lt;div id=&quot;btn-prev&quot; class=&quot;btn-ctrl&quot; onclick=&quot;clock(0)&quot;&gt;&amp;lt;&lt;/div&gt;
        &lt;div id=&quot;btn-next&quot; class=&quot;btn-ctrl&quot; onclick=&quot;clock(1)&quot;&gt;&amp;gt;&lt;/div&gt;
    &lt;img class=&quot;img-slide img1&quot;  src=&quot;images/1.jpg&quot;&gt;
    &lt;img class=&quot;img-slide img2&quot;  src=&quot;images/2.jpg&quot;&gt;
    &lt;img class=&quot;img-slide img3&quot;  src=&quot;images/3.jpg&quot;&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var index=0;
    function changeImg() {
        index++;
        var a=document.getElementsByClassName(&quot;img-slide&quot;);
        if(index&gt;=a.length) index=0;
        for(var i=0;i&lt;a.length;i++){
            a[i].style.display=&#39;none&#39;;
        }
        a[index].style.display=&#39;block&#39;;
    }
    function clock(cc){
        switch(cc){
            case 0:
                index=index-2;
                if(index&lt;-1) index=1;
                break;
            case 1:
               index;
                break;
        }
    }
      setInterval(changeImg,2000);
&lt;/script&gt;
&lt;/html&gt;
</code></pre><p>原理：用js获取图片的类组成数组，利用循环将所有图片都先隐藏，再利用图片数组下标逐个显示。</p>
]]></content>
      <categories>
        <category>特效</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>8.29日报</title>
    <url>/2019/08/29/2019-08-29-29ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p><code>今天完成了计时器的考核，关于计时器与属性获取基本掌握90%，轮播图效果80%，后面开始看node,但是刚开始看进度10%</code>  </p>
</blockquote>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>今天在做计时器效果与轮播图效果都是自己在网上寻找的教程与例子，当自己努力做出来的成果成果的时候是很开心的，很有动力。</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>8.28技术文档</title>
    <url>/2019/08/28/2019-08-28-28jishu/</url>
    <content><![CDATA[<h1 id="JS常用知识"><a href="#JS常用知识" class="headerlink" title="JS常用知识"></a>JS常用知识</h1><blockquote>
<p>直接写入html输出流：</p>
</blockquote>
<p><code>document.write(&quot;&lt;h1&gt;这是一个标题&lt;/h1&gt;&quot;);</code></p>
<blockquote>
<p>改变html内容：</p>
</blockquote>
<pre><code>&lt;p id=&quot;demo&quot;&gt;111&lt;/p&gt;
&lt;script&gt;
    function myFunction()  //定义一个类
    {
        var x=document.getElementById(&quot;demo&quot;); //找到元素
        x.innerHTML = &quot;hello&quot;; //改变内容
        x.style.color = &quot;#ff0000&quot;;
    }
&lt;/script&gt;
&lt;button onclick=&quot;myFunction()&quot;&gt;点我&lt;/button&gt;

</code></pre><blockquote>
<p>显示数据  </p>
</blockquote>
<pre><code>    alert()   弹出警告框  

    document.write() 将内容写到HTML文档中

    innerHTML= &quot;写入到HTML元素&quot;

    console.log() 写入到浏览器的控制台
</code></pre><p>let 声明的变量是局部变量<br>const 用来声明常量</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>8.28日报</title>
    <url>/2019/08/28/2019-08-28-28ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p><code>今天下午学习了JS基础，学习了 定时器和选择对象并修改内容，还看了一些基础语法。</code>  </p>
</blockquote>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>今天学习的新任务是JS ，原来学过一些php也有一些基础学得还不算慢，总体来说今天的学习效率还可以。</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>8.27技术文档</title>
    <url>/2019/08/27/2019-08-27-27jishu/</url>
    <content><![CDATA[<h1 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h1><blockquote>
<p>TCP/IP协议简介:  </p>
</blockquote>
<p>TCP/IP传输协议，即传输控制/网络协议，也叫作网络通讯协议。它是在网络的使用中的最基本的通信协议。TCP/IP传输协议对互联网中各部分进行通信的标准和方法进行了规定。并且，TCP/IP传输协议是保证网络数据信息及时、完整传输的两个重要的协议。TCP/IP传输协议是严格来说是一个四层的体系结构，应用层、传输层、网络层和数据链路层都包含其中。</p>
<blockquote>
<p>TCP/IP协议的组成:  </p>
</blockquote>
<p>TCP/IP协议在一定程度上参考了OSI的体系结构。OSI模型共有七层，从下到上分别是物理层、数据链路层、网络层、运输层、会话层、表示层和应用层。</p>
]]></content>
      <categories>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>8.27日报</title>
    <url>/2019/08/27/2019-08-27-27ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p><code>linux命令已通过考核，但是还有一些没有太熟练，学习进度95%，下午绘制了聊天室的流程图和思维导图基本绘制完成进度90%。</code>  </p>
</blockquote>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><blockquote>
<p>今天的不足与感悟</p>
</blockquote>
<h3 id="今天的不足"><a href="#今天的不足" class="headerlink" title="今天的不足"></a>今天的不足</h3><p>已经给了半天时间看文档，考试linux命令时候还勾抹几次，命令定义不明确，意思相近的有很多没有明确区分。</p>
<h3 id="今天的感悟"><a href="#今天的感悟" class="headerlink" title="今天的感悟"></a>今天的感悟</h3><p>背东西时候要专注，有效率不能左看一眼又看一眼，这个看会了再看下一个</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>8.26技术文档</title>
    <url>/2019/08/26/2019-08-26-26jishu/</url>
    <content><![CDATA[<h1 id="linux常用命令整合版"><a href="#linux常用命令整合版" class="headerlink" title="linux常用命令整合版"></a>linux常用命令整合版</h1><p><strong>关机 (系统的关机、重启以及登出 ):</strong><br>shutdown -h now 关闭系统<br>init 0 关闭系统<br>telinit 0 关闭系统<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启<br>reboot 重启<br>logout 注销   </p>
<p><strong>文件和目录:</strong><br>cd /home 进入 ‘/ home’ 目录’<br>cd .. 返回上一级目录<br>cd ../.. 返回上两级目录<br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br>cd - 返回上次所在的目录<br>pwd 显示工作路径<br>ls 查看目录中的文件<br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br>ls -a 显示隐藏文件<br>ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构<br>lstree 显示文件和目录由根目录开始的树形结构<br>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>mkdir dir1 dir2 同时创建两个目录<br>mkdir -p /tmp/dir1/dir2 创建一个目录树<br>rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>mv dir1 new_dir 重命名/移动 一个目录<br>cp file1 file2 复制一个文件<br>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码   </p>
<p><strong>文件搜索 :</strong><br>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录   </p>
<p>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件 </p>
<p>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件     </p>
<p>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件     </p>
<p>find / -name *.rpm -exec chmod 755 ‘{}’ \; 搜索以 ‘.rpm’ 结尾的文件并定义其权限 </p>
<p>find / -xdev -name *.rpm 搜索以 ‘.rpm’   结尾的文件，忽略光驱、捷盘等可移动设备 </p>
<p>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置   </p>
<p>which halt 显示一个二进制文件或可执行文件的完整路径 </p>
<p><strong>备份:</strong><br>dump [选项] 备份后文件名  原文件或目录选项：<br>-0~9  九个备份级别<br>-f文件名： 指定备份后的文件名<br>-u： 备份成功后，把备份时间记录在/etc/dumpdates文件<br>-v：显备份过程中更多的输出信息<br>-j ：把文件压缩为.bz2格式<br>-W：显示允许被dump的分区备份登等级及备份时间<br>例： dump -0uj -f /root/boot.bak.bz2 /boot<br><strong>备份命令，先执行一次完全备份，并压缩和更新备份时间:</strong><br>cat /etc/dumpdates<br><strong>查看备份时间文件 :</strong><br>cp install.log /boot/<br><strong>复制日志文件到boot分区 :</strong><br>dump -1uj -f /root/boot,bak1.bz2 /boot/<br><strong>增量备份/boot分区，并压缩:</strong><br>dump -W<br><strong>查询分区的备份时间及备份级别 :</strong><br>备份文件或目录，只能用0级别进行完全备份，并且不支持增量备份：<br>dump -0j -f /root/etc.dump.bz2 /etc/  </p>
<p><strong>恢复备份:</strong><br>restore [模式选项] [选项]<br>有四种模式不能混用。<br>-C：比较备份数据和实际数据的变化<br>-i：进入交互模式，手工选择需要恢复的文件<br>-t：查看模式，用于查看文件中拥有哪些数据<br>-r：还原模式，用于数据还原<br>选项：<br>-f：指定备份文件的文件名</p>
<p><strong>磁盘空间:</strong><br>df -h 显示已经挂载的分区列表 </p>
<p>ls -lSr |more 以尺寸大小排列文件和目录 </p>
<p>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’ </p>
<p>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小 </p>
<p>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小<br>为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)</p>
<p>dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ |<br>sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) </p>
<p><strong>用户和群组</strong><br>groupadd group_name 创建一个新用户组 </p>
<p>groupdel group_name 删除一个用户组 </p>
<p>groupmod -n new_group_name old_group_name 重命名一个用户组 </p>
<p>useradd -c “Name Surname “ -g admin -d /home/user1 -s /</p>
<p>bin/bash user1 创建一个属于 “admin” 用户组的用户 </p>
<p>useradd user1 创建一个新用户 </p>
<p>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录) </p>
<p>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/<br>nologin user1 修改用户属性 </p>
<p>passwd 修改口令 </p>
<p>passwd user1 修改一个用户的口令 (只允许root执行) </p>
<p>chage -E 2005-12-31 user1 设置用户口令的失效期限 </p>
<p>pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户 </p>
<p>grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组 </p>
<p>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组</p>
<p>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消 </p>
<p>ls -lh 显示权限 </p>
<p>ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示 </p>
<p>chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 </p>
<p>chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 </p>
<p>chown user1 file1 改变一个文件的所有人属性 </p>
<p>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 </p>
<p>chgrp group1 file1 改变文件的群组 </p>
<p>chown user1:group1 file1 改变一个文件的所有人和群组属性 </p>
<p>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件 </p>
<p>chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 </p>
<p>chmod u-s /bin/file1 禁用一个二进制文件的 SUID位 </p>
<p>chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 </p>
<p>chmod g-s /home/public 禁用一个目录的 SGID 位 </p>
<p>chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 </p>
<p>chmod o-t /home/public 禁用一个目录的 STIKY 位 </p>
<p>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消 </p>
<p>chattr +a file1 只允许以追加方式读写文件 </p>
<p>chattr +c file1 允许这个文件能被内核自动压缩/解压 </p>
<p>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件 </p>
<p>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接 </p>
<p>chattr +s file1 允许一个文件被安全地删除 </p>
<p>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 </p>
<p>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件 </p>
<p>lsattr 显示特殊的属性 </p>
<p><strong>打包和压缩文件:</strong></p>
<p>file 文件名 ：查文件类型（可看是用哪一种方式压缩的）</p>
<p>tar -zxvf a.tar.gz -C ./test ：解压tar.gz到当前目录下的<br>test目录</p>
<p>tar -zcvf /opt/c.tar.gz ./a/ ：压缩tar.gz（把当前目录下的a目录及目录下所有文件压缩为 /opt/目录下的c.tar.gz，这样tar -zxvf c.tar.gz解压出来带有目录a）</p>
<p>tar -jxvf a.tar.bz2 ：解压tar.bz2（到当前目录）</p>
<p>tar -jcvf c.tar.bz2 ./a/ ：压缩tar.bz2（把当前目录下的a目录及目录下所有文件压缩到当前目录下为c.tar.gz2）</p>
<p>unzip a.zip ：解压zip（到当前目录）</p>
<p>unzip -o mdmtest.war -d /opt/mdm ：推荐使用unzip解压war包（-o覆盖原有文件，-d指定文件解压后存储的目录）</p>
<p>zip -r c.zip ./a/ :压缩zip(把当前目录下的a目录及目录下所有文件压缩到当前目录下为c.zip</p>
<p>bzip2 -k file1 ： 压缩一个 ‘file1’ 的文件（-k表示保留源文件）（bzip2格式，比gzip好）</p>
<p>bzip2 -d -k file1.bz2 ： 解压一个叫做 ‘file1.bz2’的文件</p>
<p>gzip file1 ： 压缩一个叫做 ‘file1’的文件（gzip格式）（不能保留源文件）</p>
<p>gzip -9 file1 ： 最大程度压缩</p>
<p>gzip -d file1.gz ： 解压缩一个叫做 ‘file1’的文件</p>
<p><strong>APT 软件工具 (Debian, Ubuntu 以及类似系统):</strong>  </p>
<p>apt-get install package_name 安装/更新一个 deb 包 </p>
<p>apt-cdrom install package_name 从光盘安装/更新一个 deb 包 </p>
<p>apt-get update 升级列表中的软件包 </p>
<p>apt-get upgrade 升级所有已安装的软件 </p>
<p>apt-get remove package_name 从系统删除一个deb包 </p>
<p>apt-get check 确认依赖的软件仓库正确 </p>
<p>apt-get clean 从下载的软件包中清理缓存 </p>
<p>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 </p>
<p><strong>查看文件内容:</strong><br>cat file1 从第一个字节开始正向查看文件的内容 </p>
<p>tac file1 从最后一行开始反向查看一个文件的内容 </p>
<p>more file1 查看一个长文件的内容 </p>
<p>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作 </p>
<p>head -2 file1 查看一个文件的前两行 </p>
<p>tail -2 file1 查看一个文件的最后两行 </p>
<p>tail -f /var/log/messages 实时查看被添加到一个文件中的内容 </p>
<p><strong>文本处理:</strong><br>cat file1 file2 … | command &lt;&gt; </p>
<p>file1_in.txt_or_file1_out.txt general syntax for text </p>
<p>manipulation using PIPE, STDIN and STDOUT </p>
<p>cat file1 | command( sed, grep, awk, grep, etc…) &gt;<br>result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中 </p>
<p>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 </p>
<p>grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug” </p>
<p>grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇 </p>
<p>grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行 </p>
<p>grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug” </p>
<p>sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2” </p>
<p>sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行 </p>
<p>sed ‘/ *#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行 </p>
<p>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容 </p>
<p>sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行 </p>
<p>sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行 </p>
<p>sed -e ‘s/ *$//‘ example.txt 删除每一行最后的空白字符 </p>
<p>sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部 </p>
<p>sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容 </p>
<p>sed -n ‘5p;5q’ example.txt 查看第5行 </p>
<p>sed -e ‘s/00*/0/g’ example.txt 用单个零替换多个零 </p>
<p>cat -n file1 标示文件的行数 </p>
<p>cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行 </p>
<p>echo a b c | awk ‘{print $1}’ 查看一行第一栏 </p>
<p>echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏 </p>
<p>paste file1 file2 合并两个文件或两栏的内容 </p>
<p>paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分 </p>
<p>sort file1 file2 排序两个文件的内容 </p>
<p>sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) </p>
<p>sort file1 file2 | uniq -u 删除交集，留下其他的行 </p>
<p>sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) </p>
<p>comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容 </p>
<p>comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容 </p>
<p>comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 </p>
<p><strong>网络 - （以太网和WIFI无线）:</strong></p>
<p>sudo ifconfig 查看网卡信息</p>
<p>ifconfig eth0 显示一个以太网卡的配置 </p>
<p>ifup eth0 启用一个 ‘eth0’ 网络设备 </p>
<p>ifdown eth0 禁用一个 ‘eth0’ 网络设备 </p>
<p>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址 </p>
<p>ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing) </p>
<p>dhclient eth0 以dhcp模式启用 ‘eth0’ </p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>8.26日报</title>
    <url>/2019/08/26/2019-08-26-26ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p><code>今天看了一天的linux命令但是侧重点不够明确，常用的命令也基本认识了，学习linux命令70%。</code>  </p>
</blockquote>
<blockquote>
<p><code>今天按照网上的材料整理了一些linux常用命令，分享了技术博客。</code></p>
</blockquote>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><blockquote>
<p>今天的不足与感悟</p>
</blockquote>
<h3 id="今天的不足"><a href="#今天的不足" class="headerlink" title="今天的不足"></a>今天的不足</h3><p>今天是我们组技术分享的时间，我讲的是html，虽然事先做好了ppt，但是上台还是有些放不开，不够灵活，只是死板地讲</p>
<h3 id="今天的感悟"><a href="#今天的感悟" class="headerlink" title="今天的感悟"></a>今天的感悟</h3><p>上台演讲的事还是要多练习，还要多和大家沟通，才会一点点地会站在前面讲项目</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>8.23技术文档</title>
    <url>/2019/08/23/2019-08-23-23jishu/</url>
    <content><![CDATA[<h1 id="linux常用命令整理之一"><a href="#linux常用命令整理之一" class="headerlink" title="linux常用命令整理之一"></a>linux常用命令整理之一</h1><p><strong>关机 (系统的关机、重启以及登出 ):</strong><br>shutdown -h now 关闭系统<br>init 0 关闭系统<br>telinit 0 关闭系统<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启<br>reboot 重启<br>logout 注销   </p>
<p><strong>文件和目录:</strong><br>cd /home 进入 ‘/ home’ 目录’<br>cd .. 返回上一级目录<br>cd ../.. 返回上两级目录<br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br>cd - 返回上次所在的目录<br>pwd 显示工作路径<br>ls 查看目录中的文件<br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br>ls -a 显示隐藏文件<br>ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构<br>lstree 显示文件和目录由根目录开始的树形结构<br>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>mkdir dir1 dir2 同时创建两个目录<br>mkdir -p /tmp/dir1/dir2 创建一个目录树<br>rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>mv dir1 new_dir 重命名/移动 一个目录<br>cp file1 file2 复制一个文件<br>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码   </p>
<p><strong>文件搜索 :</strong><br>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录   </p>
<p>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件 </p>
<p>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件     </p>
<p>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件     </p>
<p>find / -name *.rpm -exec chmod 755 ‘{}’ \; 搜索以 ‘.rpm’ 结尾的文件并定义其权限 </p>
<p>find / -xdev -name *.rpm 搜索以 ‘.rpm’   结尾的文件，忽略光驱、捷盘等可移动设备 </p>
<p>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置   </p>
<p>which halt 显示一个二进制文件或可执行文件的完整路径 </p>
<p><strong>备份:</strong><br>dump [选项] 备份后文件名  原文件或目录选项：<br>-0~9  九个备份级别<br>-f文件名： 指定备份后的文件名<br>-u： 备份成功后，把备份时间记录在/etc/dumpdates文件<br>-v：显备份过程中更多的输出信息<br>-j ：把文件压缩为.bz2格式<br>-W：显示允许被dump的分区备份登等级及备份时间<br>例： dump -0uj -f /root/boot.bak.bz2 /boot<br><strong>备份命令，先执行一次完全备份，并压缩和更新备份时间:</strong><br>cat /etc/dumpdates<br><strong>查看备份时间文件 :</strong><br>cp install.log /boot/<br><strong>复制日志文件到boot分区 :</strong><br>dump -1uj -f /root/boot,bak1.bz2 /boot/<br><strong>增量备份/boot分区，并压缩:</strong><br>dump -W<br><strong>查询分区的备份时间及备份级别 :</strong><br>备份文件或目录，只能用0级别进行完全备份，并且不支持增量备份：<br>dump -0j -f /root/etc.dump.bz2 /etc/  </p>
<p><strong>恢复备份:</strong><br>restore [模式选项] [选项]<br>有四种模式不能混用。<br>-C：比较备份数据和实际数据的变化<br>-i：进入交互模式，手工选择需要恢复的文件<br>-t：查看模式，用于查看文件中拥有哪些数据<br>-r：还原模式，用于数据还原<br>选项：<br>-f：指定备份文件的文件名</p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>8.23日报</title>
    <url>/2019/08/23/2019-08-23-23ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p><code>今天把vim常用命令整理得差不多了，vim进度90%，今天开始看的linux命令，但是感觉看的很乱，进度40%。</code>  </p>
</blockquote>
<blockquote>
<p><code>今天按照网上的材料整理了一些linux常用命令，分享了技术博客。</code></p>
</blockquote>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><blockquote>
<p>今天的不足与感悟</p>
</blockquote>
<h3 id="今天的不足"><a href="#今天的不足" class="headerlink" title="今天的不足"></a>今天的不足</h3><p>今天心不够静，看到属性多了就乱了，不知道从哪开背起，后来慢慢的静下来从头看也看了好几个命令。</p>
<h3 id="今天的感悟"><a href="#今天的感悟" class="headerlink" title="今天的感悟"></a>今天的感悟</h3><p>代码还是多敲，实践起来记忆得才快，代码敲得多了自然就会了。</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>8.22技术文档</title>
    <url>/2019/08/22/2019-08-22-22jishu/</url>
    <content><![CDATA[<h1 id="vim常用命令整理"><a href="#vim常用命令整理" class="headerlink" title="vim常用命令整理"></a>vim常用命令整理</h1><blockquote>
<p>打开或新建一个文件，光标在第一行首</p>
</blockquote>
<p>vim 文件名</p>
<blockquote>
<p>恢复上次vim打开时崩溃的文件</p>
</blockquote>
<p>vim -r 文件名</p>
<blockquote>
<p>以只读方式放入vim编辑器中</p>
</blockquote>
<p>vim -R 文件名</p>
<blockquote>
<p>打开文件，光标在最后一行首部</p>
</blockquote>
<p>vim + 文件名</p>
<blockquote>
<p>在光标前插入输入的文本</p>
</blockquote>
<p>i</p>
<blockquote>
<p>在光标后插入输入的文本</p>
</blockquote>
<p>a</p>
<blockquote>
<p>在光标所在的行首插入文本</p>
</blockquote>
<p>I（大写i）</p>
<blockquote>
<p>在光标所在行的行尾插入文本</p>
</blockquote>
<p>A</p>
<blockquote>
<p>在光标所在行下面插入新一行，光标在行首</p>
</blockquote>
<p>o</p>
<blockquote>
<p>在光标所在行上面插入新一行，光标在行首</p>
</blockquote>
<p>O</p>
<blockquote>
<p>查找指定字符</p>
</blockquote>
<p>/指定字符</p>
<blockquote>
<p>查找以指定字符为行首的行</p>
</blockquote>
<p>/^指定字符</p>
<blockquote>
<p>查找以指定字符为行尾的行</p>
</blockquote>
<p>/指定字符$</p>
<blockquote>
<p>从光标处向后查找字符串</p>
</blockquote>
<p>?abc<br>按 n 向后查询下一个符合字符<br>按 N 向前查询上一个符合字符</p>
<blockquote>
<p>替换光标所在的字符</p>
</blockquote>
<p>r</p>
<blockquote>
<p>从光标所在位置开始替换字符，直到按esc结束</p>
</blockquote>
<p>R</p>
<blockquote>
<p>将当前所在行所有a1换成a2</p>
</blockquote>
<p>:s/a1/a2/g</p>
<blockquote>
<p>将文件中n1到n2行的所有a1换成a2</p>
</blockquote>
<p>:n1,n2s/a1/a2/g</p>
<blockquote>
<p>将文件中所有a1换成a2</p>
</blockquote>
<p>:g/a1/a2/g</p>
<blockquote>
<p>删除光标所在位置的字符</p>
</blockquote>
<p>x</p>
<blockquote>
<p>删除光标位置到行尾内容</p>
</blockquote>
<p>D</p>
<blockquote>
<p>删除光标所在行</p>
</blockquote>
<p>dd</p>
<blockquote>
<p>删除包括当前行的n行文本</p>
</blockquote>
<p>ndd</p>
<blockquote>
<p>删除光标所在行直到文件末尾所有内容</p>
</blockquote>
<p>dG</p>
<p><code>被删除的文件并不是真正删除，而是放进了剪切板中</code></p>
<blockquote>
<p>将剪切板内容复制到光标后</p>
</blockquote>
<p>p(小写)</p>
<blockquote>
<p>将剪贴板中的内容复制到光标前</p>
</blockquote>
<p>P(大写)</p>
<blockquote>
<p><code>ctrl + c  块选择</code> </p>
</blockquote>
<p>y  复制选定的字符   </p>
<blockquote>
<p>将光标所在行复制到剪切板，前面加数字n，可以复制多行</p>
</blockquote>
<p>yy</p>
<blockquote>
<p>将光标位置单词复制到剪切板</p>
</blockquote>
<p>yw</p>
<blockquote>
<p>保存并退出</p>
</blockquote>
<p>:wq</p>
<blockquote>
<p>不保存就退出</p>
</blockquote>
<p>:q</p>
<blockquote>
<p>保存</p>
</blockquote>
<p>:w</p>
<blockquote>
<p>另存为</p>
</blockquote>
<p>:w 文件名</p>
<p><code>命令后面加! 增加强制性</code></p>
<blockquote>
<p>保存文本并退出v，<code>更通用的一个vim命令</code></p>
</blockquote>
<p>x!</p>
<blockquote>
<p>直接退出vim编辑器</p>
</blockquote>
<p>ZZ</p>
<blockquote>
<p>与下一行数据合并</p>
</blockquote>
<p>J</p>
<blockquote>
<p>复原前一个动作</p>
</blockquote>
<p>u</p>
<blockquote>
<p>重复前一个动作</p>
</blockquote>
<p> <code>.</code> </p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>8.22日报</title>
    <url>/2019/08/22/2019-08-22-22ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p><code>git已经基本完成，今天学习了如何使用vim和vim的常用命令，已经大致地过了一遍，vim学习进度大约70%。</code>  </p>
</blockquote>
<blockquote>
<p><code>并且今天还按照网上的材料整理了一下常用命令，分享了技术博客。</code></p>
</blockquote>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><blockquote>
<p>今天的不足与感悟</p>
</blockquote>
<h3 id="今天的不足"><a href="#今天的不足" class="headerlink" title="今天的不足"></a>今天的不足</h3><p>vim的常用语法挺简单的，但是我看了两节课没去怎么实践去敲，感觉边敲边记会更快一些。</p>
<h3 id="今天的感悟"><a href="#今天的感悟" class="headerlink" title="今天的感悟"></a>今天的感悟</h3><p>代码还是多敲，实践起来记忆得才快，代码敲得多了自然就会了。</p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>8.21技术文档</title>
    <url>/2019/08/21/2019-08-21-21jishu/</url>
    <content><![CDATA[<h1 id="git常用命令整理"><a href="#git常用命令整理" class="headerlink" title="git常用命令整理"></a>git常用命令整理</h1><blockquote>
<p>初始化代码库</p>
</blockquote>
<p>git init     文件名</p>
<blockquote>
<p>克隆远程仓库</p>
</blockquote>
<p>git clone 远程仓库地址</p>
<blockquote>
<p>添加文件到暂存区</p>
</blockquote>
<p>git add 文件  (对文件进行跟踪，再用一次就是将跟踪的文件放到暂存区) </p>
<p>添加当前所有文件到暂存区 git add.或者git add –all</p>
<blockquote>
<p>删除文件,并将这次删除放入暂存区</p>
</blockquote>
<p>git rm  </p>
<blockquote>
<p>停止追踪指定文件，但文件会保留在工作区</p>
</blockquote>
<p>git rm  –cached</p>
<blockquote>
<p>改名文件，并将这个改名放入暂存区</p>
</blockquote>
<p>git mv 老文件名 新文件名</p>
<blockquote>
<p>提交暂存区到仓库区</p>
</blockquote>
<p>git commit -m [备注]</p>
<blockquote>
<p>提交暂存区的指定文件到仓库区</p>
</blockquote>
<p>git commit 文件 -m [备注] （加-a直接提交到仓库区）</p>
<blockquote>
<p>重新提交一次commit，修改提交的备注</p>
</blockquote>
<p>git commit –amend -m [备注]</p>
<blockquote>
<p>重新提交一次commit，并指定文件的新变化</p>
</blockquote>
<p>git commit –amend 文件</p>
<blockquote>
<p>显示有变更的文件</p>
</blockquote>
<p>git status <code>每次commit的时候建议先git status 看一下</code></p>
<blockquote>
<p>显示当前分支的提交历史</p>
</blockquote>
<p>git log</p>
<blockquote>
<p>显示当前分支的操作记录 （包括回退的操作）</p>
</blockquote>
<p>git reflog</p>
<blockquote>
<p>根据关键词搜索历史</p>
</blockquote>
<p>git log -S 关键词</p>
<blockquote>
<p>把暂存区的文件 恢复到工作区</p>
</blockquote>
<p>git checkout 文件名</p>
<blockquote>
<p>恢复暂存区所有文件到工作区</p>
</blockquote>
<p>git checkout .</p>
<blockquote>
<p>回退暂存区的指定文件,工作区不变</p>
</blockquote>
<p>git reset 文件</p>
<blockquote>
<p>回退暂存区与工作区</p>
</blockquote>
<p>git reset –hard</p>
<blockquote>
<p>回退到指定历史：</p>
</blockquote>
<p>git reset 历史</p>
<blockquote>
<p>回退到指定历史操作，同时重置暂存区和工作区</p>
</blockquote>
<p>git reset –hard 历史</p>
<blockquote>
<p>新建一个历史，用来撤销指定的历史并应用到当前分支</p>
</blockquote>
<p>git revert 历史</p>
<blockquote>
<p>显示暂存区和工作区差异</p>
</blockquote>
<p>git diff</p>
<blockquote>
<p>显示暂存区和上一次提交的差异</p>
</blockquote>
<p>git diff –cached 文件</p>
<blockquote>
<p>列出所有本地分支</p>
</blockquote>
<p>git branch</p>
<blockquote>
<p>列出所有远程分支</p>
</blockquote>
<p>git branch -r</p>
<blockquote>
<p>列出所有分支</p>
</blockquote>
<p>git branch -a</p>
<blockquote>
<p>新建分支</p>
</blockquote>
<p>git branch 新分支名称</p>
<blockquote>
<p>新建分支并且切换到该分支</p>
</blockquote>
<p>git checkout -b 新分支名</p>
<blockquote>
<p>新建分支，与制定远程分支建立追踪关系</p>
</blockquote>
<p>git branch –track 分支名 远程分支名</p>
<blockquote>
<p>切换分支</p>
</blockquote>
<p>git checkout 分支名</p>
<blockquote>
<p>在现有分支和制定远程分支之间建立追踪关系</p>
</blockquote>
<p>git branch –set-upstream 分支名 远程分支名</p>
<blockquote>
<p>合并指定分支到当前分支</p>
</blockquote>
<p>git merge 分支名</p>
<blockquote>
<p>删除分支</p>
</blockquote>
<p>git branch -d 分支名</p>
<blockquote>
<p>删除远程分支</p>
</blockquote>
<p>git push origin –delete 远程分支名<br>git branch -dr 远程库/分支名</p>
<blockquote>
<p>下载远程仓库的所有变动</p>
</blockquote>
<p>git fetch 远程仓库</p>
<blockquote>
<p>显示所有远程仓库 </p>
</blockquote>
<p>git remote -v</p>
<blockquote>
<p>查看某个远程库的信息</p>
</blockquote>
<p>git remote show 远程库</p>
<blockquote>
<p>增加一个远程库，并命名</p>
</blockquote>
<p>git remote add 起的名 远程库的地址</p>
<blockquote>
<p>取回远程库的变化，并与本地分支自动合并</p>
</blockquote>
<p>git pull 远程库 分支(如果提示无关历史无法合并，<br>可以使用：–allow-unrelated-histories)</p>
<blockquote>
<p>上传本地指定分支到远程库</p>
</blockquote>
<p>git push  远程库 分支</p>
<blockquote>
<p>强行推送分支到远程仓库</p>
</blockquote>
<p>git push 远程库 –force </p>
<blockquote>
<p>推送所有分支到远程仓库</p>
</blockquote>
<p>git pus 远程库 –all</p>
<blockquote>
<p>隐藏未提交的修改，用于后续恢复到当前工作目录：</p>
</blockquote>
<p>git stash</p>
<blockquote>
<p>将隐藏的修改应用到当前分支对应目录上</p>
</blockquote>
<p>git stash pop</p>
<blockquote>
<p>列出所有标签</p>
</blockquote>
<p>git tag</p>
<blockquote>
<p>在当前操作历史上添加标签</p>
</blockquote>
<p>git tag 标签名</p>
<blockquote>
<p>新建一个标签在指定历史</p>
</blockquote>
<p>git tag 标签名 历史</p>
<blockquote>
<p>删除本地标签</p>
</blockquote>
<p>git tag -d 标签名</p>
<blockquote>
<p>删除远程标签</p>
</blockquote>
<p>git push origin :refs/tags/标签名</p>
<blockquote>
<p> 查看标签信息</p>
</blockquote>
<p>git show 标签名</p>
<blockquote>
<p>提交指定标签</p>
</blockquote>
<p>git push 远程库 标签</p>
<blockquote>
<p>提交所有标签</p>
</blockquote>
<p>git push 远程库 –tags</p>
<blockquote>
<p>新建一个分支 指向某个标签</p>
</blockquote>
<p>git checkout -b 分支名 标签</p>
<h3 id="最后放上一张网上找到的git常用命令表："><a href="#最后放上一张网上找到的git常用命令表：" class="headerlink" title="最后放上一张网上找到的git常用命令表："></a>最后放上一张网上找到的git常用命令表：</h3><p><img src="http://zhengyupeng.top/images/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%A8.png" alt="git常用命令"></p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>8.21日报</title>
    <url>/2019/08/21/2019-08-21-21ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p><code>今天勉强通过了老师的测试 git完成度在90%，并且今天整理了git常用命令。</code></p>
</blockquote>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><blockquote>
<p>今天的不足与感悟</p>
</blockquote>
<h3 id="今天的不足"><a href="#今天的不足" class="headerlink" title="今天的不足"></a>今天的不足</h3><p>考试的时候在写 git commit时候忘记先使用 git status 看一看，平时自己记笔记的时候还特意记过这一点，考试的时候还忘记了，这种马虎要长记性。还有今天学习效率问题，虽然勉强过了老师的考试，但是今天在学习时间的学习效率自我感觉很差 看的git官方后面的概念文档很蒙，感觉今天往后看没什么太大进度，只有一点大致了解。</p>
<h3 id="今天的感悟"><a href="#今天的感悟" class="headerlink" title="今天的感悟"></a>今天的感悟</h3><p>在一个知识点搞不明白时候一定要自己亲手自己实验几遍，实验几遍不会再去问其他同学，其他同学有问题也要勤看，尽管自己也不能会，等他解决问题之后再去看看他怎么解决的，以后注意同样问题。<br>总之个人的发展离不开团体。</p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>8.20日报</title>
    <url>/2019/08/20/2019-08-20-20ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p>今天对git的一些基础命令熟练度80%，又继续往后看官方的文档，关于git的实际工作流程，看了举的几个例子，也大致了解了工作流程。</p>
</blockquote>
<p> <strong>git团队工作大致流程例子：</strong> </p>
<p> 有一个远程仓库  </p>
<p> 第一个人，克隆了仓库，作了些更新，在本地提交。   </p>
<p> 第二个开发者，一样这么做：克隆仓库，提交更新。</p>
<p> 现在，第二个人将她的工作推送到服务器上，第一个人 也尝试推送自己的工作上去。</p>
<p>第一个人的推送操作被驳回，因为 第二个人已经推送了新的数据上去。</p>
<p>这时候第一个人需要把远程库的更新拉下来同步才能完成推送。</p>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><blockquote>
<p>今天的不足与感悟</p>
</blockquote>
<h3 id="今天的不足"><a href="#今天的不足" class="headerlink" title="今天的不足"></a>今天的不足</h3><p>今天看git官方文档的概念文档了，但是感觉自己看得很笼统，学习效率很低，导致越看越有点蒙。</p>
<h3 id="今天的感悟"><a href="#今天的感悟" class="headerlink" title="今天的感悟"></a>今天的感悟</h3><p>今天我的U盘出现了没办法打开的情况，在ubuntu的系统上也不是很容易下u盘修复的工具，自己弄了1个多小时无果后寻求了老师的帮助，老师几下就解决了问题。这让我深深地体会到了经验的重要，一定要多去实践，经验才是知识进步的堆积。</p>
]]></content>
      <categories>
        <category>git进度</category>
      </categories>
      <tags>
        <tag>git命令</tag>
      </tags>
  </entry>
  <entry>
    <title>8.19日报</title>
    <url>/2019/08/19/2019-08-19-19ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p>今天又进一步地熟练了git的命令，以及深入地了解到了git分支的流程和使用方法</p>
</blockquote>
<p>分支的主要作用就是多个人可以同时利用分支修改自己要实现的的功能模块，然后再上传到远程仓库，达到多人同时作业，大大提高了开发效率。</p>
<p> <strong>主要知识点：</strong> </p>
<p> 创建分支：   git branch </p>
<p>查看分支：   git branch</p>
<p>切换分支：  git checkout</p>
<p>创建分支并转到： git checkout -b</p>
<p>删除分支： git branch -d</p>
<p>合并当前分支与指定分支： git merge</p>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><blockquote>
<p>今天的不足与感悟</p>
</blockquote>
<h3 id="今天的不足"><a href="#今天的不足" class="headerlink" title="今天的不足"></a>今天的不足</h3><p>今天轮到我上台讲知识点了，但是没有去准备太多的知识点去讲，基础知识也不够扎实，出现了很多预料之外的错误，准备不够充分。</p>
<h3 id="今天的感悟"><a href="#今天的感悟" class="headerlink" title="今天的感悟"></a>今天的感悟</h3><p>上台之后逻辑不是很清楚，先讲什么后讲什么，让我理解到了程序员不光要会敲代码也要会表达。</p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>8.17日报</title>
    <url>/2019/08/17/2019-08-17-17ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p>今天我深入了解并学习了git</p>
</blockquote>
<h4 id="今天下来我对于git的理解："><a href="#今天下来我对于git的理解：" class="headerlink" title="今天下来我对于git的理解："></a>今天下来我对于git的理解：</h4><p>经过阅读了官方文档和前辈们整理的博客，我了解到了git对于项目开发的重要性，每个人可以根据不同的需求创建分支，修改自己的功能模块，然后再重新合并到服务器上的代码</p>
<h4 id="今天的学习成果："><a href="#今天的学习成果：" class="headerlink" title="今天的学习成果："></a>今天的学习成果：</h4><p> 今天已经把博客基本做出一个可以交付的初成品了，下午开始学习git语法，现在已经了解了git的一些基础语法，也大概了解了git的工作原理与操作。</p>
<p> <strong>今日不足：</strong>  电脑的有线网不知为何无法连接，在寻找各种方法解决无果后甚至重做系统，导致了浪费了过多的学习时间。git的学习效率也不够高，感觉看得很乱，看文档没有条理性，静不下心来看文档。</p>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><blockquote>
<p>今天的不足与感悟</p>
</blockquote>
<h3 id="今天的不足"><a href="#今天的不足" class="headerlink" title="今天的不足"></a>今天的不足</h3><p>今天将自己做的博客上交检查了，在一个之前完成的功能出现了问题，自己没有在交项目时候提前看一下，这件事我会记住的。</p>
<h3 id="今天的感悟"><a href="#今天的感悟" class="headerlink" title="今天的感悟"></a>今天的感悟</h3><p>交项目的时候一定要将自己的所有功能都检查一边，不要因为之前解决了就不再看那个功能了，否则也许改别的时候把功能改了，否则自己麻烦别人也麻烦。</p>
]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>8.16日报</title>
    <url>/2019/08/16/2019-08-16-16ribao/</url>
    <content><![CDATA[<h1 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h1><blockquote>
<p>今天主要学习了ubuntu系统的安装与git的使用</p>
</blockquote>
<h4 id="关于ubuntu系统的安装"><a href="#关于ubuntu系统的安装" class="headerlink" title="关于ubuntu系统的安装"></a>关于ubuntu系统的安装</h4><p>在网上下载了u盘启动盘制作，将自己的u盘做成了启动盘<br>，经过四五次的反复安装与思考终于安装成功了。</p>
<p> <strong>今日不足：</strong> 由于第一次接触ubuntu系统，准备又不够充分，导致了安装了四五次才能够成功。</p>
<p><em>关于git的使用</em></p>
<p> 今天布置的任务是成功在github上发布自己的博客，我从最开始的不知道git是什么，在网上一步步地查询，逐渐深入了解到了git与github，最终成功创建了github并构建了存储库。</p>
<p> <strong>今日不足：</strong> 在使用jekyll模板时候修改模板时没有参考官方文档，自己乱打文档去寻找，大大降低了进度。</p>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><blockquote>
<p>今天的不足与感悟</p>
</blockquote>
<h3 id="今天的不足"><a href="#今天的不足" class="headerlink" title="今天的不足"></a>今天的不足</h3><p>短短的一天自学模式，我就已经发现了自己的很多问题：不喜欢查看官方文档，不喜欢多问问做出来的同学喜欢自己抠问题。</p>
<h3 id="今天的感悟"><a href="#今天的感悟" class="headerlink" title="今天的感悟"></a>今天的感悟</h3><p>永远都有学的比较好的和学的一般的，既然自己学的不够好就要付出更加多的努力。</p>
]]></content>
      <categories>
        <category>系统与命令</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>git</tag>
      </tags>
  </entry>
</search>
